//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace libavfilter
{
    public enum AVFILTER_AUTO_CONVERT
    {
        /// <summary>all automatic conversions enabled</summary>
        AVFILTER_AUTO_CONVERT_ALL = 0,
        /// <summary>all automatic conversions disabled</summary>
        AVFILTER_AUTO_CONVERT_NONE = -1
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVFilterGraph
    {
        [FieldOffset(0)]
        public AVClass* av_class;

        [FieldOffset(4)]
        public uint filter_count;

        [FieldOffset(8)]
        public AVFilterContext* filters;

        /// <summary>
        /// < sws options to use for the auto-inserted scale filters
        /// </summary>
        [FieldOffset(12)]
        public sbyte* scale_sws_opts;

        /// <summary>
        /// Private fields
        /// 
        /// The following fields are for internal use only.
        /// Their type, offset, number and semantic can change without notice.
        /// </summary>
        [FieldOffset(16)]
        public AVFilterLink* sink_links;

        [FieldOffset(20)]
        public int sink_links_count;

        [FieldOffset(24)]
        public uint disable_auto_convert;
    }

    /// <summary>
    /// A linked-list of the inputs/outputs of the filter chain.
    /// 
    /// This is mainly useful for avfilter_graph_parse() /
    /// avfilter_graph_parse2(),
    /// where it is used to communicate open (unlinked) inputs and outputs from
    /// and
    /// to the caller.
    /// This struct specifies, per each not connected pad contained in the
    /// graph, the
    /// filter context and the pad index required for establishing a link.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVFilterInOut
    {
        /// <summary>
        /// </summary>
        [FieldOffset(0)]
        public sbyte* name;

        /// <summary>
        /// </summary>
        [FieldOffset(4)]
        public AVFilterContext* filter_ctx;

        /// <summary>
        /// </summary>
        [FieldOffset(8)]
        public int pad_idx;

        /// <summary>
        /// </summary>
        [FieldOffset(12)]
        public AVFilterInOut* next;
    }

    public unsafe partial class libavfilter
    {
        /// <summary>
        /// Allocate a filter graph.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_alloc")]
        internal static extern AVFilterGraph* avfilter_graph_alloc();

        /// <summary>
        /// Get a filter instance with name name from graph.
        /// 
        /// @return the pointer to the found filter instance or NULL if it
        /// cannot be found.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_get_filter")]
        internal static extern AVFilterContext* avfilter_graph_get_filter(AVFilterGraph* graph, sbyte* name);

        /// <summary>
        /// Add an existing filter instance to a filter graph.
        /// 
        /// @param graphctx  the filter graph
        /// @param filter the filter to be added
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_add_filter")]
        internal static extern int avfilter_graph_add_filter(AVFilterGraph* graphctx, AVFilterContext* filter);

        /// <summary>
        /// Create and add a filter instance into an existing graph.
        /// The filter instance is created from the filter filt and inited
        /// with the parameters args and opaque.
        /// 
        /// In case of success put in *filt_ctx the pointer to the created
        /// filter instance, otherwise set *filt_ctx to NULL.
        /// 
        /// @param name the instance name to give to the created filter instance
        /// @param graph_ctx the filter graph
        /// @return a negative AVERROR error code in case of failure, a non
        /// negative value otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_create_filter")]
        internal static extern int avfilter_graph_create_filter(AVFilterContext* filt_ctx, AVFilter* filt, global::System.IntPtr name, global::System.IntPtr args, global::System.IntPtr opaque, AVFilterGraph* graph_ctx);

        /// <summary>
        /// Enable or disable automatic format conversion inside the graph.
        /// 
        /// Note that format conversion can still happen inside explicitly inserted
        /// scale and aconvert filters.
        /// 
        /// @param flags  any of the AVFILTER_AUTO_CONVERT_* constants
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_set_auto_convert")]
        internal static extern void avfilter_graph_set_auto_convert(AVFilterGraph* graph, uint flags);

        /// <summary>
        /// Check validity and configure all the links and formats in the graph.
        /// 
        /// @param graphctx the filter graph
        /// @param log_ctx context used for logging
        /// @return 0 in case of success, a negative AVERROR code otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_config")]
        internal static extern int avfilter_graph_config(AVFilterGraph* graphctx, global::System.IntPtr log_ctx);

        /// <summary>
        /// Free a graph, destroy its links, and set *graph to NULL.
        /// If *graph is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_free")]
        internal static extern void avfilter_graph_free(AVFilterGraph* graph);

        /// <summary>
        /// Allocate a single AVFilterInOut entry.
        /// Must be freed with avfilter_inout_free().
        /// @return allocated AVFilterInOut on success, NULL on failure.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_inout_alloc")]
        internal static extern AVFilterInOut* avfilter_inout_alloc();

        /// <summary>
        /// Free the supplied list of AVFilterInOut and set *inout to NULL.
        /// If *inout is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_inout_free")]
        internal static extern void avfilter_inout_free(AVFilterInOut* inout);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// 
        /// @param graph   the filter graph where to link the parsed graph context
        /// @param filters string to be parsed
        /// @param inputs  pointer to a linked list to the inputs of the graph, may
        /// be NULL.
        /// If non-NULL, *inputs is updated to contain the list of open inputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// @param outputs pointer to a linked list to the outputs of the graph,
        /// may be NULL.
        /// If non-NULL, *outputs is updated to contain the list of open outputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// @return non negative on success, a negative AVERROR code on error
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_parse")]
        internal static extern int avfilter_graph_parse(AVFilterGraph* graph, global::System.IntPtr filters, AVFilterInOut* inputs, AVFilterInOut* outputs, global::System.IntPtr log_ctx);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// 
        /// @param[in]  graph   the filter graph where to link the parsed graph
        /// context
        /// @param[in]  filters string to be parsed
        /// @param[out] inputs  a linked list of all free (unlinked) inputs of the
        /// parsed graph will be returned here. It is to be freed
        /// by the caller using avfilter_inout_free().
        /// @param[out] outputs a linked list of all free (unlinked) outputs of the
        /// parsed graph will be returned here. It is to be freed by the
        /// caller using avfilter_inout_free().
        /// @return zero on success, a negative AVERROR code on error
        /// 
        /// @note the difference between avfilter_graph_parse2() and
        /// avfilter_graph_parse() is that in avfilter_graph_parse(), the caller
        /// provides
        /// the lists of inputs and outputs, which therefore must be known before
        /// calling
        /// the function. On the other hand, avfilter_graph_parse2() \em returns
        /// the
        /// inputs and outputs that are left unlinked after parsing the graph and
        /// the
        /// caller then deals with them. Another difference is that in
        /// avfilter_graph_parse(), the inputs parameter describes inputs of the
        /// <em>already existing</em> part of the graph; i.e. from the point of
        /// view of
        /// the newly created part, they are outputs. Similarly the outputs
        /// parameter
        /// describes outputs of the already existing filters, which are provided
        /// as
        /// inputs to the parsed filters.
        /// avfilter_graph_parse2() takes the opposite approach -- it makes no
        /// reference
        /// whatsoever to already existing parts of the graph and the inputs
        /// parameter
        /// will on return contain inputs of the newly parsed part of the graph.
        /// Analogously the outputs parameter will contain outputs of the newly
        /// created
        /// filters.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_parse2")]
        internal static extern int avfilter_graph_parse2(AVFilterGraph* graph, global::System.IntPtr filters, AVFilterInOut* inputs, AVFilterInOut* outputs);

        /// <summary>
        /// Send a command to one or more filter instances.
        /// 
        /// @param graph  the filter graph
        /// @param target the filter(s) to which the command should be sent
        /// "all" sends to all filters
        /// otherwise it can be a filter or filter instance name
        /// which will send the command to all matching filters.
        /// @param cmd    the command to sent, for handling simplicity all commands
        /// must be alphanumeric only
        /// @param arg    the argument for the command
        /// @param res    a buffer with size res_size where the filter(s) can
        /// return a response.
        /// 
        /// @returns >=0 on success otherwise an error code.
        /// AVERROR(ENOSYS) on unsupported commands
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_send_command")]
        internal static extern int avfilter_graph_send_command(AVFilterGraph* graph, global::System.IntPtr target, global::System.IntPtr cmd, global::System.IntPtr arg, sbyte* res, int res_len, int flags);

        /// <summary>
        /// Queue a command for one or more filter instances.
        /// 
        /// @param graph  the filter graph
        /// @param target the filter(s) to which the command should be sent
        /// "all" sends to all filters
        /// otherwise it can be a filter or filter instance name
        /// which will send the command to all matching filters.
        /// @param cmd    the command to sent, for handling simplicity all commands
        /// must be alphanummeric only
        /// @param arg    the argument for the command
        /// @param ts     time at which the command should be sent to the filter
        /// 
        /// @note As this executes commands after this function returns, no return
        /// code
        /// from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not
        /// supported.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_queue_command")]
        internal static extern int avfilter_graph_queue_command(AVFilterGraph* graph, global::System.IntPtr target, global::System.IntPtr cmd, global::System.IntPtr arg, int flags, double ts);

        /// <summary>
        /// Dump a graph into a human-readable string representation.
        /// 
        /// @param graph    the graph to dump
        /// @param options  formatting options; currently ignored
        /// @return  a string, or NULL in case of memory allocation failure;
        /// the string must be freed using av_free
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_dump")]
        internal static extern sbyte* avfilter_graph_dump(AVFilterGraph* graph, global::System.IntPtr options);

        /// <summary>
        /// Request a frame on the oldest sink link.
        /// 
        /// If the request returns AVERROR_EOF, try the next.
        /// 
        /// Note that this function is not meant to be the sole scheduling
        /// mechanism
        /// of a filtergraph, only a convenience function to help drain a
        /// filtergraph
        /// in a balanced way under normal circumstances.
        /// 
        /// Also note that AVERROR_EOF does not mean that frames did not arrive on
        /// some of the sinks during the process.
        /// When there are multiple sink links, in case the requested link
        /// returns an EOF, this may cause a filter to flush pending frames
        /// which are sent to another sink link, although unrequested.
        /// 
        /// @return  the return value of ff_request_frame(),
        /// or AVERROR_EOF if all links returned AVERROR_EOF
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avfilter_graph_request_oldest")]
        internal static extern int avfilter_graph_request_oldest(AVFilterGraph* graph);
    }
}
