//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using FFmpeg;

namespace FFmpeg
{
    public unsafe static partial class libavfilter
    {
        public enum AVFILTER_AUTO_CONVERT
        {
            /// <summary>all automatic conversions enabled</summary>
            AVFILTER_AUTO_CONVERT_ALL = 0,
            /// <summary>all automatic conversions disabled</summary>
            AVFILTER_AUTO_CONVERT_NONE = -1
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterGraph
        {
            public libavutil.AVClass* av_class;

            public uint filter_count;

            public libavfilter.AVFilterContext** filters;

            /// <summary>
            /// sws options to use for the auto-inserted scale filters
            /// </summary>
            public sbyte* scale_sws_opts;

            /// <summary>
            /// Private fields
            /// 
            /// The following fields are for internal use only.
            /// Their type, offset, number and semantic can change without notice.
            /// </summary>
            public libavfilter.AVFilterLink** sink_links;

            public int sink_links_count;

            public uint disable_auto_convert;
        }

        /// <summary>
        /// A linked-list of the inputs/outputs of the filter chain.
        /// 
        /// This is mainly useful for avfilter_graph_parse() /
        /// avfilter_graph_parse2(),
        /// where it is used to communicate open (unlinked) inputs and outputs from
        /// and
        /// to the caller.
        /// This struct specifies, per each not connected pad contained in the
        /// graph, the
        /// filter context and the pad index required for establishing a link.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterInOut
        {
            /// <summary>
            /// unique name for this input/output in the list
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// filter context associated to this input/output
            /// </summary>
            public libavfilter.AVFilterContext* filter_ctx;

            /// <summary>
            /// index of the filt_ctx pad to use for linking
            /// </summary>
            public int pad_idx;

            /// <summary>
            /// next input/input in the list, NULL if this is the last
            /// </summary>
            public libavfilter.AVFilterInOut* next;
        }

        /// <summary>
        /// Allocate a filter graph.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_alloc")]
        public static extern libavfilter.AVFilterGraph* avfilter_graph_alloc();

        /// <summary>
        /// Get a filter instance with name name from graph.
        /// 
        /// @return the pointer to the found filter instance or NULL if it
        /// cannot be found.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_get_filter")]
        public static extern libavfilter.AVFilterContext* avfilter_graph_get_filter(libavfilter.AVFilterGraph* graph, System.Text.StringBuilder name);

        /// <summary>
        /// Add an existing filter instance to a filter graph.
        /// 
        /// @param graphctx  the filter graph
        /// @param filter the filter to be added
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_add_filter")]
        public static extern int avfilter_graph_add_filter(libavfilter.AVFilterGraph* graphctx, libavfilter.AVFilterContext* filter);

        /// <summary>
        /// Create and add a filter instance into an existing graph.
        /// The filter instance is created from the filter filt and inited
        /// with the parameters args and opaque.
        /// 
        /// In case of success put in *filt_ctx the pointer to the created
        /// filter instance, otherwise set *filt_ctx to NULL.
        /// 
        /// @param name the instance name to give to the created filter instance
        /// @param graph_ctx the filter graph
        /// @return a negative AVERROR error code in case of failure, a non
        /// negative value otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_create_filter")]
        public static extern int avfilter_graph_create_filter(libavfilter.AVFilterContext** filt_ctx, libavfilter.AVFilter* filt, string name, string args, void* opaque, libavfilter.AVFilterGraph* graph_ctx);

        /// <summary>
        /// Create and add a filter instance into an existing graph.
        /// The filter instance is created from the filter filt and inited
        /// with the parameters args and opaque.
        /// 
        /// In case of success put in *filt_ctx the pointer to the created
        /// filter instance, otherwise set *filt_ctx to NULL.
        /// 
        /// @param name the instance name to give to the created filter instance
        /// @param graph_ctx the filter graph
        /// @return a negative AVERROR error code in case of failure, a non
        /// negative value otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_create_filter")]
        public static extern int avfilter_graph_create_filter(ref libavfilter.AVFilterContext* filt_ctx, libavfilter.AVFilter* filt, string name, string args, void* opaque, libavfilter.AVFilterGraph* graph_ctx);

        /// <summary>
        /// Enable or disable automatic format conversion inside the graph.
        /// 
        /// Note that format conversion can still happen inside explicitly inserted
        /// scale and aconvert filters.
        /// 
        /// @param flags  any of the AVFILTER_AUTO_CONVERT_* constants
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_set_auto_convert")]
        public static extern void avfilter_graph_set_auto_convert(libavfilter.AVFilterGraph* graph, uint flags);

        /// <summary>
        /// Check validity and configure all the links and formats in the graph.
        /// 
        /// @param graphctx the filter graph
        /// @param log_ctx context used for logging
        /// @return 0 in case of success, a negative AVERROR code otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_config")]
        public static extern int avfilter_graph_config(libavfilter.AVFilterGraph* graphctx, void* log_ctx);

        /// <summary>
        /// Free a graph, destroy its links, and set *graph to NULL.
        /// If *graph is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_free")]
        public static extern void avfilter_graph_free(libavfilter.AVFilterGraph** graph);

        /// <summary>
        /// Free a graph, destroy its links, and set *graph to NULL.
        /// If *graph is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_free")]
        public static extern void avfilter_graph_free(ref libavfilter.AVFilterGraph* graph);

        /// <summary>
        /// Allocate a single AVFilterInOut entry.
        /// Must be freed with avfilter_inout_free().
        /// @return allocated AVFilterInOut on success, NULL on failure.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_inout_alloc")]
        public static extern libavfilter.AVFilterInOut* avfilter_inout_alloc();

        /// <summary>
        /// Free the supplied list of AVFilterInOut and set *inout to NULL.
        /// If *inout is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_inout_free")]
        public static extern void avfilter_inout_free(libavfilter.AVFilterInOut** inout);

        /// <summary>
        /// Free the supplied list of AVFilterInOut and set *inout to NULL.
        /// If *inout is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_inout_free")]
        public static extern void avfilter_inout_free(ref libavfilter.AVFilterInOut* inout);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// 
        /// @param graph   the filter graph where to link the parsed graph context
        /// @param filters string to be parsed
        /// @param inputs  pointer to a linked list to the inputs of the graph, may
        /// be NULL.
        /// If non-NULL, *inputs is updated to contain the list of open inputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// @param outputs pointer to a linked list to the outputs of the graph,
        /// may be NULL.
        /// If non-NULL, *outputs is updated to contain the list of open outputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// @return non negative on success, a negative AVERROR code on error
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse")]
        public static extern int avfilter_graph_parse(libavfilter.AVFilterGraph* graph, string filters, libavfilter.AVFilterInOut** inputs, libavfilter.AVFilterInOut** outputs, void* log_ctx);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// 
        /// @param graph   the filter graph where to link the parsed graph context
        /// @param filters string to be parsed
        /// @param inputs  pointer to a linked list to the inputs of the graph, may
        /// be NULL.
        /// If non-NULL, *inputs is updated to contain the list of open inputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// @param outputs pointer to a linked list to the outputs of the graph,
        /// may be NULL.
        /// If non-NULL, *outputs is updated to contain the list of open outputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// @return non negative on success, a negative AVERROR code on error
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse")]
        public static extern int avfilter_graph_parse(libavfilter.AVFilterGraph* graph, string filters, ref libavfilter.AVFilterInOut* inputs, ref libavfilter.AVFilterInOut* outputs, void* log_ctx);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// 
        /// @param[in]  graph   the filter graph where to link the parsed graph
        /// context
        /// @param[in]  filters string to be parsed
        /// @param[out] inputs  a linked list of all free (unlinked) inputs of the
        /// parsed graph will be returned here. It is to be freed
        /// by the caller using avfilter_inout_free().
        /// @param[out] outputs a linked list of all free (unlinked) outputs of the
        /// parsed graph will be returned here. It is to be freed by the
        /// caller using avfilter_inout_free().
        /// @return zero on success, a negative AVERROR code on error
        /// 
        /// @note the difference between avfilter_graph_parse2() and
        /// avfilter_graph_parse() is that in avfilter_graph_parse(), the caller
        /// provides
        /// the lists of inputs and outputs, which therefore must be known before
        /// calling
        /// the function. On the other hand, avfilter_graph_parse2() \em returns
        /// the
        /// inputs and outputs that are left unlinked after parsing the graph and
        /// the
        /// caller then deals with them. Another difference is that in
        /// avfilter_graph_parse(), the inputs parameter describes inputs of the
        /// em>already existing</em> part of the graph; i.e. from the point of view
        /// of
        /// the newly created part, they are outputs. Similarly the outputs
        /// parameter
        /// describes outputs of the already existing filters, which are provided
        /// as
        /// inputs to the parsed filters.
        /// avfilter_graph_parse2() takes the opposite approach -- it makes no
        /// reference
        /// whatsoever to already existing parts of the graph and the inputs
        /// parameter
        /// will on return contain inputs of the newly parsed part of the graph.
        /// Analogously the outputs parameter will contain outputs of the newly
        /// created
        /// filters.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse2")]
        public static extern int avfilter_graph_parse2(libavfilter.AVFilterGraph* graph, string filters, libavfilter.AVFilterInOut** inputs, libavfilter.AVFilterInOut** outputs);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// 
        /// @param[in]  graph   the filter graph where to link the parsed graph
        /// context
        /// @param[in]  filters string to be parsed
        /// @param[out] inputs  a linked list of all free (unlinked) inputs of the
        /// parsed graph will be returned here. It is to be freed
        /// by the caller using avfilter_inout_free().
        /// @param[out] outputs a linked list of all free (unlinked) outputs of the
        /// parsed graph will be returned here. It is to be freed by the
        /// caller using avfilter_inout_free().
        /// @return zero on success, a negative AVERROR code on error
        /// 
        /// @note the difference between avfilter_graph_parse2() and
        /// avfilter_graph_parse() is that in avfilter_graph_parse(), the caller
        /// provides
        /// the lists of inputs and outputs, which therefore must be known before
        /// calling
        /// the function. On the other hand, avfilter_graph_parse2() \em returns
        /// the
        /// inputs and outputs that are left unlinked after parsing the graph and
        /// the
        /// caller then deals with them. Another difference is that in
        /// avfilter_graph_parse(), the inputs parameter describes inputs of the
        /// em>already existing</em> part of the graph; i.e. from the point of view
        /// of
        /// the newly created part, they are outputs. Similarly the outputs
        /// parameter
        /// describes outputs of the already existing filters, which are provided
        /// as
        /// inputs to the parsed filters.
        /// avfilter_graph_parse2() takes the opposite approach -- it makes no
        /// reference
        /// whatsoever to already existing parts of the graph and the inputs
        /// parameter
        /// will on return contain inputs of the newly parsed part of the graph.
        /// Analogously the outputs parameter will contain outputs of the newly
        /// created
        /// filters.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse2")]
        public static extern int avfilter_graph_parse2(libavfilter.AVFilterGraph* graph, string filters, ref libavfilter.AVFilterInOut* inputs, ref libavfilter.AVFilterInOut* outputs);

        /// <summary>
        /// Send a command to one or more filter instances.
        /// 
        /// @param graph  the filter graph
        /// @param target the filter(s) to which the command should be sent
        /// "all" sends to all filters
        /// otherwise it can be a filter or filter instance name
        /// which will send the command to all matching filters.
        /// @param cmd    the command to sent, for handling simplicity all commands
        /// must be alphanumeric only
        /// @param arg    the argument for the command
        /// @param res    a buffer with size res_size where the filter(s) can
        /// return a response.
        /// 
        /// @returns >=0 on success otherwise an error code.
        /// AVERROR(ENOSYS) on unsupported commands
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_send_command")]
        public static extern int avfilter_graph_send_command(libavfilter.AVFilterGraph* graph, string target, string cmd, string arg, System.Text.StringBuilder res, int res_len, int flags);

        /// <summary>
        /// Queue a command for one or more filter instances.
        /// 
        /// @param graph  the filter graph
        /// @param target the filter(s) to which the command should be sent
        /// "all" sends to all filters
        /// otherwise it can be a filter or filter instance name
        /// which will send the command to all matching filters.
        /// @param cmd    the command to sent, for handling simplicity all commands
        /// must be alphanummeric only
        /// @param arg    the argument for the command
        /// @param ts     time at which the command should be sent to the filter
        /// 
        /// @note As this executes commands after this function returns, no return
        /// code
        /// from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not
        /// supported.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_queue_command")]
        public static extern int avfilter_graph_queue_command(libavfilter.AVFilterGraph* graph, string target, string cmd, string arg, int flags, double ts);

        /// <summary>
        /// Dump a graph into a human-readable string representation.
        /// 
        /// @param graph    the graph to dump
        /// @param options  formatting options; currently ignored
        /// @return  a string, or NULL in case of memory allocation failure;
        /// the string must be freed using av_free
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_dump")]
        public static extern sbyte* avfilter_graph_dump(libavfilter.AVFilterGraph* graph, string options);

        /// <summary>
        /// Request a frame on the oldest sink link.
        /// 
        /// If the request returns AVERROR_EOF, try the next.
        /// 
        /// Note that this function is not meant to be the sole scheduling
        /// mechanism
        /// of a filtergraph, only a convenience function to help drain a
        /// filtergraph
        /// in a balanced way under normal circumstances.
        /// 
        /// Also note that AVERROR_EOF does not mean that frames did not arrive on
        /// some of the sinks during the process.
        /// When there are multiple sink links, in case the requested link
        /// returns an EOF, this may cause a filter to flush pending frames
        /// which are sent to another sink link, although unrequested.
        /// 
        /// @return  the return value of ff_request_frame(),
        /// or AVERROR_EOF if all links returned AVERROR_EOF
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_request_oldest")]
        public static extern int avfilter_graph_request_oldest(libavfilter.AVFilterGraph* graph);
    }
}
