//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace libavfilter
{
    /// <summary>
    /// Struct to use for initializing a buffersink context.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVBufferSinkParams
    {
        /// <summary>
        /// < list of allowed pixel formats, terminated by PIX_FMT_NONE
        /// </summary>
        [FieldOffset(0)]
        public PixelFormat pixel_fmts;
    }

    /// <summary>
    /// Struct to use for initializing an abuffersink context.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVABufferSinkParams
    {
        /// <summary>
        /// < list of allowed sample formats, terminated by AV_SAMPLE_FMT_NONE
        /// </summary>
        [FieldOffset(0)]
        public AVSampleFormat sample_fmts;

        /// <summary>
        /// < list of allowed channel layouts, terminated by -1
        /// </summary>
        [FieldOffset(4)]
        public long* channel_layouts;
    }

    public unsafe partial class libavfilter
    {
        /// <summary>
        /// Create an AVBufferSinkParams structure.
        /// 
        /// Must be freed with av_free().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_buffersink_params_alloc")]
        internal static extern AVBufferSinkParams* av_buffersink_params_alloc();

        /// <summary>
        /// Create an AVABufferSinkParams structure.
        /// 
        /// Must be freed with av_free().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_abuffersink_params_alloc")]
        internal static extern AVABufferSinkParams* av_abuffersink_params_alloc();

        /// <summary>
        /// Set the frame size for an audio buffer sink.
        /// 
        /// All calls to av_buffersink_get_buffer_ref will return a buffer with
        /// exactly the specified number of samples, or AVERROR(EAGAIN) if there is
        /// not enough. The last buffer at EOF will be padded with 0.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_buffersink_set_frame_size")]
        internal static extern void av_buffersink_set_frame_size(AVFilterContext* ctx, uint frame_size);

        /// <summary>
        /// Get an audio/video buffer data from buffer_sink and put it in bufref.
        /// 
        /// This function works with both audio and video buffer sinks.
        /// 
        /// @param buffer_sink pointer to a buffersink or abuffersink context
        /// @param flags a combination of AV_BUFFERSINK_FLAG_* flags
        /// @return >= 0 in case of success, a negative AVERROR code in case of
        /// failure
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_buffersink_get_buffer_ref")]
        internal static extern int av_buffersink_get_buffer_ref(AVFilterContext* buffer_sink, AVFilterBufferRef* bufref, int flags);

        /// <summary>
        /// Get the number of immediately available frames.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_buffersink_poll_frame")]
        internal static extern int av_buffersink_poll_frame(AVFilterContext* ctx);

        /// <summary>
        /// Get the frame rate of the input.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_buffersink_get_frame_rate")]
        internal static extern AVRational* av_buffersink_get_frame_rate(AVFilterContext* ctx);

        /// <summary>
        /// Get a buffer with filtered data from sink and put it in buf.
        /// 
        /// @param ctx pointer to a context of a buffersink or abuffersink
        /// AVFilter.
        /// @param buf pointer to the buffer will be written here if buf is
        /// non-NULL. buf
        /// must be freed by the caller using avfilter_unref_buffer().
        /// Buf may also be NULL to query whether a buffer is ready to be
        /// output.
        /// 
        /// @return >= 0 in case of success, a negative AVERROR code in case of
        /// failure.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_buffersink_read")]
        internal static extern int av_buffersink_read(AVFilterContext* ctx, AVFilterBufferRef* buf);

        /// <summary>
        /// Same as av_buffersink_read, but with the ability to specify the number
        /// of
        /// samples read. This function is less efficient than
        /// av_buffersink_read(),
        /// because it copies the data around.
        /// 
        /// @param ctx pointer to a context of the abuffersink AVFilter.
        /// @param buf pointer to the buffer will be written here if buf is
        /// non-NULL. buf
        /// must be freed by the caller using avfilter_unref_buffer(). buf
        /// will contain exactly nb_samples audio samples, except at the end
        /// of stream, when it can contain less than nb_samples.
        /// Buf may also be NULL to query whether a buffer is ready to be
        /// output.
        /// 
        /// @warning do not mix this function with av_buffersink_read(). Use only
        /// one or
        /// the other with a single sink, not both.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avfilter-if-3.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_buffersink_read_samples")]
        internal static extern int av_buffersink_read_samples(AVFilterContext* ctx, AVFilterBufferRef* buf, int nb_samples);
    }
}
