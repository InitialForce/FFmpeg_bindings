//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace libavformat
{
    /// <summary>
    /// @}
    /// </summary>
    public enum AVStreamParseType
    {
        AVSTREAM_PARSE_NONE = 0,
        /// <summary>full parsing and repack</summary>
        AVSTREAM_PARSE_FULL = 1,
        /// <summary>Only parse headers, do not repack.</summary>
        AVSTREAM_PARSE_HEADERS = 2,
        /// <summary>full parsing and interpolation of timestamps for frames not starting on a packet boundary</summary>
        AVSTREAM_PARSE_TIMESTAMPS = 3,
        /// <summary>full parsing and repack of the first frame only, only implemented for H.264 currently</summary>
        AVSTREAM_PARSE_FULL_ONCE = 4,
        /// <summary>full parsing and repack with timestamp and position generation by parser for raw this assumes that each packet in the file contains no demuxer level headers and just codec level data, otherwise position generaion would fail</summary>
        AVSTREAM_PARSE_FULL_RAW = 1463898624
    }

    /// <summary>
    /// The duration of a video can be estimated through various ways, and this
    /// enum can be used
    /// to know how the duration was estimated.
    /// </summary>
    public enum AVDurationEstimationMethod
    {
        /// <summary>Duration accurately estimated from PTSes</summary>
        AVFMT_DURATION_FROM_PTS = 0,
        /// <summary>Duration estimated from a stream with a known duration</summary>
        AVFMT_DURATION_FROM_STREAM = 1,
        /// <summary>Duration estimated from bitrate (less accurate)</summary>
        AVFMT_DURATION_FROM_BITRATE = 2
    }

    /// <summary>
    /// The exact value of the fractional number is: 'val + num / den'.
    /// num is assumed to be 0 <= num < den.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVFrac
    {
        [FieldOffset(0)]
        public long val;

        [FieldOffset(8)]
        public long num;

        [FieldOffset(16)]
        public long den;
    }

    /// <summary>
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVCodecTag
    {
    }

    /// <summary>
    /// This structure contains the data a format has to probe a file.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVProbeData
    {
        [FieldOffset(0)]
        public global::System.IntPtr filename;

        /// <summary>
        /// </summary>
        [FieldOffset(4)]
        public byte* buf;

        /// <summary>
        /// </summary>
        [FieldOffset(8)]
        public int buf_size;
    }

    /// <summary>
    /// @addtogroup lavf_encoding
    /// @{
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVOutputFormat
    {
        [FieldOffset(0)]
        public global::System.IntPtr name;

        /// <summary>
        /// Descriptive name for the format, meant to be more human-readable
        /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
        /// to define it.
        /// </summary>
        [FieldOffset(4)]
        public global::System.IntPtr long_name;

        [FieldOffset(8)]
        public global::System.IntPtr mime_type;

        /// <summary>
        /// </summary>
        [FieldOffset(12)]
        public global::System.IntPtr extensions;

        /// <summary>
        /// </summary>
        [FieldOffset(16)]
        public AVCodecID audio_codec;

        /// <summary>
        /// </summary>
        [FieldOffset(20)]
        public AVCodecID video_codec;

        /// <summary>
        /// </summary>
        [FieldOffset(24)]
        public AVCodecID subtitle_codec;

        /// <summary>
        /// can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_RAWPICTURE,
        /// AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,
        /// AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,
        /// AVFMT_TS_NONSTRICT
        /// </summary>
        [FieldOffset(28)]
        public int flags;

        /// <summary>
        /// List of supported codec_id-codec_tag pairs, ordered by "better
        /// choice first". The arrays are all terminated by AV_CODEC_ID_NONE.
        /// </summary>
        [FieldOffset(32)]
        public AVCodecTag* codec_tag;

        /// <summary>
        /// < AVClass for the private context
        /// </summary>
        [FieldOffset(36)]
        public AVClass* priv_class;

        /// <summary>
        /// No fields below this line are part of the public API. They
        /// may not be used outside of libavformat and can be changed and
        /// removed at will.
        /// New public fields should be added right above.
        /// 
        /// </summary>
        [FieldOffset(40)]
        public AVOutputFormat* next;

        /// <summary>
        /// size of private data so that it can be allocated in the wrapper
        /// </summary>
        [FieldOffset(44)]
        public int priv_data_size;

        [FieldOffset(48)]
        public global::System.IntPtr write_header;

        /// <summary>
        /// Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,
        /// pkt can be NULL in order to flush data buffered in the muxer.
        /// When flushing, return 0 if there still is more data to flush,
        /// or 1 if everything was flushed and there is no more buffered
        /// data.
        /// </summary>
        [FieldOffset(52)]
        public global::System.IntPtr write_packet;

        [FieldOffset(56)]
        public global::System.IntPtr write_trailer;

        /// <summary>
        /// Currently only used to set pixel format if not YUV420P.
        /// </summary>
        [FieldOffset(60)]
        public global::System.IntPtr interleave_packet;

        /// <summary>
        /// Test if the given codec can be stored in this container.
        /// 
        /// @return 1 if the codec is supported, 0 if it is not.
        /// A negative number if unknown.
        /// MKTAG('A', 'P', 'I', 'C') if the codec is only supported as
        /// AV_DISPOSITION_ATTACHED_PIC
        /// </summary>
        [FieldOffset(64)]
        public global::System.IntPtr query_codec;

        [FieldOffset(68)]
        public global::System.IntPtr get_output_timestamp;
    }

    /// <summary>
    /// @addtogroup lavf_decoding
    /// @{
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVInputFormat
    {
        /// <summary>
        /// A comma separated list of short names for the format. New names
        /// may be appended with a minor bump.
        /// </summary>
        [FieldOffset(0)]
        public global::System.IntPtr name;

        /// <summary>
        /// Descriptive name for the format, meant to be more human-readable
        /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
        /// to define it.
        /// </summary>
        [FieldOffset(4)]
        public global::System.IntPtr long_name;

        /// <summary>
        /// Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,
        /// AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,
        /// AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.
        /// </summary>
        [FieldOffset(8)]
        public int flags;

        /// <summary>
        /// If extensions are defined, then no probe is done. You should
        /// usually not use extension format guessing because it is not
        /// reliable enough
        /// </summary>
        [FieldOffset(12)]
        public global::System.IntPtr extensions;

        [FieldOffset(16)]
        public AVCodecTag* codec_tag;

        /// <summary>
        /// < AVClass for the private context
        /// </summary>
        [FieldOffset(20)]
        public AVClass* priv_class;

        /// <summary>
        /// No fields below this line are part of the public API. They
        /// may not be used outside of libavformat and can be changed and
        /// removed at will.
        /// New public fields should be added right above.
        /// 
        /// </summary>
        [FieldOffset(24)]
        public AVInputFormat* next;

        /// <summary>
        /// Raw demuxers store their codec ID here.
        /// </summary>
        [FieldOffset(28)]
        public int raw_codec_id;

        /// <summary>
        /// Size of private data so that it can be allocated in the wrapper.
        /// </summary>
        [FieldOffset(32)]
        public int priv_data_size;

        /// <summary>
        /// Tell if a given file has a chance of being parsed as this format.
        /// The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes
        /// big so you do not have to check for that unless you need more.
        /// </summary>
        [FieldOffset(36)]
        public global::System.IntPtr read_probe;

        /// <summary>
        /// Read the format header and initialize the AVFormatContext
        /// structure. Return 0 if OK. Only used in raw format right
        /// now. 'avformat_new_stream' should be called to create new streams.
        /// </summary>
        [FieldOffset(40)]
        public global::System.IntPtr read_header;

        /// <summary>
        /// Read one packet and put it in 'pkt'. pts and flags are also
        /// set. 'avformat_new_stream' can be called only if the flag
        /// AVFMTCTX_NOHEADER is used and only in the calling thread (not in a
        /// background thread).
        /// @return 0 on success, < 0 on error.
        /// When returning an error, pkt must not have been allocated
        /// or must be freed before returning
        /// </summary>
        [FieldOffset(44)]
        public global::System.IntPtr read_packet;

        /// <summary>
        /// Close the stream. The AVFormatContext and AVStreams are not
        /// freed by this function
        /// </summary>
        [FieldOffset(48)]
        public global::System.IntPtr read_close;

        /// <summary>
        /// Seek to a given timestamp relative to the frames in
        /// stream component stream_index.
        /// @param stream_index Must not be -1.
        /// @param flags Selects which direction should be preferred if no
        /// exact
        /// match is available.
        /// @return >= 0 on success (but not necessarily the new offset)
        /// </summary>
        [FieldOffset(52)]
        public global::System.IntPtr read_seek;

        /// <summary>
        /// Get the next timestamp in stream[stream_index].time_base units.
        /// @return the timestamp or AV_NOPTS_VALUE if an error occurred
        /// </summary>
        [FieldOffset(56)]
        public global::System.IntPtr read_timestamp;

        /// <summary>
        /// Start/resume playing - only meaningful if using a network-based
        /// format
        /// (RTSP).
        /// </summary>
        [FieldOffset(60)]
        public global::System.IntPtr read_play;

        /// <summary>
        /// Pause playing - only meaningful if using a network-based format
        /// (RTSP).
        /// </summary>
        [FieldOffset(64)]
        public global::System.IntPtr read_pause;

        /// <summary>
        /// Seek to timestamp ts.
        /// Seeking will be done so that the point from which all active
        /// streams
        /// can be presented successfully will be closest to ts and within
        /// min/max_ts.
        /// Active streams are all streams that have AVStream.discard <
        /// AVDISCARD_ALL.
        /// </summary>
        [FieldOffset(68)]
        public global::System.IntPtr read_seek2;
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVIndexEntry
    {
        [FieldOffset(0)]
        public long pos;

        /// <summary>
        /// Timestamp in AVStream.time_base units, preferably the time from
        /// which on correctly decoded frames are available
        /// when seeking to this entry. That means preferable PTS on keyframe
        /// based formats.
        /// But demuxers can choose to store a different timestamp, if it is
        /// more convenient for the implementation or nothing better
        /// is known
        /// </summary>
        [FieldOffset(8)]
        public long timestamp;

        [FieldOffset(16)]
        public int flags;

        [FieldOffset(16)]
        public int size;

        /// <summary>
        /// </summary>
        [FieldOffset(20)]
        public int min_distance;
    }

    /// <summary>
    /// Stream structure.
    /// New fields can be added to the end with minor version bumps.
    /// Removal, reordering and changes to existing fields require a major
    /// version bump.
    /// sizeof(AVStream) must not be used outside libav*.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVStream
    {
        /// <summary>
        /// </summary>
        [FieldOffset(0)]
        public int index;

        /// <summary>
        /// Format-specific stream ID.
        /// decoding: set by libavformat
        /// encoding: set by the user
        /// </summary>
        [FieldOffset(4)]
        public int id;

        /// <summary>
        /// Codec context associated with this stream. Allocated and freed by
        /// libavformat.
        /// 
        /// - decoding: The demuxer exports codec information stored in the
        /// headers
        /// here.
        /// - encoding: The user sets codec information, the muxer writes it to
        /// the
        /// output. Mandatory fields as specified in AVCodecContext
        /// documentation must be set even if this AVCodecContext is
        /// not actually used for encoding.
        /// </summary>
        [FieldOffset(8)]
        public AVCodecContext* codec;

        /// <summary>
        /// Real base framerate of the stream.
        /// This is the lowest framerate with which all timestamps can be
        /// represented accurately (it is the least common multiple of all
        /// framerates in the stream). Note, this value is just a guess!
        /// For example, if the time base is 1/90000 and all frames have either
        /// approximately 3600 or 1800 timer ticks, then r_frame_rate will be
        /// 50/1.
        /// </summary>
        [FieldOffset(12)]
        public AVRational* r_frame_rate;

        [FieldOffset(20)]
        public global::System.IntPtr priv_data;

        /// <summary>
        /// encoding: pts generation when outputting stream
        /// </summary>
        [FieldOffset(24)]
        public AVFrac* pts;

        /// <summary>
        /// This is the fundamental unit of time (in seconds) in terms
        /// of which frame timestamps are represented.
        /// 
        /// decoding: set by libavformat
        /// encoding: set by libavformat in av_write_header. The muxer may use
        /// the
        /// user-provided value of @ref AVCodecContext.time_base
        /// "codec->time_base"
        /// as a hint.
        /// </summary>
        [FieldOffset(48)]
        public AVRational* time_base;

        /// <summary>
        /// Decoding: pts of the first frame of the stream in presentation
        /// order, in stream time base.
        /// Only set this if you are absolutely 100% sure that the value you
        /// set
        /// it to really is the pts of the first frame.
        /// This may be undefined (AV_NOPTS_VALUE).
        /// @note The ASF header does NOT contain a correct start_time the ASF
        /// demuxer must NOT set this.
        /// </summary>
        [FieldOffset(56)]
        public long start_time;

        /// <summary>
        /// Decoding: duration of the stream, in stream time base.
        /// If a source file does not specify a duration, but does specify
        /// a bitrate, this value will be estimated from bitrate and file size.
        /// </summary>
        [FieldOffset(64)]
        public long duration;

        /// <summary>
        /// < number of frames in this stream if known or 0
        /// </summary>
        [FieldOffset(72)]
        public long nb_frames;

        /// <summary>
        /// </summary>
        [FieldOffset(80)]
        public int disposition;

        /// <summary>
        /// < Selects which packets can be discarded at will and do not need to
        /// be demuxed.
        /// </summary>
        [FieldOffset(84)]
        public AVDiscard discard;

        /// <summary>
        /// sample aspect ratio (0 if unknown)
        /// - encoding: Set by user.
        /// - decoding: Set by libavformat.
        /// </summary>
        [FieldOffset(88)]
        public AVRational* sample_aspect_ratio;

        [FieldOffset(96)]
        public AVDictionary* metadata;

        /// <summary>
        /// Average framerate
        /// </summary>
        [FieldOffset(100)]
        public AVRational* avg_frame_rate;

        /// <summary>
        /// For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this
        /// packet
        /// will contain the attached picture.
        /// 
        /// decoding: set by libavformat, must not be modified by the caller.
        /// encoding: unused
        /// </summary>
        [FieldOffset(112)]
        public AVPacket* attached_pic;

        [FieldOffset(184)]
        public AVStream.* info;

        /// <summary>
        /// </summary>
        [FieldOffset(188)]
        public int pts_wrap_bits;

        /// <summary>
        /// Timestamp corresponding to the last dts sync point.
        /// 
        /// Initialized when AVCodecParserContext.dts_sync_point >= 0 and
        /// a DTS is received from the underlying container. Otherwise set to
        /// AV_NOPTS_VALUE by default.
        /// </summary>
        [FieldOffset(192)]
        public long reference_dts;

        [FieldOffset(200)]
        public long first_dts;

        [FieldOffset(208)]
        public long cur_dts;

        [FieldOffset(216)]
        public long last_IP_pts;

        [FieldOffset(224)]
        public int last_IP_duration;

        [FieldOffset(228)]
        public int probe_packets;

        /// <summary>
        /// Number of frames that have been demuxed during
        /// av_find_stream_info()
        /// </summary>
        [FieldOffset(232)]
        public int codec_info_nb_frames;

        /// <summary>
        /// Stream Identifier
        /// This is the MPEG-TS stream identifier +1
        /// 0 means unknown
        /// </summary>
        [FieldOffset(236)]
        public int stream_identifier;

        [FieldOffset(240)]
        public long interleaver_chunk_size;

        [FieldOffset(248)]
        public long interleaver_chunk_duration;

        [FieldOffset(256)]
        public AVStreamParseType need_parsing;

        [FieldOffset(260)]
        public AVCodecParserContext* parser;

        /// <summary>
        /// last packet in packet_buffer for this stream when muxing.
        /// </summary>
        [FieldOffset(264)]
        public AVPacketList* last_in_packet_buffer;

        [FieldOffset(268)]
        public AVProbeData* probe_data;

        [FieldOffset(280)]
        public fixed long pts_buffer[17];

        /// <summary>
        /// support seeking natively. */
        /// </summary>
        [FieldOffset(416)]
        public AVIndexEntry* index_entries;

        [FieldOffset(420)]
        public int nb_index_entries;

        [FieldOffset(424)]
        public uint index_entries_allocated_size;

        /// <summary>
        /// stream probing state
        /// -1   -> probing finished
        /// 0   -> no probing requested
        /// rest -> perform probing with request_probe being the minimum score
        /// to accept.
        /// NOT PART OF PUBLIC API
        /// </summary>
        [FieldOffset(428)]
        public int request_probe;

        /// <summary>
        /// Indicates that everything up to the next keyframe
        /// should be discarded.
        /// </summary>
        [FieldOffset(432)]
        public int skip_to_keyframe;

        /// <summary>
        /// Number of samples to skip at the start of the frame decoded from
        /// the next packet.
        /// </summary>
        [FieldOffset(436)]
        public int skip_samples;

        /// <summary>
        /// Number of internally decoded frames, used internally in
        /// libavformat, do not access
        /// its lifetime differs from info which is why its not in that
        /// structure.
        /// </summary>
        [FieldOffset(440)]
        public int nb_decoded_frames;

        /// <summary>
        /// Timestamp offset added to timestamps before muxing
        /// NOT PART OF PUBLIC API
        /// </summary>
        [FieldOffset(448)]
        public long mux_ts_offset;
    }

    /// <summary>
    /// New fields can be added to the end with minor version bumps.
    /// Removal, reordering and changes to existing fields require a major
    /// version bump.
    /// sizeof(AVProgram) must not be used outside libav*.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVProgram
    {
        [FieldOffset(0)]
        public int id;

        [FieldOffset(4)]
        public int flags;

        /// <summary>
        /// < selects which program to discard and which to feed to the caller
        /// </summary>
        [FieldOffset(8)]
        public AVDiscard discard;

        [FieldOffset(12)]
        public uint* stream_index;

        [FieldOffset(16)]
        public uint nb_stream_indexes;

        [FieldOffset(20)]
        public AVDictionary* metadata;

        [FieldOffset(24)]
        public int program_num;

        [FieldOffset(28)]
        public int pmt_pid;

        [FieldOffset(32)]
        public int pcr_pid;
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVChapter
    {
        /// <summary>
        /// < unique ID to identify the chapter
        /// </summary>
        [FieldOffset(0)]
        public int id;

        /// <summary>
        /// < time base in which the start/end timestamps are specified
        /// </summary>
        [FieldOffset(4)]
        public AVRational* time_base;

        /// <summary>
        /// < chapter start/end time in time_base units
        /// </summary>
        [FieldOffset(16)]
        public long start;

        /// <summary>
        /// < chapter start/end time in time_base units
        /// </summary>
        [FieldOffset(24)]
        public long end;

        [FieldOffset(32)]
        public AVDictionary* metadata;
    }

    /// <summary>
    /// Format I/O context.
    /// New fields can be added to the end with minor version bumps.
    /// Removal, reordering and changes to existing fields require a major
    /// version bump.
    /// sizeof(AVFormatContext) must not be used outside libav*, use
    /// avformat_alloc_context() to create an AVFormatContext.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVFormatContext
    {
        /// <summary>
        /// A class for logging and AVOptions. Set by avformat_alloc_context().
        /// Exports (de)muxer private options if they exist.
        /// </summary>
        [FieldOffset(0)]
        public AVClass* av_class;

        /// <summary>
        /// Can only be iformat or oformat, not both at the same time.
        /// 
        /// decoding: set by avformat_open_input().
        /// encoding: set by the user.
        /// </summary>
        [FieldOffset(4)]
        public AVInputFormat* iformat;

        [FieldOffset(8)]
        public AVOutputFormat* oformat;

        /// <summary>
        /// Format private data. This is an AVOptions-enabled struct
        /// if and only if iformat/oformat.priv_class is not NULL.
        /// </summary>
        [FieldOffset(12)]
        public global::System.IntPtr priv_data;

        /// <summary>
        /// I/O context.
        /// 
        /// decoding: either set by the user before avformat_open_input() (then
        /// the user must close it manually) or set by avformat_open_input().
        /// encoding: set by the user.
        /// 
        /// Do NOT set this field if AVFMT_NOFILE flag is set in
        /// iformat/oformat.flags. In such a case, the (de)muxer will handle
        /// I/O in some other way and this field will be NULL.
        /// </summary>
        [FieldOffset(16)]
        public AVIOContext* pb;

        /// <summary>
        /// </summary>
        [FieldOffset(20)]
        public int ctx_flags;

        /// <summary>
        /// A list of all streams in the file. New streams are created with
        /// avformat_new_stream().
        /// 
        /// decoding: streams are created by libavformat in
        /// avformat_open_input().
        /// If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also
        /// appear in av_read_frame().
        /// encoding: streams are created by the user before
        /// avformat_write_header().
        /// </summary>
        [FieldOffset(24)]
        public uint nb_streams;

        [FieldOffset(28)]
        public AVStream* streams;

        /// <summary>
        /// </summary>
        [FieldOffset(32)]
        public fixed sbyte filename[1024];

        /// <summary>
        /// Decoding: position of the first frame of the component, in
        /// AV_TIME_BASE fractional seconds. NEVER set this value directly:
        /// It is deduced from the AVStream values.
        /// </summary>
        [FieldOffset(1056)]
        public long start_time;

        /// <summary>
        /// Decoding: duration of the stream, in AV_TIME_BASE fractional
        /// seconds. Only set this value if you know none of the individual
        /// stream
        /// durations and also do not set any of them. This is deduced from the
        /// AVStream values if not set.
        /// </summary>
        [FieldOffset(1064)]
        public long duration;

        /// <summary>
        /// Decoding: total stream bitrate in bit/s, 0 if not
        /// available. Never set it directly if the file_size and the
        /// duration are known as FFmpeg can compute it automatically.
        /// </summary>
        [FieldOffset(1072)]
        public int bit_rate;

        [FieldOffset(1076)]
        public uint packet_size;

        [FieldOffset(1080)]
        public int max_delay;

        [FieldOffset(1084)]
        public int flags;

        /// <summary>
        /// decoding: size of data to probe; encoding: unused.
        /// </summary>
        [FieldOffset(1088)]
        public uint probesize;

        /// <summary>
        /// decoding: maximum time (in AV_TIME_BASE units) during which the
        /// input should
        /// be analyzed in avformat_find_stream_info().
        /// </summary>
        [FieldOffset(1092)]
        public int max_analyze_duration;

        [FieldOffset(1096)]
        public byte* key;

        [FieldOffset(1100)]
        public int keylen;

        [FieldOffset(1104)]
        public uint nb_programs;

        [FieldOffset(1108)]
        public AVProgram* programs;

        /// <summary>
        /// Forced video codec_id.
        /// Demuxing: Set by user.
        /// </summary>
        [FieldOffset(1112)]
        public AVCodecID video_codec_id;

        /// <summary>
        /// Forced audio codec_id.
        /// Demuxing: Set by user.
        /// </summary>
        [FieldOffset(1116)]
        public AVCodecID audio_codec_id;

        /// <summary>
        /// Forced subtitle codec_id.
        /// Demuxing: Set by user.
        /// </summary>
        [FieldOffset(1120)]
        public AVCodecID subtitle_codec_id;

        /// <summary>
        /// Maximum amount of memory in bytes to use for the index of each
        /// stream.
        /// If the index exceeds this size, entries will be discarded as
        /// needed to maintain a smaller size. This can lead to slower or less
        /// accurate seeking (depends on demuxer).
        /// Demuxers for which a full in-memory index is mandatory will ignore
        /// this.
        /// muxing  : unused
        /// demuxing: set by user
        /// </summary>
        [FieldOffset(1124)]
        public uint max_index_size;

        /// <summary>
        /// Maximum amount of memory in bytes to use for buffering frames
        /// obtained from realtime capture devices.
        /// </summary>
        [FieldOffset(1128)]
        public uint max_picture_buffer;

        [FieldOffset(1132)]
        public uint nb_chapters;

        [FieldOffset(1136)]
        public AVChapter* chapters;

        [FieldOffset(1140)]
        public AVDictionary* metadata;

        /// <summary>
        /// Start time of the stream in real world time, in microseconds
        /// since the unix epoch (00:00 1st January 1970). That is, pts=0
        /// in the stream was captured at this real world time.
        /// - encoding: Set by user.
        /// - decoding: Unused.
        /// </summary>
        [FieldOffset(1144)]
        public long start_time_realtime;

        /// <summary>
        /// decoding: number of frames used to probe fps
        /// </summary>
        [FieldOffset(1152)]
        public int fps_probe_size;

        /// <summary>
        /// Error recognition; higher values will detect more errors but may
        /// misdetect some more or less valid parts as errors.
        /// - encoding: unused
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(1156)]
        public int error_recognition;

        /// <summary>
        /// Custom interrupt callbacks for the I/O layer.
        /// 
        /// decoding: set by the user before avformat_open_input().
        /// encoding: set by the user before avformat_write_header()
        /// (mainly useful for AVFMT_NOFILE formats). The callback
        /// should also be passed to avio_open2() if it's used to
        /// open the file.
        /// </summary>
        [FieldOffset(1160)]
        public AVIOInterruptCB* interrupt_callback;

        /// <summary>
        /// Flags to enable debugging.
        /// </summary>
        [FieldOffset(1168)]
        public int debug;

        /// <summary>
        /// Transport stream id.
        /// This will be moved into demuxer private options. Thus no API/ABI
        /// compatibility
        /// </summary>
        [FieldOffset(1172)]
        public int ts_id;

        /// <summary>
        /// Audio preload in microseconds.
        /// Note, not all formats support this and unpredictable things may
        /// happen if it is used when not supported.
        /// - encoding: Set by user via AVOptions (NO direct access)
        /// - decoding: unused
        /// </summary>
        [FieldOffset(1176)]
        public int audio_preload;

        /// <summary>
        /// Max chunk time in microseconds.
        /// Note, not all formats support this and unpredictable things may
        /// happen if it is used when not supported.
        /// - encoding: Set by user via AVOptions (NO direct access)
        /// - decoding: unused
        /// </summary>
        [FieldOffset(1180)]
        public int max_chunk_duration;

        /// <summary>
        /// Max chunk size in bytes
        /// Note, not all formats support this and unpredictable things may
        /// happen if it is used when not supported.
        /// - encoding: Set by user via AVOptions (NO direct access)
        /// - decoding: unused
        /// </summary>
        [FieldOffset(1184)]
        public int max_chunk_size;

        /// <summary>
        /// forces the use of wallclock timestamps as pts/dts of packets
        /// This has undefined results in the presence of B frames.
        /// - encoding: unused
        /// - decoding: Set by user via AVOptions (NO direct access)
        /// </summary>
        [FieldOffset(1188)]
        public int use_wallclock_as_timestamps;

        /// <summary>
        /// Avoids negative timestamps during muxing
        /// 0 -> allow negative timestamps
        /// 1 -> avoid negative timestamps
        /// -1 -> choose automatically (default)
        /// Note, this is only works when interleave_packet_per_dts is in use
        /// - encoding: Set by user via AVOptions (NO direct access)
        /// - decoding: unused
        /// </summary>
        [FieldOffset(1192)]
        public int avoid_negative_ts;

        /// <summary>
        /// avio flags, used to force AVIO_FLAG_DIRECT.
        /// - encoding: unused
        /// - decoding: Set by user via AVOptions (NO direct access)
        /// </summary>
        [FieldOffset(1196)]
        public int avio_flags;

        /// <summary>
        /// The duration field can be estimated through various ways, and this
        /// field can be used
        /// to know how the duration was estimated.
        /// - encoding: unused
        /// - decoding: Read by user via AVOptions (NO direct access)
        /// </summary>
        [FieldOffset(1200)]
        public AVDurationEstimationMethod duration_estimation_method;

        /// <summary>
        /// This buffer is only needed when packets were already buffered but
        /// not decoded, for example to get the codec parameters in MPEG
        /// streams.
        /// </summary>
        [FieldOffset(1204)]
        public AVPacketList* packet_buffer;

        [FieldOffset(1208)]
        public AVPacketList* packet_buffer_end;

        /// <summary>
        /// </summary>
        [FieldOffset(1216)]
        public long data_offset;

        /// <summary>
        /// Raw packets from the demuxer, prior to parsing and decoding.
        /// This buffer is used for buffering packets until the codec can
        /// be identified, as parsing cannot be done without knowing the
        /// codec.
        /// </summary>
        [FieldOffset(1224)]
        public AVPacketList* raw_packet_buffer;

        [FieldOffset(1228)]
        public AVPacketList* raw_packet_buffer_end;

        /// <summary>
        /// Packets split by the parser get queued here.
        /// </summary>
        [FieldOffset(1232)]
        public AVPacketList* parse_queue;

        [FieldOffset(1236)]
        public AVPacketList* parse_queue_end;

        [FieldOffset(1240)]
        public int raw_packet_buffer_remaining_size;
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVPacketList
    {
        [FieldOffset(0)]
        public AVPacket* pkt;

        [FieldOffset(72)]
        public AVPacketList* next;
    }

    public unsafe partial class libavformat
    {
        /// <summary>
        /// Allocate and read the payload of a packet and initialize its
        /// fields with default values.
        /// 
        /// @param pkt packet
        /// @param size desired payload size
        /// @return >0 (read size) if OK, AVERROR_xxx otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_get_packet")]
        internal static extern int av_get_packet(AVIOContext* s, AVPacket* pkt, int size);

        /// <summary>
        /// Read data and append it to the current content of the AVPacket.
        /// If pkt->size is 0 this is identical to av_get_packet.
        /// Note that this uses av_grow_packet and thus involves a realloc
        /// which is inefficient. Thus this function should only be used
        /// when there is no reasonable way to know (an upper bound of)
        /// the final size.
        /// 
        /// @param pkt packet
        /// @param size amount of data to read
        /// @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data
        /// will not be lost even if an error occurs.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_append_packet")]
        internal static extern int av_append_packet(AVIOContext* s, AVPacket* pkt, int size);

        /// <summary>
        /// Returns the method used to set ctx->duration.
        /// 
        /// @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or
        /// AVFMT_DURATION_FROM_BITRATE.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_fmt_ctx_get_duration_estimation_method")]
        internal static extern AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method(AVFormatContext* ctx);

        /// <summary>
        /// Return the LIBAVFORMAT_VERSION_INT constant.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_version")]
        internal static extern uint avformat_version();

        /// <summary>
        /// Return the libavformat build-time configuration.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_configuration")]
        internal static extern global::System.IntPtr avformat_configuration();

        /// <summary>
        /// Return the libavformat license.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_license")]
        internal static extern global::System.IntPtr avformat_license();

        /// <summary>
        /// Initialize libavformat and register all the muxers, demuxers and
        /// protocols. If you do not call this function, then you can select
        /// exactly which formats you want to support.
        /// 
        /// @see av_register_input_format()
        /// @see av_register_output_format()
        /// @see av_register_protocol()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_register_all")]
        internal static extern void av_register_all();

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_register_input_format")]
        internal static extern void av_register_input_format(AVInputFormat* format);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_register_output_format")]
        internal static extern void av_register_output_format(AVOutputFormat* format);

        /// <summary>
        /// Do global initialization of network components. This is optional,
        /// but recommended, since it avoids the overhead of implicitly
        /// doing the setup for each session.
        /// 
        /// Calling this function will become mandatory if using network
        /// protocols at some major version bump.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_network_init")]
        internal static extern int avformat_network_init();

        /// <summary>
        /// Undo the initialization done by avformat_network_init.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_network_deinit")]
        internal static extern int avformat_network_deinit();

        /// <summary>
        /// If f is NULL, returns the first registered input format,
        /// if f is non-NULL, returns the next registered input format after f
        /// or NULL if f is the last one.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_iformat_next")]
        internal static extern AVInputFormat* av_iformat_next(AVInputFormat* f);

        /// <summary>
        /// If f is NULL, returns the first registered output format,
        /// if f is non-NULL, returns the next registered output format after f
        /// or NULL if f is the last one.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_oformat_next")]
        internal static extern AVOutputFormat* av_oformat_next(AVOutputFormat* f);

        /// <summary>
        /// Allocate an AVFormatContext.
        /// avformat_free_context() can be used to free the context and everything
        /// allocated by the framework within it.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_alloc_context")]
        internal static extern AVFormatContext* avformat_alloc_context();

        /// <summary>
        /// Free an AVFormatContext and all its streams.
        /// @param s context to free
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_free_context")]
        internal static extern void avformat_free_context(AVFormatContext* s);

        /// <summary>
        /// Get the AVClass for AVFormatContext. It can be used in combination with
        /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
        /// 
        /// @see av_opt_find().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_get_class")]
        internal static extern AVClass* avformat_get_class();

        /// <summary>
        /// Add a new stream to a media file.
        /// 
        /// When demuxing, it is called by the demuxer in read_header(). If the
        /// flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also
        /// be called in read_packet().
        /// 
        /// When muxing, should be called by the user before
        /// avformat_write_header().
        /// 
        /// @param c If non-NULL, the AVCodecContext corresponding to the new
        /// stream
        /// will be initialized to use this codec. This is needed for e.g.
        /// codec-specific
        /// defaults to be set, so codec should be provided if it is known.
        /// 
        /// @return newly created stream or NULL on error.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_new_stream")]
        internal static extern AVStream* avformat_new_stream(AVFormatContext* s, AVCodec* c);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_new_program")]
        internal static extern AVProgram* av_new_program(AVFormatContext* s, int id);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_alloc_output_context")]
        internal static extern AVFormatContext* avformat_alloc_output_context(global::System.IntPtr format, AVOutputFormat* oformat, global::System.IntPtr filename);

        /// <summary>
        /// Allocate an AVFormatContext for an output format.
        /// avformat_free_context() can be used to free the context and
        /// everything allocated by the framework within it.
        /// 
        /// @param *ctx is set to the created format context, or to NULL in
        /// case of failure
        /// @param oformat format to use for allocating the context, if NULL
        /// format_name and filename are used instead
        /// @param format_name the name of output format to use for allocating the
        /// context, if NULL filename is used instead
        /// @param filename the name of the filename to use for allocating the
        /// context, may be NULL
        /// @return >= 0 in case of success, a negative AVERROR code in case of
        /// failure
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_alloc_output_context2")]
        internal static extern int avformat_alloc_output_context2(AVFormatContext* ctx, AVOutputFormat* oformat, global::System.IntPtr format_name, global::System.IntPtr filename);

        /// <summary>
        /// Find AVInputFormat based on the short name of the input format.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_find_input_format")]
        internal static extern AVInputFormat* av_find_input_format(global::System.IntPtr short_name);

        /// <summary>
        /// Guess the file format.
        /// 
        /// @param is_opened Whether the file is already opened; determines whether
        /// demuxers with or without AVFMT_NOFILE are probed.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_probe_input_format")]
        internal static extern AVInputFormat* av_probe_input_format(AVProbeData* pd, int is_opened);

        /// <summary>
        /// Guess the file format.
        /// 
        /// @param is_opened Whether the file is already opened; determines whether
        /// demuxers with or without AVFMT_NOFILE are probed.
        /// @param score_max A probe score larger that this is required to accept a
        /// detection, the variable is set to the actual detection
        /// score afterwards.
        /// If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended
        /// to retry with a larger probe buffer.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_probe_input_format2")]
        internal static extern AVInputFormat* av_probe_input_format2(AVProbeData* pd, int is_opened, int* score_max);

        /// <summary>
        /// Guess the file format.
        /// 
        /// @param is_opened Whether the file is already opened; determines whether
        /// demuxers with or without AVFMT_NOFILE are probed.
        /// @param score_ret The score of the best detection.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_probe_input_format3")]
        internal static extern AVInputFormat* av_probe_input_format3(AVProbeData* pd, int is_opened, int* score_ret);

        /// <summary>
        /// Probe a bytestream to determine the input format. Each time a probe
        /// returns
        /// with a score that is too low, the probe buffer size is increased and
        /// another
        /// attempt is made. When the maximum probe size is reached, the input
        /// format
        /// with the highest score is returned.
        /// 
        /// @param pb the bytestream to probe
        /// @param fmt the input format is put here
        /// @param filename the filename of the stream
        /// @param logctx the log context
        /// @param offset the offset within the bytestream to probe from
        /// @param max_probe_size the maximum probe buffer size (zero for default)
        /// @return 0 in case of success, a negative value corresponding to an
        /// AVERROR code otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_probe_input_buffer")]
        internal static extern int av_probe_input_buffer(AVIOContext* pb, AVInputFormat* fmt, global::System.IntPtr filename, global::System.IntPtr logctx, uint offset, uint max_probe_size);

        /// <summary>
        /// Open an input stream and read the header. The codecs are not opened.
        /// The stream must be closed with av_close_input_file().
        /// 
        /// @param ps Pointer to user-supplied AVFormatContext (allocated by
        /// avformat_alloc_context).
        /// May be a pointer to NULL, in which case an AVFormatContext is allocated
        /// by this
        /// function and written into ps.
        /// Note that a user-supplied AVFormatContext will be freed on failure.
        /// @param filename Name of the stream to open.
        /// @param fmt If non-NULL, this parameter forces a specific input format.
        /// Otherwise the format is autodetected.
        /// @param options  A dictionary filled with AVFormatContext and
        /// demuxer-private options.
        /// On return this parameter will be destroyed and replaced with a dict
        /// containing
        /// options that were not found. May be NULL.
        /// 
        /// @return 0 on success, a negative AVERROR on failure.
        /// 
        /// @note If you want to use custom IO, preallocate the format context and
        /// set its pb field.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_open_input")]
        internal static extern int avformat_open_input(AVFormatContext* ps, global::System.IntPtr filename, AVInputFormat* fmt, AVDictionary* options);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_demuxer_open")]
        internal static extern int av_demuxer_open(AVFormatContext* ic);

        /// <summary>
        /// Read packets of a media file to get stream information. This
        /// is useful for file formats with no headers such as MPEG. This
        /// function also computes the real framerate in case of MPEG-2 repeat
        /// frame mode.
        /// The logical file position is not changed by this function;
        /// examined packets may be buffered for later processing.
        /// 
        /// @param ic media file handle
        /// @return >=0 if OK, AVERROR_xxx on error
        /// @todo Let the user decide somehow what information is needed so that
        /// we do not waste time getting stuff the user does not need.
        /// 
        /// @deprecated use avformat_find_stream_info.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_find_stream_info")]
        internal static extern int av_find_stream_info(AVFormatContext* ic);

        /// <summary>
        /// Read packets of a media file to get stream information. This
        /// is useful for file formats with no headers such as MPEG. This
        /// function also computes the real framerate in case of MPEG-2 repeat
        /// frame mode.
        /// The logical file position is not changed by this function;
        /// examined packets may be buffered for later processing.
        /// 
        /// @param ic media file handle
        /// @param options  If non-NULL, an ic.nb_streams long array of pointers to
        /// dictionaries, where i-th member contains options for
        /// codec corresponding to i-th stream.
        /// On return each dictionary will be filled with options that were not
        /// found.
        /// @return >=0 if OK, AVERROR_xxx on error
        /// 
        /// @note this function isn't guaranteed to open all the codecs, so
        /// options being non-empty at return is a perfectly normal behavior.
        /// 
        /// @todo Let the user decide somehow what information is needed so that
        /// we do not waste time getting stuff the user does not need.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_find_stream_info")]
        internal static extern int avformat_find_stream_info(AVFormatContext* ic, AVDictionary* options);

        /// <summary>
        /// Find the programs which belong to a given stream.
        /// 
        /// @param ic    media file handle
        /// @param last  the last found program, the search will start after this
        /// program, or from the beginning if it is NULL
        /// @param s     stream index
        /// @return the next program which belongs to s, NULL if no program is
        /// found or
        /// the last program is not among the programs of ic.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_find_program_from_stream")]
        internal static extern AVProgram* av_find_program_from_stream(AVFormatContext* ic, AVProgram* last, int s);

        /// <summary>
        /// Find the "best" stream in the file.
        /// The best stream is determined according to various heuristics as the
        /// most
        /// likely to be what the user expects.
        /// If the decoder parameter is non-NULL, av_find_best_stream will find the
        /// default decoder for the stream's codec; streams for which no decoder
        /// can
        /// be found are ignored.
        /// 
        /// @param ic                media file handle
        /// @param type              stream type: video, audio, subtitles, etc.
        /// @param wanted_stream_nb  user-requested stream number,
        /// or -1 for automatic selection
        /// @param related_stream    try to find a stream related (eg. in the same
        /// program) to this one, or -1 if none
        /// @param decoder_ret       if non-NULL, returns the decoder for the
        /// selected stream
        /// @param flags             flags; none are currently defined
        /// @return  the non-negative stream number in case of success,
        /// AVERROR_STREAM_NOT_FOUND if no stream with the requested type
        /// could be found,
        /// AVERROR_DECODER_NOT_FOUND if streams were found but no decoder
        /// @note  If av_find_best_stream returns successfully and decoder_ret is
        /// not
        /// NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_find_best_stream")]
        internal static extern int av_find_best_stream(AVFormatContext* ic, AVMediaType type, int wanted_stream_nb, int related_stream, AVCodec* decoder_ret, int flags);

        /// <summary>
        /// @deprecated use AVFMT_FLAG_NOFILLIN | AVFMT_FLAG_NOPARSE to read raw
        /// unprocessed packets
        /// 
        /// Read a transport packet from a media file.
        /// 
        /// This function is obsolete and should never be used.
        /// Use av_read_frame() instead.
        /// 
        /// @param s media file handle
        /// @param pkt is filled
        /// @return 0 if OK, AVERROR_xxx on error
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_read_packet")]
        internal static extern int av_read_packet(AVFormatContext* s, AVPacket* pkt);

        /// <summary>
        /// Return the next frame of a stream.
        /// This function returns what is stored in the file, and does not validate
        /// that what is there are valid frames for the decoder. It will split what
        /// is
        /// stored in the file into frames and return one for each call. It will
        /// not
        /// omit invalid data between valid frames so as to give the decoder the
        /// maximum
        /// information possible for decoding.
        /// 
        /// The returned packet is valid
        /// until the next av_read_frame() or until av_close_input_file() and
        /// must be freed with av_free_packet. For video, the packet contains
        /// exactly one frame. For audio, it contains an integer number of
        /// frames if each frame has a known fixed size (e.g. PCM or ADPCM
        /// data). If the audio frames have a variable size (e.g. MPEG audio),
        /// then it contains one frame.
        /// 
        /// pkt->pts, pkt->dts and pkt->duration are always set to correct
        /// values in AVStream.time_base units (and guessed if the format cannot
        /// provide them). pkt->pts can be AV_NOPTS_VALUE if the video format
        /// has B-frames, so it is better to rely on pkt->dts if you do not
        /// decompress the payload.
        /// 
        /// @return 0 if OK, < 0 on error or end of file
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_read_frame")]
        internal static extern int av_read_frame(AVFormatContext* s, AVPacket* pkt);

        /// <summary>
        /// Seek to the keyframe at timestamp.
        /// 'timestamp' in 'stream_index'.
        /// @param stream_index If stream_index is (-1), a default
        /// stream is selected, and timestamp is automatically converted
        /// from AV_TIME_BASE units to the stream specific time_base.
        /// @param timestamp Timestamp in AVStream.time_base units
        /// or, if no stream is specified, in AV_TIME_BASE units.
        /// @param flags flags which select direction and seeking mode
        /// @return >= 0 on success
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_seek_frame")]
        internal static extern int av_seek_frame(AVFormatContext* s, int stream_index, long timestamp, int flags);

        /// <summary>
        /// Seek to timestamp ts.
        /// Seeking will be done so that the point from which all active streams
        /// can be presented successfully will be closest to ts and within
        /// min/max_ts.
        /// Active streams are all streams that have AVStream.discard <
        /// AVDISCARD_ALL.
        /// 
        /// If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and
        /// are the file position (this may not be supported by all demuxers).
        /// If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames
        /// in the stream with stream_index (this may not be supported by all
        /// demuxers).
        /// Otherwise all timestamps are in units of the stream selected by
        /// stream_index
        /// or if stream_index is -1, in AV_TIME_BASE units.
        /// If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as
        /// keyframes (this may not be supported by all demuxers).
        /// 
        /// @param stream_index index of the stream which is used as time base
        /// reference
        /// @param min_ts smallest acceptable timestamp
        /// @param ts target timestamp
        /// @param max_ts largest acceptable timestamp
        /// @param flags flags
        /// @return >=0 on success, error code otherwise
        /// 
        /// @note This is part of the new seek API which is still under
        /// construction.
        /// Thus do not use this yet. It may change at any time, do not expect
        /// ABI compatibility yet!
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_seek_file")]
        internal static extern int avformat_seek_file(AVFormatContext* s, int stream_index, long min_ts, long ts, long max_ts, int flags);

        /// <summary>
        /// Start playing a network-based stream (e.g. RTSP stream) at the
        /// current position.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_read_play")]
        internal static extern int av_read_play(AVFormatContext* s);

        /// <summary>
        /// Pause a network-based stream (e.g. RTSP stream).
        /// 
        /// Use av_read_play() to resume it.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_read_pause")]
        internal static extern int av_read_pause(AVFormatContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_close_input_file")]
        internal static extern void av_close_input_file(AVFormatContext* s);

        /// <summary>
        /// Close an opened input AVFormatContext. Free it and all its contents
        /// and set *s to NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_close_input")]
        internal static extern void avformat_close_input(AVFormatContext* s);

        /// <summary>
        /// Add a new stream to a media file.
        /// 
        /// Can only be called in the read_header() function. If the flag
        /// AVFMTCTX_NOHEADER is in the format context, then new streams
        /// can be added in read_packet too.
        /// 
        /// @param s media file handle
        /// @param id file-format-dependent stream ID
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_new_stream")]
        internal static extern AVStream* av_new_stream(AVFormatContext* s, int id);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_set_pts_info")]
        internal static extern void av_set_pts_info(AVStream* s, int pts_wrap_bits, uint pts_num, uint pts_den);

        /// <summary>
        /// @addtogroup lavf_encoding
        /// @{
        /// 
        /// 
        /// Allocate the stream private data and write the stream header to
        /// an output media file.
        /// 
        /// @param s Media file handle, must be allocated with
        /// avformat_alloc_context().
        /// Its oformat field must be set to the desired output format;
        /// Its pb field must be set to an already openened AVIOContext.
        /// @param options  An AVDictionary filled with AVFormatContext and
        /// muxer-private options.
        /// On return this parameter will be destroyed and replaced with a dict
        /// containing
        /// options that were not found. May be NULL.
        /// 
        /// @return 0 on success, negative AVERROR on failure.
        /// 
        /// @see av_opt_find, av_dict_set, avio_open, av_oformat_next.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_write_header")]
        internal static extern int avformat_write_header(AVFormatContext* s, AVDictionary* options);

        /// <summary>
        /// Write a packet to an output media file.
        /// 
        /// The packet shall contain one audio or video frame.
        /// The packet must be correctly interleaved according to the container
        /// specification, if not then av_interleaved_write_frame must be used.
        /// 
        /// @param s media file handle
        /// @param pkt The packet, which contains the stream_index, buf/buf_size,
        /// dts/pts, ...
        /// This can be NULL (at any time, not just at the end), in
        /// order to immediately flush data buffered within the muxer,
        /// for muxers that buffer up data internally before writing it
        /// to the output.
        /// @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data
        /// to flush
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_write_frame")]
        internal static extern int av_write_frame(AVFormatContext* s, AVPacket* pkt);

        /// <summary>
        /// Write a packet to an output media file ensuring correct interleaving.
        /// 
        /// The packet must contain one audio or video frame.
        /// If the packets are already correctly interleaved, the application
        /// should
        /// call av_write_frame() instead as it is slightly faster. It is also
        /// important
        /// to keep in mind that completely non-interleaved input will need huge
        /// amounts
        /// of memory to interleave with this, so it is preferable to interleave at
        /// the
        /// demuxer level.
        /// 
        /// @param s media file handle
        /// @param pkt The packet containing the data to be written. Libavformat
        /// takes
        /// ownership of the data and will free it when it sees fit using the
        /// packet's
        /// This can be NULL (at any time, not just at the end), to flush the
        /// interleaving queues.
        /// @ref AVPacket.destruct "destruct" field. The caller must not access the
        /// data
        /// after this function returns, as it may already be freed.
        /// Packet's @ref AVPacket.stream_index "stream_index" field must be set to
        /// the
        /// index of the corresponding stream in @ref AVFormatContext.streams
        /// "s.streams".
        /// It is very strongly recommended that timing information (@ref
        /// AVPacket.pts
        /// "pts", @ref AVPacket.dts "dts" @ref AVPacket.duration "duration") is
        /// set to
        /// correct values.
        /// 
        /// @return 0 on success, a negative AVERROR on error.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_interleaved_write_frame")]
        internal static extern int av_interleaved_write_frame(AVFormatContext* s, AVPacket* pkt);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_interleave_packet_per_dts")]
        internal static extern int av_interleave_packet_per_dts(AVFormatContext* s, AVPacket* @out, AVPacket* pkt, int flush);

        /// <summary>
        /// Write the stream trailer to an output media file and free the
        /// file private data.
        /// 
        /// May only be called after a successful call to av_write_header.
        /// 
        /// @param s media file handle
        /// @return 0 if OK, AVERROR_xxx on error
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_write_trailer")]
        internal static extern int av_write_trailer(AVFormatContext* s);

        /// <summary>
        /// Return the output format in the list of registered output formats
        /// which best matches the provided parameters, or return NULL if
        /// there is no match.
        /// 
        /// @param short_name if non-NULL checks if short_name matches with the
        /// names of the registered formats
        /// @param filename if non-NULL checks if filename terminates with the
        /// extensions of the registered formats
        /// @param mime_type if non-NULL checks if mime_type matches with the
        /// MIME type of the registered formats
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_guess_format")]
        internal static extern AVOutputFormat* av_guess_format(global::System.IntPtr short_name, global::System.IntPtr filename, global::System.IntPtr mime_type);

        /// <summary>
        /// Guess the codec ID based upon muxer and filename.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_guess_codec")]
        internal static extern AVCodecID av_guess_codec(AVOutputFormat* fmt, global::System.IntPtr short_name, global::System.IntPtr filename, global::System.IntPtr mime_type, AVMediaType type);

        /// <summary>
        /// Get timing information for the data currently output.
        /// The exact meaning of "currently output" depends on the format.
        /// It is mostly relevant for devices that have an internal buffer and/or
        /// work in real time.
        /// @param s          media file handle
        /// @param stream     stream in the media file
        /// @param dts[out]   DTS of the last packet output for the stream, in
        /// stream
        /// time_base units
        /// @param wall[out]  absolute time when that packet whas output,
        /// in microsecond
        /// @return  0 if OK, AVERROR(ENOSYS) if the format does not support it
        /// Note: some formats or devices may not allow to measure dts and wall
        /// atomically.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_get_output_timestamp")]
        internal static extern int av_get_output_timestamp(AVFormatContext* s, int stream, long* dts, long* wall);

        /// <summary>
        /// Send a nice hexadecimal dump of a buffer to the specified file stream.
        /// 
        /// @param f The file stream pointer where the dump should be sent to.
        /// @param buf buffer
        /// @param size buffer size
        /// 
        /// @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_hex_dump")]
        internal static extern void av_hex_dump(_iobuf* f, byte* buf, int size);

        /// <summary>
        /// Send a nice hexadecimal dump of a buffer to the log.
        /// 
        /// @param avcl A pointer to an arbitrary struct of which the first field
        /// is a
        /// pointer to an AVClass struct.
        /// @param level The importance level of the message, lower values
        /// signifying
        /// higher importance.
        /// @param buf buffer
        /// @param size buffer size
        /// 
        /// @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_hex_dump_log")]
        internal static extern void av_hex_dump_log(global::System.IntPtr avcl, int level, byte* buf, int size);

        /// <summary>
        /// Send a nice dump of a packet to the specified file stream.
        /// 
        /// @param f The file stream pointer where the dump should be sent to.
        /// @param pkt packet to dump
        /// @param dump_payload True if the payload must be displayed, too.
        /// @param st AVStream that the packet belongs to
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_pkt_dump2")]
        internal static extern void av_pkt_dump2(_iobuf* f, AVPacket* pkt, int dump_payload, AVStream* st);

        /// <summary>
        /// Send a nice dump of a packet to the log.
        /// 
        /// @param avcl A pointer to an arbitrary struct of which the first field
        /// is a
        /// pointer to an AVClass struct.
        /// @param level The importance level of the message, lower values
        /// signifying
        /// higher importance.
        /// @param pkt packet to dump
        /// @param dump_payload True if the payload must be displayed, too.
        /// @param st AVStream that the packet belongs to
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_pkt_dump_log2")]
        internal static extern void av_pkt_dump_log2(global::System.IntPtr avcl, int level, AVPacket* pkt, int dump_payload, AVStream* st);

        /// <summary>
        /// Get the AVCodecID for the given codec tag tag.
        /// If no codec id is found returns AV_CODEC_ID_NONE.
        /// 
        /// @param tags list of supported codec_id-codec_tag pairs, as stored
        /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_get_id")]
        internal static extern AVCodecID av_codec_get_id(AVCodecTag* tags, uint tag);

        /// <summary>
        /// Get the codec tag for the given codec id id.
        /// If no codec tag is found returns 0.
        /// 
        /// @param tags list of supported codec_id-codec_tag pairs, as stored
        /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_get_tag")]
        internal static extern uint av_codec_get_tag(AVCodecTag* tags, AVCodecID id);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_find_default_stream_index")]
        internal static extern int av_find_default_stream_index(AVFormatContext* s);

        /// <summary>
        /// Get the index for a specific timestamp.
        /// @param flags if AVSEEK_FLAG_BACKWARD then the returned index will
        /// correspond
        /// to the timestamp which is <= the requested one, if backward
        /// is 0, then it will be >=
        /// if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise
        /// @return < 0 if no such timestamp could be found
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_index_search_timestamp")]
        internal static extern int av_index_search_timestamp(AVStream* st, long timestamp, int flags);

        /// <summary>
        /// Add an index entry into a sorted list. Update the entry if the list
        /// already contains it.
        /// 
        /// @param timestamp timestamp in the time base of the given stream
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_add_index_entry")]
        internal static extern int av_add_index_entry(AVStream* st, long pos, long timestamp, int size, int distance, int flags);

        /// <summary>
        /// Split a URL string into components.
        /// 
        /// The pointers to buffers for storing individual components may be null,
        /// in order to ignore that component. Buffers for components not found are
        /// set to empty strings. If the port is not found, it is set to a negative
        /// value.
        /// 
        /// @param proto the buffer for the protocol
        /// @param proto_size the size of the proto buffer
        /// @param authorization the buffer for the authorization
        /// @param authorization_size the size of the authorization buffer
        /// @param hostname the buffer for the host name
        /// @param hostname_size the size of the hostname buffer
        /// @param port_ptr a pointer to store the port number in
        /// @param path the buffer for the path
        /// @param path_size the size of the path buffer
        /// @param url the URL to split
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_url_split")]
        internal static extern void av_url_split(sbyte* proto, int proto_size, sbyte* authorization, int authorization_size, sbyte* hostname, int hostname_size, int* port_ptr, sbyte* path, int path_size, global::System.IntPtr url);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_dump_format")]
        internal static extern void av_dump_format(AVFormatContext* ic, int index, global::System.IntPtr url, int is_output);

        /// <summary>
        /// Return in 'buf' the path with '%d' replaced by a number.
        /// 
        /// Also handles the '%0nd' format where 'n' is the total number
        /// of digits and '%%'.
        /// 
        /// @param buf destination buffer
        /// @param buf_size destination buffer size
        /// @param path numbered sequence string
        /// @param number frame number
        /// @return 0 if OK, -1 on format error
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_get_frame_filename")]
        internal static extern int av_get_frame_filename(sbyte* buf, int buf_size, global::System.IntPtr path, int number);

        /// <summary>
        /// Check whether filename actually is a numbered sequence generator.
        /// 
        /// @param filename possible numbered sequence string
        /// @return 1 if a valid numbered sequence string, 0 otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_filename_number_test")]
        internal static extern int av_filename_number_test(global::System.IntPtr filename);

        /// <summary>
        /// Generate an SDP for an RTP session.
        /// 
        /// @param ac array of AVFormatContexts describing the RTP streams. If the
        /// array is composed by only one context, such context can contain
        /// multiple AVStreams (one AVStream per RTP stream). Otherwise,
        /// all the contexts in the array (an AVCodecContext per RTP stream)
        /// must contain only one AVStream.
        /// @param n_files number of AVCodecContexts contained in ac
        /// @param buf buffer where the SDP will be stored (must be allocated by
        /// the caller)
        /// @param size the size of the buffer
        /// @return 0 if OK, AVERROR_xxx on error
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_sdp_create")]
        internal static extern int av_sdp_create(AVFormatContext* ac, int n_files, sbyte* buf, int size);

        /// <summary>
        /// Return a positive value if the given filename has one of the given
        /// extensions, 0 otherwise.
        /// 
        /// @param extensions a comma-separated list of filename extensions
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_match_ext")]
        internal static extern int av_match_ext(global::System.IntPtr filename, global::System.IntPtr extensions);

        /// <summary>
        /// Test if the given container can store a codec.
        /// 
        /// @param std_compliance standards compliance level, one of
        /// FF_COMPLIANCE_*
        /// 
        /// @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it
        /// cannot.
        /// A negative number if this information is not available.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_query_codec")]
        internal static extern int avformat_query_codec(AVOutputFormat* ofmt, AVCodecID codec_id, int std_compliance);

        /// <summary>
        /// @defgroup riff_fourcc RIFF FourCCs
        /// @{
        /// Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The
        /// tables are
        /// meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the
        /// following code:
        /// @code
        /// uint32_t tag = MKTAG('H', '2', '6', '4');
        /// const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0
        /// };
        /// enum AVCodecID id = av_codec_get_id(table, tag);
        /// @endcode
        /// 
        /// 
        /// @return the table mapping RIFF FourCCs for video to libavcodec
        /// AVCodecID.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_get_riff_video_tags")]
        internal static extern AVCodecTag* avformat_get_riff_video_tags();

        /// <summary>
        /// @return the table mapping RIFF FourCCs for audio to AVCodecID.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_get_riff_audio_tags")]
        internal static extern AVCodecTag* avformat_get_riff_audio_tags();

        /// <summary>
        /// Guess the sample aspect ratio of a frame, based on both the stream and
        /// the
        /// frame aspect ratio.
        /// 
        /// Since the frame aspect ratio is set by the codec but the stream aspect
        /// ratio
        /// is set by the demuxer, these two may not be equal. This function tries
        /// to
        /// return the value that you should use if you would like to display the
        /// frame.
        /// 
        /// Basic logic is to use the stream aspect ratio if it is set to something
        /// sane
        /// otherwise use the frame aspect ratio. This way a container setting,
        /// which is
        /// usually easy to modify can override the coded value in the frames.
        /// 
        /// @param format the format context which the stream is part of
        /// @param stream the stream which the frame is part of
        /// @param frame the frame with the aspect ratio to be determined
        /// @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_guess_sample_aspect_ratio")]
        internal static extern AVRational* av_guess_sample_aspect_ratio(AVFormatContext* format, AVStream* stream, AVFrame* frame);

        /// <summary>
        /// Check if the stream st contained in s is matched by the stream
        /// specifier
        /// spec.
        /// 
        /// See the "stream specifiers" chapter in the documentation for the syntax
        /// of spec.
        /// 
        /// @return  >0 if st is matched by spec;
        /// 0  if st is not matched by spec;
        /// AVERROR code if spec is invalid
        /// 
        /// @note  A stream specifier can match several streams in the format.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_match_stream_specifier")]
        internal static extern int avformat_match_stream_specifier(AVFormatContext* s, AVStream* st, global::System.IntPtr spec);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avformat-if-54.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avformat_queue_attached_pictures")]
        internal static extern void avformat_queue_attached_pictures(AVFormatContext* s);
    }
}
