//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FFmpeg
{
    public unsafe static partial class libavutil
    {
        /// <summary>
        /// Allocate a block of size bytes with alignment suitable for all
        /// memory accesses (including vectors if available on the CPU).
        /// @param size Size in bytes for the memory block to be allocated.
        /// @return Pointer to the allocated block, NULL if the block cannot
        /// be allocated.
        /// @see av_mallocz()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_malloc")]
        public static extern void* av_malloc(global::System.UIntPtr size);

        /// <summary>
        /// Helper function to allocate a block of size * nmemb bytes with
        /// using av_malloc()
        /// @param nmemb Number of elements
        /// @param size Size of the single element
        /// @return Pointer to the allocated block, NULL if the block cannot
        /// be allocated.
        /// @see av_malloc()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_malloc_array")]
        public static extern void* av_malloc_array(global::System.UIntPtr nmemb, global::System.UIntPtr size);

        /// <summary>
        /// Allocate or reallocate a block of memory.
        /// If ptr is NULL and size > 0, allocate a new block. If
        /// size is zero, free the memory block pointed to by ptr.
        /// @param ptr Pointer to a memory block already allocated with
        /// av_malloc(z)() or av_realloc() or NULL.
        /// @param size Size in bytes for the memory block to be allocated or
        /// reallocated.
        /// @return Pointer to a newly reallocated block or NULL if the block
        /// cannot be reallocated or the function is used to free the memory block.
        /// @see av_fast_realloc()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_realloc")]
        public static extern void* av_realloc(void* ptr, global::System.UIntPtr size);

        /// <summary>
        /// Allocate or reallocate a block of memory.
        /// This function does the same thing as av_realloc, except:
        /// - It takes two arguments and checks the result of the multiplication
        /// for
        /// integer overflow.
        /// - It frees the input block in case of failure, thus avoiding the memory
        /// leak with the classic "buf = realloc(buf); if (!buf) return -1;".
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_realloc_f")]
        public static extern void* av_realloc_f(void* ptr, global::System.UIntPtr nelem, global::System.UIntPtr elsize);

        /// <summary>
        /// Free a memory block which has been allocated with av_malloc(z)() or
        /// av_realloc().
        /// @param ptr Pointer to the memory block which should be freed.
        /// @note ptr = NULL is explicitly allowed.
        /// @note It is recommended that you use av_freep() instead.
        /// @see av_freep()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_free")]
        public static extern void av_free(void* ptr);

        /// <summary>
        /// Allocate a block of size bytes with alignment suitable for all
        /// memory accesses (including vectors if available on the CPU) and
        /// zero all the bytes of the block.
        /// @param size Size in bytes for the memory block to be allocated.
        /// @return Pointer to the allocated block, NULL if it cannot be allocated.
        /// @see av_malloc()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_mallocz")]
        public static extern void* av_mallocz(global::System.UIntPtr size);

        /// <summary>
        /// Allocate a block of nmemb * size bytes with alignment suitable for all
        /// memory accesses (including vectors if available on the CPU) and
        /// zero all the bytes of the block.
        /// The allocation will fail if nmemb * size is greater than or equal
        /// to INT_MAX.
        /// @param nmemb
        /// @param size
        /// @return Pointer to the allocated block, NULL if it cannot be allocated.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_calloc")]
        public static extern void* av_calloc(global::System.UIntPtr nmemb, global::System.UIntPtr size);

        /// <summary>
        /// Helper function to allocate a block of size * nmemb bytes with
        /// using av_mallocz()
        /// @param nmemb Number of elements
        /// @param size Size of the single element
        /// @return Pointer to the allocated block, NULL if the block cannot
        /// be allocated.
        /// @see av_mallocz()
        /// @see av_malloc_array()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_mallocz_array")]
        public static extern void* av_mallocz_array(global::System.UIntPtr nmemb, global::System.UIntPtr size);

        /// <summary>
        /// Duplicate the string s.
        /// @param s string to be duplicated
        /// @return Pointer to a newly allocated string containing a
        /// copy of s or NULL if the string cannot be allocated.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_strdup")]
        public static extern sbyte* av_strdup(string s);

        /// <summary>
        /// Free a memory block which has been allocated with av_malloc(z)() or
        /// av_realloc() and set the pointer pointing to it to NULL.
        /// @param ptr Pointer to the pointer to the memory block which should
        /// be freed.
        /// @see av_free()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_freep")]
        public static extern void av_freep(void* ptr);

        /// <summary>
        /// Add an element to a dynamic array.
        /// 
        /// @param tab_ptr Pointer to the array.
        /// @param nb_ptr  Pointer to the number of elements in the array.
        /// @param elem    Element to be added.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_dynarray_add")]
        public static extern void av_dynarray_add(void* tab_ptr, int* nb_ptr, void* elem);

        /// <summary>
        /// Multiply two size_t values checking for overflow.
        /// @return  0 if success, AVERROR(EINVAL) if overflow.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_size_mult")]
        public static extern int av_size_mult(global::System.UIntPtr a, global::System.UIntPtr b, global::System.UIntPtr* r);

        /// <summary>
        /// Set the maximum size that may me allocated in one block.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_max_alloc")]
        public static extern void av_max_alloc(global::System.UIntPtr max);
    }
}
