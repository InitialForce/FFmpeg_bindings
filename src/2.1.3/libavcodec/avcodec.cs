//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace libavcodec
{
    /// <summary>
    /// Identify the syntax and semantics of the bitstream.
    /// The principle is roughly:
    /// Two decoders with the same ID can decode the same streams.
    /// Two encoders with the same ID can encode compatible streams.
    /// There may be slight deviations from the principle due to implementation
    /// details.
    /// 
    /// If you add a codec ID to this list, add it so that
    /// 1. no value of a existing codec ID changes (that would break ABI),
    /// 2. Give it a value which when taken as ASCII is recognized uniquely by
    /// a human as this specific codec.
    /// This ensures that 2 forks can independently add AVCodecIDs without
    /// producing conflicts.
    /// 
    /// After adding new codec IDs, do not forget to add an entry to the codec
    /// descriptor list and bump libavcodec minor version.
    /// </summary>
    public enum AVCodecID
    {
        AV_CODEC_ID_NONE = 0,
        AV_CODEC_ID_MPEG1VIDEO = 1,
        /// <summary>preferred ID for MPEG-1/2 video decoding</summary>
        AV_CODEC_ID_MPEG2VIDEO = 2,
        AV_CODEC_ID_MPEG2VIDEO_XVMC = 3,
        AV_CODEC_ID_H261 = 4,
        AV_CODEC_ID_H263 = 5,
        AV_CODEC_ID_RV10 = 6,
        AV_CODEC_ID_RV20 = 7,
        AV_CODEC_ID_MJPEG = 8,
        AV_CODEC_ID_MJPEGB = 9,
        AV_CODEC_ID_LJPEG = 10,
        AV_CODEC_ID_SP5X = 11,
        AV_CODEC_ID_JPEGLS = 12,
        AV_CODEC_ID_MPEG4 = 13,
        AV_CODEC_ID_RAWVIDEO = 14,
        AV_CODEC_ID_MSMPEG4V1 = 15,
        AV_CODEC_ID_MSMPEG4V2 = 16,
        AV_CODEC_ID_MSMPEG4V3 = 17,
        AV_CODEC_ID_WMV1 = 18,
        AV_CODEC_ID_WMV2 = 19,
        AV_CODEC_ID_H263P = 20,
        AV_CODEC_ID_H263I = 21,
        AV_CODEC_ID_FLV1 = 22,
        AV_CODEC_ID_SVQ1 = 23,
        AV_CODEC_ID_SVQ3 = 24,
        AV_CODEC_ID_DVVIDEO = 25,
        AV_CODEC_ID_HUFFYUV = 26,
        AV_CODEC_ID_CYUV = 27,
        AV_CODEC_ID_H264 = 28,
        AV_CODEC_ID_INDEO3 = 29,
        AV_CODEC_ID_VP3 = 30,
        AV_CODEC_ID_THEORA = 31,
        AV_CODEC_ID_ASV1 = 32,
        AV_CODEC_ID_ASV2 = 33,
        AV_CODEC_ID_FFV1 = 34,
        AV_CODEC_ID_4XM = 35,
        AV_CODEC_ID_VCR1 = 36,
        AV_CODEC_ID_CLJR = 37,
        AV_CODEC_ID_MDEC = 38,
        AV_CODEC_ID_ROQ = 39,
        AV_CODEC_ID_INTERPLAY_VIDEO = 40,
        AV_CODEC_ID_XAN_WC3 = 41,
        AV_CODEC_ID_XAN_WC4 = 42,
        AV_CODEC_ID_RPZA = 43,
        AV_CODEC_ID_CINEPAK = 44,
        AV_CODEC_ID_WS_VQA = 45,
        AV_CODEC_ID_MSRLE = 46,
        AV_CODEC_ID_MSVIDEO1 = 47,
        AV_CODEC_ID_IDCIN = 48,
        AV_CODEC_ID_8BPS = 49,
        AV_CODEC_ID_SMC = 50,
        AV_CODEC_ID_FLIC = 51,
        AV_CODEC_ID_TRUEMOTION1 = 52,
        AV_CODEC_ID_VMDVIDEO = 53,
        AV_CODEC_ID_MSZH = 54,
        AV_CODEC_ID_ZLIB = 55,
        AV_CODEC_ID_QTRLE = 56,
        AV_CODEC_ID_TSCC = 57,
        AV_CODEC_ID_ULTI = 58,
        AV_CODEC_ID_QDRAW = 59,
        AV_CODEC_ID_VIXL = 60,
        AV_CODEC_ID_QPEG = 61,
        AV_CODEC_ID_PNG = 62,
        AV_CODEC_ID_PPM = 63,
        AV_CODEC_ID_PBM = 64,
        AV_CODEC_ID_PGM = 65,
        AV_CODEC_ID_PGMYUV = 66,
        AV_CODEC_ID_PAM = 67,
        AV_CODEC_ID_FFVHUFF = 68,
        AV_CODEC_ID_RV30 = 69,
        AV_CODEC_ID_RV40 = 70,
        AV_CODEC_ID_VC1 = 71,
        AV_CODEC_ID_WMV3 = 72,
        AV_CODEC_ID_LOCO = 73,
        AV_CODEC_ID_WNV1 = 74,
        AV_CODEC_ID_AASC = 75,
        AV_CODEC_ID_INDEO2 = 76,
        AV_CODEC_ID_FRAPS = 77,
        AV_CODEC_ID_TRUEMOTION2 = 78,
        AV_CODEC_ID_BMP = 79,
        AV_CODEC_ID_CSCD = 80,
        AV_CODEC_ID_MMVIDEO = 81,
        AV_CODEC_ID_ZMBV = 82,
        AV_CODEC_ID_AVS = 83,
        AV_CODEC_ID_SMACKVIDEO = 84,
        AV_CODEC_ID_NUV = 85,
        AV_CODEC_ID_KMVC = 86,
        AV_CODEC_ID_FLASHSV = 87,
        AV_CODEC_ID_CAVS = 88,
        AV_CODEC_ID_JPEG2000 = 89,
        AV_CODEC_ID_VMNC = 90,
        AV_CODEC_ID_VP5 = 91,
        AV_CODEC_ID_VP6 = 92,
        AV_CODEC_ID_VP6F = 93,
        AV_CODEC_ID_TARGA = 94,
        AV_CODEC_ID_DSICINVIDEO = 95,
        AV_CODEC_ID_TIERTEXSEQVIDEO = 96,
        AV_CODEC_ID_TIFF = 97,
        AV_CODEC_ID_GIF = 98,
        AV_CODEC_ID_DXA = 99,
        AV_CODEC_ID_DNXHD = 100,
        AV_CODEC_ID_THP = 101,
        AV_CODEC_ID_SGI = 102,
        AV_CODEC_ID_C93 = 103,
        AV_CODEC_ID_BETHSOFTVID = 104,
        AV_CODEC_ID_PTX = 105,
        AV_CODEC_ID_TXD = 106,
        AV_CODEC_ID_VP6A = 107,
        AV_CODEC_ID_AMV = 108,
        AV_CODEC_ID_VB = 109,
        AV_CODEC_ID_PCX = 110,
        AV_CODEC_ID_SUNRAST = 111,
        AV_CODEC_ID_INDEO4 = 112,
        AV_CODEC_ID_INDEO5 = 113,
        AV_CODEC_ID_MIMIC = 114,
        AV_CODEC_ID_RL2 = 115,
        AV_CODEC_ID_ESCAPE124 = 116,
        AV_CODEC_ID_DIRAC = 117,
        AV_CODEC_ID_BFI = 118,
        AV_CODEC_ID_CMV = 119,
        AV_CODEC_ID_MOTIONPIXELS = 120,
        AV_CODEC_ID_TGV = 121,
        AV_CODEC_ID_TGQ = 122,
        AV_CODEC_ID_TQI = 123,
        AV_CODEC_ID_AURA = 124,
        AV_CODEC_ID_AURA2 = 125,
        AV_CODEC_ID_V210X = 126,
        AV_CODEC_ID_TMV = 127,
        AV_CODEC_ID_V210 = 128,
        AV_CODEC_ID_DPX = 129,
        AV_CODEC_ID_MAD = 130,
        AV_CODEC_ID_FRWU = 131,
        AV_CODEC_ID_FLASHSV2 = 132,
        AV_CODEC_ID_CDGRAPHICS = 133,
        AV_CODEC_ID_R210 = 134,
        AV_CODEC_ID_ANM = 135,
        AV_CODEC_ID_BINKVIDEO = 136,
        AV_CODEC_ID_IFF_ILBM = 137,
        AV_CODEC_ID_IFF_BYTERUN1 = 138,
        AV_CODEC_ID_KGV1 = 139,
        AV_CODEC_ID_YOP = 140,
        AV_CODEC_ID_VP8 = 141,
        AV_CODEC_ID_PICTOR = 142,
        AV_CODEC_ID_ANSI = 143,
        AV_CODEC_ID_A64_MULTI = 144,
        AV_CODEC_ID_A64_MULTI5 = 145,
        AV_CODEC_ID_R10K = 146,
        AV_CODEC_ID_MXPEG = 147,
        AV_CODEC_ID_LAGARITH = 148,
        AV_CODEC_ID_PRORES = 149,
        AV_CODEC_ID_JV = 150,
        AV_CODEC_ID_DFA = 151,
        AV_CODEC_ID_WMV3IMAGE = 152,
        AV_CODEC_ID_VC1IMAGE = 153,
        AV_CODEC_ID_UTVIDEO = 154,
        AV_CODEC_ID_BMV_VIDEO = 155,
        AV_CODEC_ID_VBLE = 156,
        AV_CODEC_ID_DXTORY = 157,
        AV_CODEC_ID_V410 = 158,
        AV_CODEC_ID_XWD = 159,
        AV_CODEC_ID_CDXL = 160,
        AV_CODEC_ID_XBM = 161,
        AV_CODEC_ID_ZEROCODEC = 162,
        AV_CODEC_ID_MSS1 = 163,
        AV_CODEC_ID_MSA1 = 164,
        AV_CODEC_ID_TSCC2 = 165,
        AV_CODEC_ID_MTS2 = 166,
        AV_CODEC_ID_CLLC = 167,
        AV_CODEC_ID_MSS2 = 168,
        AV_CODEC_ID_VP9 = 169,
        AV_CODEC_ID_AIC = 170,
        AV_CODEC_ID_ESCAPE130_DEPRECATED = 171,
        AV_CODEC_ID_G2M_DEPRECATED = 172,
        AV_CODEC_ID_WEBP_DEPRECATED = 173,
        AV_CODEC_ID_BRENDER_PIX = 1112557912,
        AV_CODEC_ID_Y41P = 1496592720,
        AV_CODEC_ID_ESCAPE130 = 1160852272,
        AV_CODEC_ID_EXR = 809850962,
        AV_CODEC_ID_AVRP = 1096176208,
        AV_CODEC_ID_012V = 808530518,
        AV_CODEC_ID_G2M = 4665933,
        AV_CODEC_ID_AVUI = 1096176969,
        AV_CODEC_ID_AYUV = 1096373590,
        AV_CODEC_ID_TARGA_Y216 = 1412575542,
        AV_CODEC_ID_V308 = 1446195256,
        AV_CODEC_ID_V408 = 1446260792,
        AV_CODEC_ID_YUV4 = 1498764852,
        AV_CODEC_ID_SANM = 1396788813,
        AV_CODEC_ID_PAF_VIDEO = 1346455126,
        AV_CODEC_ID_AVRN = 1096176238,
        AV_CODEC_ID_CPIA = 1129335105,
        AV_CODEC_ID_XFACE = 1480999235,
        AV_CODEC_ID_SGIRLE = 1397180754,
        AV_CODEC_ID_MVC1 = 1297498929,
        AV_CODEC_ID_MVC2 = 1297498930,
        AV_CODEC_ID_SNOW = 1397641047,
        AV_CODEC_ID_WEBP = 1464156752,
        AV_CODEC_ID_SMVJPEG = 1397577290,
        AV_CODEC_ID_HEVC = 1211250229,
        /// <summary>A dummy id pointing at the start of audio codecs</summary>
        AV_CODEC_ID_FIRST_AUDIO = 65536,
        AV_CODEC_ID_PCM_S16LE = 65536,
        AV_CODEC_ID_PCM_S16BE = 65537,
        AV_CODEC_ID_PCM_U16LE = 65538,
        AV_CODEC_ID_PCM_U16BE = 65539,
        AV_CODEC_ID_PCM_S8 = 65540,
        AV_CODEC_ID_PCM_U8 = 65541,
        AV_CODEC_ID_PCM_MULAW = 65542,
        AV_CODEC_ID_PCM_ALAW = 65543,
        AV_CODEC_ID_PCM_S32LE = 65544,
        AV_CODEC_ID_PCM_S32BE = 65545,
        AV_CODEC_ID_PCM_U32LE = 65546,
        AV_CODEC_ID_PCM_U32BE = 65547,
        AV_CODEC_ID_PCM_S24LE = 65548,
        AV_CODEC_ID_PCM_S24BE = 65549,
        AV_CODEC_ID_PCM_U24LE = 65550,
        AV_CODEC_ID_PCM_U24BE = 65551,
        AV_CODEC_ID_PCM_S24DAUD = 65552,
        AV_CODEC_ID_PCM_ZORK = 65553,
        AV_CODEC_ID_PCM_S16LE_PLANAR = 65554,
        AV_CODEC_ID_PCM_DVD = 65555,
        AV_CODEC_ID_PCM_F32BE = 65556,
        AV_CODEC_ID_PCM_F32LE = 65557,
        AV_CODEC_ID_PCM_F64BE = 65558,
        AV_CODEC_ID_PCM_F64LE = 65559,
        AV_CODEC_ID_PCM_BLURAY = 65560,
        AV_CODEC_ID_PCM_LXF = 65561,
        AV_CODEC_ID_S302M = 65562,
        AV_CODEC_ID_PCM_S8_PLANAR = 65563,
        AV_CODEC_ID_PCM_S24LE_PLANAR_DEPRECATED = 65564,
        AV_CODEC_ID_PCM_S32LE_PLANAR_DEPRECATED = 65565,
        AV_CODEC_ID_PCM_S24LE_PLANAR = 407917392,
        AV_CODEC_ID_PCM_S32LE_PLANAR = 542135120,
        AV_CODEC_ID_PCM_S16BE_PLANAR = 1347637264,
        AV_CODEC_ID_ADPCM_IMA_QT = 69632,
        AV_CODEC_ID_ADPCM_IMA_WAV = 69633,
        AV_CODEC_ID_ADPCM_IMA_DK3 = 69634,
        AV_CODEC_ID_ADPCM_IMA_DK4 = 69635,
        AV_CODEC_ID_ADPCM_IMA_WS = 69636,
        AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637,
        AV_CODEC_ID_ADPCM_MS = 69638,
        AV_CODEC_ID_ADPCM_4XM = 69639,
        AV_CODEC_ID_ADPCM_XA = 69640,
        AV_CODEC_ID_ADPCM_ADX = 69641,
        AV_CODEC_ID_ADPCM_EA = 69642,
        AV_CODEC_ID_ADPCM_G726 = 69643,
        AV_CODEC_ID_ADPCM_CT = 69644,
        AV_CODEC_ID_ADPCM_SWF = 69645,
        AV_CODEC_ID_ADPCM_YAMAHA = 69646,
        AV_CODEC_ID_ADPCM_SBPRO_4 = 69647,
        AV_CODEC_ID_ADPCM_SBPRO_3 = 69648,
        AV_CODEC_ID_ADPCM_SBPRO_2 = 69649,
        AV_CODEC_ID_ADPCM_THP = 69650,
        AV_CODEC_ID_ADPCM_IMA_AMV = 69651,
        AV_CODEC_ID_ADPCM_EA_R1 = 69652,
        AV_CODEC_ID_ADPCM_EA_R3 = 69653,
        AV_CODEC_ID_ADPCM_EA_R2 = 69654,
        AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655,
        AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656,
        AV_CODEC_ID_ADPCM_EA_XAS = 69657,
        AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658,
        AV_CODEC_ID_ADPCM_IMA_ISS = 69659,
        AV_CODEC_ID_ADPCM_G722 = 69660,
        AV_CODEC_ID_ADPCM_IMA_APC = 69661,
        AV_CODEC_ID_VIMA = 1447644481,
        AV_CODEC_ID_ADPCM_AFC = 1095123744,
        AV_CODEC_ID_ADPCM_IMA_OKI = 1330333984,
        AV_CODEC_ID_ADPCM_DTK = 1146374944,
        AV_CODEC_ID_ADPCM_IMA_RAD = 1380008992,
        AV_CODEC_ID_ADPCM_G726LE = 909260615,
        AV_CODEC_ID_AMR_NB = 73728,
        AV_CODEC_ID_AMR_WB = 73729,
        AV_CODEC_ID_RA_144 = 77824,
        AV_CODEC_ID_RA_288 = 77825,
        AV_CODEC_ID_ROQ_DPCM = 81920,
        AV_CODEC_ID_INTERPLAY_DPCM = 81921,
        AV_CODEC_ID_XAN_DPCM = 81922,
        AV_CODEC_ID_SOL_DPCM = 81923,
        AV_CODEC_ID_MP2 = 86016,
        /// <summary>preferred ID for decoding MPEG audio layer 1, 2 or 3</summary>
        AV_CODEC_ID_MP3 = 86017,
        AV_CODEC_ID_AAC = 86018,
        AV_CODEC_ID_AC3 = 86019,
        AV_CODEC_ID_DTS = 86020,
        AV_CODEC_ID_VORBIS = 86021,
        AV_CODEC_ID_DVAUDIO = 86022,
        AV_CODEC_ID_WMAV1 = 86023,
        AV_CODEC_ID_WMAV2 = 86024,
        AV_CODEC_ID_MACE3 = 86025,
        AV_CODEC_ID_MACE6 = 86026,
        AV_CODEC_ID_VMDAUDIO = 86027,
        AV_CODEC_ID_FLAC = 86028,
        AV_CODEC_ID_MP3ADU = 86029,
        AV_CODEC_ID_MP3ON4 = 86030,
        AV_CODEC_ID_SHORTEN = 86031,
        AV_CODEC_ID_ALAC = 86032,
        AV_CODEC_ID_WESTWOOD_SND1 = 86033,
        /// <summary>as in Berlin toast format</summary>
        AV_CODEC_ID_GSM = 86034,
        AV_CODEC_ID_QDM2 = 86035,
        AV_CODEC_ID_COOK = 86036,
        AV_CODEC_ID_TRUESPEECH = 86037,
        AV_CODEC_ID_TTA = 86038,
        AV_CODEC_ID_SMACKAUDIO = 86039,
        AV_CODEC_ID_QCELP = 86040,
        AV_CODEC_ID_WAVPACK = 86041,
        AV_CODEC_ID_DSICINAUDIO = 86042,
        AV_CODEC_ID_IMC = 86043,
        AV_CODEC_ID_MUSEPACK7 = 86044,
        AV_CODEC_ID_MLP = 86045,
        AV_CODEC_ID_GSM_MS = 86046,
        AV_CODEC_ID_ATRAC3 = 86047,
        AV_CODEC_ID_VOXWARE = 86048,
        AV_CODEC_ID_APE = 86049,
        AV_CODEC_ID_NELLYMOSER = 86050,
        AV_CODEC_ID_MUSEPACK8 = 86051,
        AV_CODEC_ID_SPEEX = 86052,
        AV_CODEC_ID_WMAVOICE = 86053,
        AV_CODEC_ID_WMAPRO = 86054,
        AV_CODEC_ID_WMALOSSLESS = 86055,
        AV_CODEC_ID_ATRAC3P = 86056,
        AV_CODEC_ID_EAC3 = 86057,
        AV_CODEC_ID_SIPR = 86058,
        AV_CODEC_ID_MP1 = 86059,
        AV_CODEC_ID_TWINVQ = 86060,
        AV_CODEC_ID_TRUEHD = 86061,
        AV_CODEC_ID_MP4ALS = 86062,
        AV_CODEC_ID_ATRAC1 = 86063,
        AV_CODEC_ID_BINKAUDIO_RDFT = 86064,
        AV_CODEC_ID_BINKAUDIO_DCT = 86065,
        AV_CODEC_ID_AAC_LATM = 86066,
        AV_CODEC_ID_QDMC = 86067,
        AV_CODEC_ID_CELT = 86068,
        AV_CODEC_ID_G723_1 = 86069,
        AV_CODEC_ID_G729 = 86070,
        AV_CODEC_ID_8SVX_EXP = 86071,
        AV_CODEC_ID_8SVX_FIB = 86072,
        AV_CODEC_ID_BMV_AUDIO = 86073,
        AV_CODEC_ID_RALF = 86074,
        AV_CODEC_ID_IAC = 86075,
        AV_CODEC_ID_ILBC = 86076,
        AV_CODEC_ID_OPUS_DEPRECATED = 86077,
        AV_CODEC_ID_COMFORT_NOISE = 86078,
        AV_CODEC_ID_TAK_DEPRECATED = 86079,
        AV_CODEC_ID_METASOUND = 86080,
        AV_CODEC_ID_FFWAVESYNTH = 1179014995,
        AV_CODEC_ID_SONIC = 1397706307,
        AV_CODEC_ID_SONIC_LS = 1397706316,
        AV_CODEC_ID_PAF_AUDIO = 1346455105,
        AV_CODEC_ID_OPUS = 1330664787,
        AV_CODEC_ID_TAK = 1950507339,
        AV_CODEC_ID_EVRC = 1936029283,
        AV_CODEC_ID_SMV = 1936944502,
        /// <summary>A dummy ID pointing at the start of subtitle codecs.</summary>
        AV_CODEC_ID_FIRST_SUBTITLE = 94208,
        AV_CODEC_ID_DVD_SUBTITLE = 94208,
        AV_CODEC_ID_DVB_SUBTITLE = 94209,
        /// <summary>raw UTF-8 text</summary>
        AV_CODEC_ID_TEXT = 94210,
        AV_CODEC_ID_XSUB = 94211,
        AV_CODEC_ID_SSA = 94212,
        AV_CODEC_ID_MOV_TEXT = 94213,
        AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214,
        AV_CODEC_ID_DVB_TELETEXT = 94215,
        AV_CODEC_ID_SRT = 94216,
        AV_CODEC_ID_MICRODVD = 1833195076,
        AV_CODEC_ID_EIA_608 = 1664495672,
        AV_CODEC_ID_JACOSUB = 1246975298,
        AV_CODEC_ID_SAMI = 1396788553,
        AV_CODEC_ID_REALTEXT = 1381259348,
        AV_CODEC_ID_SUBVIEWER1 = 1398953521,
        AV_CODEC_ID_SUBVIEWER = 1400201814,
        AV_CODEC_ID_SUBRIP = 1397909872,
        AV_CODEC_ID_WEBVTT = 1465275476,
        AV_CODEC_ID_MPL2 = 1297108018,
        AV_CODEC_ID_VPLAYER = 1448111218,
        AV_CODEC_ID_PJS = 1349012051,
        /// <summary>ASS as defined in Matroska</summary>
        AV_CODEC_ID_ASS = 1095979808,
        /// <summary>A dummy ID pointing at the start of various fake codecs.</summary>
        AV_CODEC_ID_FIRST_UNKNOWN = 98304,
        AV_CODEC_ID_TTF = 98304,
        AV_CODEC_ID_BINTEXT = 1112823892,
        AV_CODEC_ID_XBIN = 1480739150,
        AV_CODEC_ID_IDF = 4801606,
        AV_CODEC_ID_OTF = 5198918,
        AV_CODEC_ID_SMPTE_KLV = 1263294017,
        AV_CODEC_ID_DVD_NAV = 1145979222,
        /// <summary>codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it</summary>
        AV_CODEC_ID_PROBE = 102400,
        /// <summary>_FAKE_ codec to indicate a raw MPEG-2 TS stream (only used by libavformat)</summary>
        AV_CODEC_ID_MPEG2TS = 131072,
        /// <summary>_FAKE_ codec to indicate a MPEG-4 Systems stream (only used by libavformat)</summary>
        AV_CODEC_ID_MPEG4SYSTEMS = 131073,
        /// <summary>Dummy codec for streams containing only metadata information.</summary>
        AV_CODEC_ID_FFMETADATA = 135168,
        CODEC_ID_NONE = 0,
        CODEC_ID_MPEG1VIDEO = 1,
        /// <summary>preferred ID for MPEG-1/2 video decoding</summary>
        CODEC_ID_MPEG2VIDEO = 2,
        CODEC_ID_MPEG2VIDEO_XVMC = 3,
        CODEC_ID_H261 = 4,
        CODEC_ID_H263 = 5,
        CODEC_ID_RV10 = 6,
        CODEC_ID_RV20 = 7,
        CODEC_ID_MJPEG = 8,
        CODEC_ID_MJPEGB = 9,
        CODEC_ID_LJPEG = 10,
        CODEC_ID_SP5X = 11,
        CODEC_ID_JPEGLS = 12,
        CODEC_ID_MPEG4 = 13,
        CODEC_ID_RAWVIDEO = 14,
        CODEC_ID_MSMPEG4V1 = 15,
        CODEC_ID_MSMPEG4V2 = 16,
        CODEC_ID_MSMPEG4V3 = 17,
        CODEC_ID_WMV1 = 18,
        CODEC_ID_WMV2 = 19,
        CODEC_ID_H263P = 20,
        CODEC_ID_H263I = 21,
        CODEC_ID_FLV1 = 22,
        CODEC_ID_SVQ1 = 23,
        CODEC_ID_SVQ3 = 24,
        CODEC_ID_DVVIDEO = 25,
        CODEC_ID_HUFFYUV = 26,
        CODEC_ID_CYUV = 27,
        CODEC_ID_H264 = 28,
        CODEC_ID_INDEO3 = 29,
        CODEC_ID_VP3 = 30,
        CODEC_ID_THEORA = 31,
        CODEC_ID_ASV1 = 32,
        CODEC_ID_ASV2 = 33,
        CODEC_ID_FFV1 = 34,
        CODEC_ID_4XM = 35,
        CODEC_ID_VCR1 = 36,
        CODEC_ID_CLJR = 37,
        CODEC_ID_MDEC = 38,
        CODEC_ID_ROQ = 39,
        CODEC_ID_INTERPLAY_VIDEO = 40,
        CODEC_ID_XAN_WC3 = 41,
        CODEC_ID_XAN_WC4 = 42,
        CODEC_ID_RPZA = 43,
        CODEC_ID_CINEPAK = 44,
        CODEC_ID_WS_VQA = 45,
        CODEC_ID_MSRLE = 46,
        CODEC_ID_MSVIDEO1 = 47,
        CODEC_ID_IDCIN = 48,
        CODEC_ID_8BPS = 49,
        CODEC_ID_SMC = 50,
        CODEC_ID_FLIC = 51,
        CODEC_ID_TRUEMOTION1 = 52,
        CODEC_ID_VMDVIDEO = 53,
        CODEC_ID_MSZH = 54,
        CODEC_ID_ZLIB = 55,
        CODEC_ID_QTRLE = 56,
        CODEC_ID_TSCC = 57,
        CODEC_ID_ULTI = 58,
        CODEC_ID_QDRAW = 59,
        CODEC_ID_VIXL = 60,
        CODEC_ID_QPEG = 61,
        CODEC_ID_PNG = 62,
        CODEC_ID_PPM = 63,
        CODEC_ID_PBM = 64,
        CODEC_ID_PGM = 65,
        CODEC_ID_PGMYUV = 66,
        CODEC_ID_PAM = 67,
        CODEC_ID_FFVHUFF = 68,
        CODEC_ID_RV30 = 69,
        CODEC_ID_RV40 = 70,
        CODEC_ID_VC1 = 71,
        CODEC_ID_WMV3 = 72,
        CODEC_ID_LOCO = 73,
        CODEC_ID_WNV1 = 74,
        CODEC_ID_AASC = 75,
        CODEC_ID_INDEO2 = 76,
        CODEC_ID_FRAPS = 77,
        CODEC_ID_TRUEMOTION2 = 78,
        CODEC_ID_BMP = 79,
        CODEC_ID_CSCD = 80,
        CODEC_ID_MMVIDEO = 81,
        CODEC_ID_ZMBV = 82,
        CODEC_ID_AVS = 83,
        CODEC_ID_SMACKVIDEO = 84,
        CODEC_ID_NUV = 85,
        CODEC_ID_KMVC = 86,
        CODEC_ID_FLASHSV = 87,
        CODEC_ID_CAVS = 88,
        CODEC_ID_JPEG2000 = 89,
        CODEC_ID_VMNC = 90,
        CODEC_ID_VP5 = 91,
        CODEC_ID_VP6 = 92,
        CODEC_ID_VP6F = 93,
        CODEC_ID_TARGA = 94,
        CODEC_ID_DSICINVIDEO = 95,
        CODEC_ID_TIERTEXSEQVIDEO = 96,
        CODEC_ID_TIFF = 97,
        CODEC_ID_GIF = 98,
        CODEC_ID_DXA = 99,
        CODEC_ID_DNXHD = 100,
        CODEC_ID_THP = 101,
        CODEC_ID_SGI = 102,
        CODEC_ID_C93 = 103,
        CODEC_ID_BETHSOFTVID = 104,
        CODEC_ID_PTX = 105,
        CODEC_ID_TXD = 106,
        CODEC_ID_VP6A = 107,
        CODEC_ID_AMV = 108,
        CODEC_ID_VB = 109,
        CODEC_ID_PCX = 110,
        CODEC_ID_SUNRAST = 111,
        CODEC_ID_INDEO4 = 112,
        CODEC_ID_INDEO5 = 113,
        CODEC_ID_MIMIC = 114,
        CODEC_ID_RL2 = 115,
        CODEC_ID_ESCAPE124 = 116,
        CODEC_ID_DIRAC = 117,
        CODEC_ID_BFI = 118,
        CODEC_ID_CMV = 119,
        CODEC_ID_MOTIONPIXELS = 120,
        CODEC_ID_TGV = 121,
        CODEC_ID_TGQ = 122,
        CODEC_ID_TQI = 123,
        CODEC_ID_AURA = 124,
        CODEC_ID_AURA2 = 125,
        CODEC_ID_V210X = 126,
        CODEC_ID_TMV = 127,
        CODEC_ID_V210 = 128,
        CODEC_ID_DPX = 129,
        CODEC_ID_MAD = 130,
        CODEC_ID_FRWU = 131,
        CODEC_ID_FLASHSV2 = 132,
        CODEC_ID_CDGRAPHICS = 133,
        CODEC_ID_R210 = 134,
        CODEC_ID_ANM = 135,
        CODEC_ID_BINKVIDEO = 136,
        CODEC_ID_IFF_ILBM = 137,
        CODEC_ID_IFF_BYTERUN1 = 138,
        CODEC_ID_KGV1 = 139,
        CODEC_ID_YOP = 140,
        CODEC_ID_VP8 = 141,
        CODEC_ID_PICTOR = 142,
        CODEC_ID_ANSI = 143,
        CODEC_ID_A64_MULTI = 144,
        CODEC_ID_A64_MULTI5 = 145,
        CODEC_ID_R10K = 146,
        CODEC_ID_MXPEG = 147,
        CODEC_ID_LAGARITH = 148,
        CODEC_ID_PRORES = 149,
        CODEC_ID_JV = 150,
        CODEC_ID_DFA = 151,
        CODEC_ID_WMV3IMAGE = 152,
        CODEC_ID_VC1IMAGE = 153,
        CODEC_ID_UTVIDEO = 154,
        CODEC_ID_BMV_VIDEO = 155,
        CODEC_ID_VBLE = 156,
        CODEC_ID_DXTORY = 157,
        CODEC_ID_V410 = 158,
        CODEC_ID_XWD = 159,
        CODEC_ID_CDXL = 160,
        CODEC_ID_XBM = 161,
        CODEC_ID_ZEROCODEC = 162,
        CODEC_ID_MSS1 = 163,
        CODEC_ID_MSA1 = 164,
        CODEC_ID_TSCC2 = 165,
        CODEC_ID_MTS2 = 166,
        CODEC_ID_CLLC = 167,
        CODEC_ID_Y41P = 1496592720,
        CODEC_ID_ESCAPE130 = 1160852272,
        CODEC_ID_EXR = 809850962,
        CODEC_ID_AVRP = 1096176208,
        CODEC_ID_G2M = 4665933,
        CODEC_ID_AVUI = 1096176969,
        CODEC_ID_AYUV = 1096373590,
        CODEC_ID_V308 = 1446195256,
        CODEC_ID_V408 = 1446260792,
        CODEC_ID_YUV4 = 1498764852,
        CODEC_ID_SANM = 1396788813,
        CODEC_ID_PAF_VIDEO = 1346455126,
        CODEC_ID_SNOW = 1397641047,
        /// <summary>A dummy id pointing at the start of audio codecs</summary>
        CODEC_ID_FIRST_AUDIO = 65536,
        CODEC_ID_PCM_S16LE = 65536,
        CODEC_ID_PCM_S16BE = 65537,
        CODEC_ID_PCM_U16LE = 65538,
        CODEC_ID_PCM_U16BE = 65539,
        CODEC_ID_PCM_S8 = 65540,
        CODEC_ID_PCM_U8 = 65541,
        CODEC_ID_PCM_MULAW = 65542,
        CODEC_ID_PCM_ALAW = 65543,
        CODEC_ID_PCM_S32LE = 65544,
        CODEC_ID_PCM_S32BE = 65545,
        CODEC_ID_PCM_U32LE = 65546,
        CODEC_ID_PCM_U32BE = 65547,
        CODEC_ID_PCM_S24LE = 65548,
        CODEC_ID_PCM_S24BE = 65549,
        CODEC_ID_PCM_U24LE = 65550,
        CODEC_ID_PCM_U24BE = 65551,
        CODEC_ID_PCM_S24DAUD = 65552,
        CODEC_ID_PCM_ZORK = 65553,
        CODEC_ID_PCM_S16LE_PLANAR = 65554,
        CODEC_ID_PCM_DVD = 65555,
        CODEC_ID_PCM_F32BE = 65556,
        CODEC_ID_PCM_F32LE = 65557,
        CODEC_ID_PCM_F64BE = 65558,
        CODEC_ID_PCM_F64LE = 65559,
        CODEC_ID_PCM_BLURAY = 65560,
        CODEC_ID_PCM_LXF = 65561,
        CODEC_ID_S302M = 65562,
        CODEC_ID_PCM_S8_PLANAR = 65563,
        CODEC_ID_ADPCM_IMA_QT = 69632,
        CODEC_ID_ADPCM_IMA_WAV = 69633,
        CODEC_ID_ADPCM_IMA_DK3 = 69634,
        CODEC_ID_ADPCM_IMA_DK4 = 69635,
        CODEC_ID_ADPCM_IMA_WS = 69636,
        CODEC_ID_ADPCM_IMA_SMJPEG = 69637,
        CODEC_ID_ADPCM_MS = 69638,
        CODEC_ID_ADPCM_4XM = 69639,
        CODEC_ID_ADPCM_XA = 69640,
        CODEC_ID_ADPCM_ADX = 69641,
        CODEC_ID_ADPCM_EA = 69642,
        CODEC_ID_ADPCM_G726 = 69643,
        CODEC_ID_ADPCM_CT = 69644,
        CODEC_ID_ADPCM_SWF = 69645,
        CODEC_ID_ADPCM_YAMAHA = 69646,
        CODEC_ID_ADPCM_SBPRO_4 = 69647,
        CODEC_ID_ADPCM_SBPRO_3 = 69648,
        CODEC_ID_ADPCM_SBPRO_2 = 69649,
        CODEC_ID_ADPCM_THP = 69650,
        CODEC_ID_ADPCM_IMA_AMV = 69651,
        CODEC_ID_ADPCM_EA_R1 = 69652,
        CODEC_ID_ADPCM_EA_R3 = 69653,
        CODEC_ID_ADPCM_EA_R2 = 69654,
        CODEC_ID_ADPCM_IMA_EA_SEAD = 69655,
        CODEC_ID_ADPCM_IMA_EA_EACS = 69656,
        CODEC_ID_ADPCM_EA_XAS = 69657,
        CODEC_ID_ADPCM_EA_MAXIS_XA = 69658,
        CODEC_ID_ADPCM_IMA_ISS = 69659,
        CODEC_ID_ADPCM_G722 = 69660,
        CODEC_ID_ADPCM_IMA_APC = 69661,
        CODEC_ID_VIMA = 1447644481,
        CODEC_ID_AMR_NB = 73728,
        CODEC_ID_AMR_WB = 73729,
        CODEC_ID_RA_144 = 77824,
        CODEC_ID_RA_288 = 77825,
        CODEC_ID_ROQ_DPCM = 81920,
        CODEC_ID_INTERPLAY_DPCM = 81921,
        CODEC_ID_XAN_DPCM = 81922,
        CODEC_ID_SOL_DPCM = 81923,
        CODEC_ID_MP2 = 86016,
        /// <summary>preferred ID for decoding MPEG audio layer 1, 2 or 3</summary>
        CODEC_ID_MP3 = 86017,
        CODEC_ID_AAC = 86018,
        CODEC_ID_AC3 = 86019,
        CODEC_ID_DTS = 86020,
        CODEC_ID_VORBIS = 86021,
        CODEC_ID_DVAUDIO = 86022,
        CODEC_ID_WMAV1 = 86023,
        CODEC_ID_WMAV2 = 86024,
        CODEC_ID_MACE3 = 86025,
        CODEC_ID_MACE6 = 86026,
        CODEC_ID_VMDAUDIO = 86027,
        CODEC_ID_FLAC = 86028,
        CODEC_ID_MP3ADU = 86029,
        CODEC_ID_MP3ON4 = 86030,
        CODEC_ID_SHORTEN = 86031,
        CODEC_ID_ALAC = 86032,
        CODEC_ID_WESTWOOD_SND1 = 86033,
        /// <summary>as in Berlin toast format</summary>
        CODEC_ID_GSM = 86034,
        CODEC_ID_QDM2 = 86035,
        CODEC_ID_COOK = 86036,
        CODEC_ID_TRUESPEECH = 86037,
        CODEC_ID_TTA = 86038,
        CODEC_ID_SMACKAUDIO = 86039,
        CODEC_ID_QCELP = 86040,
        CODEC_ID_WAVPACK = 86041,
        CODEC_ID_DSICINAUDIO = 86042,
        CODEC_ID_IMC = 86043,
        CODEC_ID_MUSEPACK7 = 86044,
        CODEC_ID_MLP = 86045,
        CODEC_ID_GSM_MS = 86046,
        CODEC_ID_ATRAC3 = 86047,
        CODEC_ID_VOXWARE = 86048,
        CODEC_ID_APE = 86049,
        CODEC_ID_NELLYMOSER = 86050,
        CODEC_ID_MUSEPACK8 = 86051,
        CODEC_ID_SPEEX = 86052,
        CODEC_ID_WMAVOICE = 86053,
        CODEC_ID_WMAPRO = 86054,
        CODEC_ID_WMALOSSLESS = 86055,
        CODEC_ID_ATRAC3P = 86056,
        CODEC_ID_EAC3 = 86057,
        CODEC_ID_SIPR = 86058,
        CODEC_ID_MP1 = 86059,
        CODEC_ID_TWINVQ = 86060,
        CODEC_ID_TRUEHD = 86061,
        CODEC_ID_MP4ALS = 86062,
        CODEC_ID_ATRAC1 = 86063,
        CODEC_ID_BINKAUDIO_RDFT = 86064,
        CODEC_ID_BINKAUDIO_DCT = 86065,
        CODEC_ID_AAC_LATM = 86066,
        CODEC_ID_QDMC = 86067,
        CODEC_ID_CELT = 86068,
        CODEC_ID_G723_1 = 86069,
        CODEC_ID_G729 = 86070,
        CODEC_ID_8SVX_EXP = 86071,
        CODEC_ID_8SVX_FIB = 86072,
        CODEC_ID_BMV_AUDIO = 86073,
        CODEC_ID_RALF = 86074,
        CODEC_ID_IAC = 86075,
        CODEC_ID_ILBC = 86076,
        CODEC_ID_FFWAVESYNTH = 1179014995,
        CODEC_ID_SONIC = 1397706307,
        CODEC_ID_SONIC_LS = 1397706316,
        CODEC_ID_PAF_AUDIO = 1346455105,
        CODEC_ID_OPUS = 1330664787,
        /// <summary>A dummy ID pointing at the start of subtitle codecs.</summary>
        CODEC_ID_FIRST_SUBTITLE = 94208,
        CODEC_ID_DVD_SUBTITLE = 94208,
        CODEC_ID_DVB_SUBTITLE = 94209,
        /// <summary>raw UTF-8 text</summary>
        CODEC_ID_TEXT = 94210,
        CODEC_ID_XSUB = 94211,
        CODEC_ID_SSA = 94212,
        CODEC_ID_MOV_TEXT = 94213,
        CODEC_ID_HDMV_PGS_SUBTITLE = 94214,
        CODEC_ID_DVB_TELETEXT = 94215,
        CODEC_ID_SRT = 94216,
        CODEC_ID_MICRODVD = 1833195076,
        CODEC_ID_EIA_608 = 1664495672,
        CODEC_ID_JACOSUB = 1246975298,
        CODEC_ID_SAMI = 1396788553,
        CODEC_ID_REALTEXT = 1381259348,
        CODEC_ID_SUBVIEWER = 1400201814,
        /// <summary>A dummy ID pointing at the start of various fake codecs.</summary>
        CODEC_ID_FIRST_UNKNOWN = 98304,
        CODEC_ID_TTF = 98304,
        CODEC_ID_BINTEXT = 1112823892,
        CODEC_ID_XBIN = 1480739150,
        CODEC_ID_IDF = 4801606,
        CODEC_ID_OTF = 5198918,
        /// <summary>codec_id is not known (like CODEC_ID_NONE) but lavf should attempt to identify it</summary>
        CODEC_ID_PROBE = 102400,
        /// <summary>_FAKE_ codec to indicate a raw MPEG-2 TS stream (only used by libavformat)</summary>
        CODEC_ID_MPEG2TS = 131072,
        /// <summary>_FAKE_ codec to indicate a MPEG-4 Systems stream (only used by libavformat)</summary>
        CODEC_ID_MPEG4SYSTEMS = 131073,
        /// <summary>Dummy codec for streams containing only metadata information.</summary>
        CODEC_ID_FFMETADATA = 135168
    }

    /// <summary>
    /// @}
    /// </summary>
    public enum AVSubtitleType
    {
        SUBTITLE_NONE = 0,
        /// <summary>A bitmap, pict will be set</summary>
        SUBTITLE_BITMAP = 1,
        /// <summary>Plain text, the text field must be set by the decoder and is authoritative. ass and pict fields may contain approximations.</summary>
        SUBTITLE_TEXT = 2,
        /// <summary>Formatted text, the ass field must be set by the decoder and is authoritative. pict and text fields may contain approximations.</summary>
        SUBTITLE_ASS = 3
    }

    /// <summary>
    /// @defgroup lavc_packet AVPacket
    /// 
    /// Types and functions for working with AVPacket.
    /// @{
    /// </summary>
    public enum AVPacketSideDataType
    {
        AV_PKT_DATA_PALETTE = 0,
        AV_PKT_DATA_NEW_EXTRADATA = 1,
        /// <summary>An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:</summary>
        AV_PKT_DATA_PARAM_CHANGE = 2,
        /// <summary>An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of structures with info about macroblocks relevant to splitting the packet into smaller packets on macroblock edges (e.g. as for RFC 2190). That is, it does not necessarily contain info about all macroblocks, as long as the distance between macroblocks in the info is smaller than the target payload size. Each MB info structure is 12 bytes, and is laid out as follows:</summary>
        AV_PKT_DATA_H263_MB_INFO = 3,
        /// <summary>Recommmends skipping the specified number of samples</summary>
        AV_PKT_DATA_SKIP_SAMPLES = 70,
        /// <summary>An AV_PKT_DATA_JP_DUALMONO side data packet indicates that the packet may contain "dual mono" audio specific to Japanese DTV and if it is true, recommends only the selected channel to be used.</summary>
        AV_PKT_DATA_JP_DUALMONO = 71,
        /// <summary>A list of zero terminated key/value strings. There is no end marker for the list, so it is required to rely on the side data size to stop.</summary>
        AV_PKT_DATA_STRINGS_METADATA = 72,
        /// <summary>Subtitle event position</summary>
        AV_PKT_DATA_SUBTITLE_POSITION = 73,
        /// <summary>Data found in BlockAdditional element of matroska container. There is no end marker for the data, so it is required to rely on the side data size to recognize the end. 8 byte id (as found in BlockAddId) followed by data.</summary>
        AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 74,
        /// <summary>The optional first identifier line of a WebVTT cue.</summary>
        AV_PKT_DATA_WEBVTT_IDENTIFIER = 75,
        /// <summary>The optional settings (rendering instructions) that immediately follow the timestamp specifier of a WebVTT cue.</summary>
        AV_PKT_DATA_WEBVTT_SETTINGS = 76
    }

    public enum AVColorPrimaries
    {
        /// <summary>also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B</summary>
        AVCOL_PRI_BT709 = 1,
        AVCOL_PRI_UNSPECIFIED = 2,
        AVCOL_PRI_BT470M = 4,
        /// <summary>also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM</summary>
        AVCOL_PRI_BT470BG = 5,
        /// <summary>also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC</summary>
        AVCOL_PRI_SMPTE170M = 6,
        /// <summary>functionally identical to above</summary>
        AVCOL_PRI_SMPTE240M = 7,
        AVCOL_PRI_FILM = 8,
        /// <summary>Not part of ABI</summary>
        AVCOL_PRI_NB = 9
    }

    public enum AVColorTransferCharacteristic
    {
        /// <summary>also ITU-R BT1361</summary>
        AVCOL_TRC_BT709 = 1,
        AVCOL_TRC_UNSPECIFIED = 2,
        /// <summary>also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM</summary>
        AVCOL_TRC_GAMMA22 = 4,
        /// <summary>also ITU-R BT470BG</summary>
        AVCOL_TRC_GAMMA28 = 5,
        AVCOL_TRC_SMPTE240M = 7,
        /// <summary>Not part of ABI</summary>
        AVCOL_TRC_NB = 8
    }

    /// <summary>
    /// X   X      3 4 X      X are luma samples,
    /// 1 2        1-6 are possible chroma positions
    /// X   X      5 6 X      0 is undefined/unknown position
    /// </summary>
    public enum AVChromaLocation
    {
        AVCHROMA_LOC_UNSPECIFIED = 0,
        /// <summary>mpeg2/4, h264 default</summary>
        AVCHROMA_LOC_LEFT = 1,
        /// <summary>mpeg1, jpeg, h263</summary>
        AVCHROMA_LOC_CENTER = 2,
        /// <summary>DV</summary>
        AVCHROMA_LOC_TOPLEFT = 3,
        AVCHROMA_LOC_TOP = 4,
        AVCHROMA_LOC_BOTTOMLEFT = 5,
        AVCHROMA_LOC_BOTTOM = 6,
        /// <summary>Not part of ABI</summary>
        AVCHROMA_LOC_NB = 7
    }

    public enum AVFieldOrder
    {
        AV_FIELD_UNKNOWN = 0,
        AV_FIELD_PROGRESSIVE = 1,
        AV_FIELD_TT = 2,
        AV_FIELD_BB = 3,
        AV_FIELD_TB = 4,
        AV_FIELD_BT = 5
    }

    public enum AVAudioServiceType
    {
        AV_AUDIO_SERVICE_TYPE_MAIN = 0,
        AV_AUDIO_SERVICE_TYPE_EFFECTS = 1,
        AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
        AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3,
        AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4,
        AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5,
        AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6,
        AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7,
        AV_AUDIO_SERVICE_TYPE_KARAOKE = 8,
        /// <summary>Not part of ABI</summary>
        AV_AUDIO_SERVICE_TYPE_NB = 9
    }

    public enum AVDiscard
    {
        /// <summary>discard nothing</summary>
        AVDISCARD_NONE = -16,
        /// <summary>discard useless packets like 0 size packets in avi</summary>
        AVDISCARD_DEFAULT = 0,
        /// <summary>discard all non reference</summary>
        AVDISCARD_NONREF = 8,
        /// <summary>discard all bidirectional frames</summary>
        AVDISCARD_BIDIR = 16,
        /// <summary>discard all frames except keyframes</summary>
        AVDISCARD_NONKEY = 32,
        /// <summary>discard all</summary>
        AVDISCARD_ALL = 48
    }

    /// <summary>
    /// @ingroup lavc_encoding
    /// motion estimation type.
    /// </summary>
    public enum Motion_Est_ID
    {
        /// <summary>no search, that is use 0,0 vector whenever one is needed</summary>
        ME_ZERO = 1,
        ME_FULL = 2,
        ME_LOG = 3,
        ME_PHODS = 4,
        /// <summary>enhanced predictive zonal search</summary>
        ME_EPZS = 5,
        /// <summary>reserved for experiments</summary>
        ME_X1 = 6,
        /// <summary>hexagon based search</summary>
        ME_HEX = 7,
        /// <summary>uneven multi-hexagon search</summary>
        ME_UMH = 8,
        /// <summary>transformed exhaustive search algorithm</summary>
        ME_TESA = 9,
        /// <summary>iterative search</summary>
        ME_ITER = 50
    }

    [Flags]
    public enum AVSideDataParamChangeFlags
    {
        AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 1,
        AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 2,
        AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 4,
        AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 8
    }

    /// <summary>
    /// @defgroup lavc_parsing Frame parsing
    /// @{
    /// </summary>
    public enum AVPictureStructure
    {
        AV_PICTURE_STRUCTURE_UNKNOWN = 0,
        AV_PICTURE_STRUCTURE_TOP_FIELD = 1,
        AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2,
        AV_PICTURE_STRUCTURE_FRAME = 3
    }

    /// <summary>
    /// Lock operation used by lockmgr
    /// </summary>
    public enum AVLockOp
    {
        /// <summary>Create a mutex</summary>
        AV_LOCK_CREATE = 0,
        /// <summary>Lock the mutex</summary>
        AV_LOCK_OBTAIN = 1,
        /// <summary>Unlock the mutex</summary>
        AV_LOCK_RELEASE = 2,
        /// <summary>Free mutex resources</summary>
        AV_LOCK_DESTROY = 3
    }

    /// <summary>
    /// This struct describes the properties of a single codec described by an
    /// AVCodecID.
    /// @see avcodec_get_descriptor()
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVCodecDescriptor
    {
        [FieldOffset(0)]
        public AVCodecID id;

        [FieldOffset(4)]
        public AVMediaType type;

        /// <summary>
        /// Name of the codec described by this descriptor. It is non-empty and
        /// unique for each codec descriptor. It should contain alphanumeric
        /// characters and '_' only.
        /// </summary>
        [FieldOffset(8)]
        public global::System.IntPtr name;

        /// <summary>
        /// A more descriptive name for this codec. May be NULL.
        /// </summary>
        [FieldOffset(12)]
        public global::System.IntPtr long_name;

        /// <summary>
        /// Codec properties, a combination of AV_CODEC_PROP_* flags.
        /// </summary>
        [FieldOffset(16)]
        public int props;
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct RcOverride
    {
        [FieldOffset(0)]
        public int start_frame;

        [FieldOffset(4)]
        public int end_frame;

        [FieldOffset(8)]
        public int qscale;

        [FieldOffset(12)]
        public float quality_factor;
    }

    /// <summary>
    /// Pan Scan area.
    /// This specifies the area which should be displayed.
    /// Note there may be multiple such areas for one frame.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVPanScan
    {
        /// <summary>
        /// id
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(0)]
        public int id;

        /// <summary>
        /// width and height in 1/16 pel
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(4)]
        public int width;

        [FieldOffset(8)]
        public int height;

        /// <summary>
        /// position of the top left corner in 1/16 pel for up to 3
        /// fields/frames
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(12)]
        public fixed short position_0[2];

        /// <summary>
        /// position of the top left corner in 1/16 pel for up to 3
        /// fields/frames
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(16)]
        public fixed short position_1[2];

        /// <summary>
        /// position of the top left corner in 1/16 pel for up to 3
        /// fields/frames
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(20)]
        public fixed short position_2[2];

        /// <summary>
        /// position of the top left corner in 1/16 pel for up to 3
        /// fields/frames
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(24)]
        public fixed short position_3[2];

        /// <summary>
        /// position of the top left corner in 1/16 pel for up to 3
        /// fields/frames
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(28)]
        public fixed short position_4[2];

        /// <summary>
        /// position of the top left corner in 1/16 pel for up to 3
        /// fields/frames
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(32)]
        public fixed short position_5[2];
    }

    /// <summary>
    /// This structure stores compressed data. It is typically exported by
    /// demuxers
    /// and then passed as input to decoders, or received as output from
    /// encoders and
    /// then passed to muxers.
    /// 
    /// For video, it should typically contain one compressed frame. For audio
    /// it may
    /// contain several compressed frames.
    /// 
    /// AVPacket is one of the few structs in FFmpeg, whose size is a part of
    /// public
    /// ABI. Thus it may be allocated on stack and no new fields can be added
    /// to it
    /// without libavcodec and libavformat major bump.
    /// 
    /// The semantics of data ownership depends on the buf or destruct
    /// (deprecated)
    /// fields. If either is set, the packet data is dynamically allocated and
    /// is
    /// valid indefinitely until av_free_packet() is called (which in turn
    /// calls
    /// av_buffer_unref()/the destruct callback to free the data). If neither
    /// is set,
    /// the packet data is typically backed by some static buffer somewhere and
    /// is
    /// only valid for a limited time (e.g. until the next read call when
    /// demuxing).
    /// 
    /// The side data is always allocated with av_malloc() and is freed in
    /// av_free_packet().
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVPacket
    {
        /// <summary>
        /// A reference to the reference-counted buffer where the packet data
        /// is
        /// stored.
        /// May be NULL, then the packet data is not reference-counted.
        /// </summary>
        [FieldOffset(0)]
        public AVBufferRef* buf;

        /// <summary>
        /// Presentation timestamp in AVStream->time_base units; the time at
        /// which
        /// the decompressed packet will be presented to the user.
        /// Can be AV_NOPTS_VALUE if it is not stored in the file.
        /// pts MUST be larger or equal to dts as presentation cannot happen
        /// before
        /// decompression, unless one wants to view hex dumps. Some formats
        /// misuse
        /// the terms dts and pts/cts to mean something different. Such
        /// timestamps
        /// must be converted to true pts/dts before they are stored in
        /// AVPacket.
        /// </summary>
        [FieldOffset(8)]
        public long pts;

        /// <summary>
        /// Decompression timestamp in AVStream->time_base units; the time at
        /// which
        /// the packet is decompressed.
        /// Can be AV_NOPTS_VALUE if it is not stored in the file.
        /// </summary>
        [FieldOffset(16)]
        public long dts;

        [FieldOffset(24)]
        public byte* data;

        [FieldOffset(28)]
        public int size;

        [FieldOffset(32)]
        public int stream_index;

        /// <summary>
        /// A combination of AV_PKT_FLAG values
        /// </summary>
        [FieldOffset(36)]
        public int flags;

        [FieldOffset(40)]
        public AVPacket.* side_data;

        [FieldOffset(44)]
        public int side_data_elems;

        /// <summary>
        /// Duration of this packet in AVStream->time_base units, 0 if unknown.
        /// Equals next_pts - this_pts in presentation order.
        /// </summary>
        [FieldOffset(48)]
        public int duration;

        [FieldOffset(52)]
        public global::System.IntPtr destruct;

        [FieldOffset(56)]
        public global::System.IntPtr priv;

        /// <summary>
        /// < byte position in stream, -1 if unknown
        /// </summary>
        [FieldOffset(64)]
        public long pos;

        /// <summary>
        /// Time difference in AVStream->time_base units from the pts of this
        /// packet to the point at which the output from the decoder has
        /// converged
        /// independent from the availability of previous frames. That is, the
        /// frames are virtually identical no matter if decoding started from
        /// the very first frame or from this keyframe.
        /// Is AV_NOPTS_VALUE if unknown.
        /// This field is not the display duration of the current packet.
        /// This field has no meaning if the packet does not have
        /// AV_PKT_FLAG_KEY
        /// set.
        /// 
        /// The purpose of this field is to allow seeking in streams that have
        /// no
        /// keyframes in the conventional sense. It corresponds to the
        /// recovery point SEI in H.264 and match_time_delta in NUT. It is also
        /// essential for some types of subtitle streams to ensure that all
        /// subtitles are correctly displayed after seeking.
        /// </summary>
        [FieldOffset(72)]
        public long convergence_duration;
    }

    /// <summary>
    /// @}
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVCodecInternal
    {
    }

    /// <summary>
    /// main external API structure.
    /// New fields can be added to the end with minor version bumps.
    /// Removal, reordering and changes to existing fields require a major
    /// version bump.
    /// Please use AVOptions (av_opt* / av_set/get*()) to access these fields
    /// from user
    /// applications.
    /// sizeof(AVCodecContext) must not be used outside libav*.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVCodecContext
    {
        /// <summary>
        /// information on struct for av_log
        /// - set by avcodec_alloc_context3
        /// </summary>
        [FieldOffset(0)]
        public AVClass* av_class;

        [FieldOffset(4)]
        public int log_level_offset;

        [FieldOffset(8)]
        public AVMediaType codec_type;

        [FieldOffset(12)]
        public AVCodec* codec;

        [FieldOffset(16)]
        public fixed sbyte codec_name[32];

        [FieldOffset(48)]
        public AVCodecID codec_id;

        /// <summary>
        /// fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) +
        /// 'A').
        /// This is used to work around some encoder bugs.
        /// A demuxer should set this to what is stored in the field used to
        /// identify the codec.
        /// If there are multiple such fields in a container then the demuxer
        /// should choose the one
        /// which maximizes the information about the used codec.
        /// If the codec tag field in a container is larger than 32 bits then
        /// the demuxer should
        /// remap the longer ID to 32 bits with a table or other structure.
        /// Alternatively a new
        /// extra_codec_tag + size could be added but for this a clear
        /// advantage must be demonstrated
        /// first.
        /// - encoding: Set by user, if not then the default based on codec_id
        /// will be used.
        /// - decoding: Set by user, will be converted to uppercase by
        /// libavcodec during init.
        /// </summary>
        [FieldOffset(52)]
        public uint codec_tag;

        /// <summary>
        /// fourcc from the AVI stream header (LSB first, so "ABCD" ->
        /// ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
        /// This is used to work around some encoder bugs.
        /// - encoding: unused
        /// - decoding: Set by user, will be converted to uppercase by
        /// libavcodec during init.
        /// </summary>
        [FieldOffset(56)]
        public uint stream_codec_tag;

        [FieldOffset(60)]
        public global::System.IntPtr priv_data;

        /// <summary>
        /// Private context used for internal data.
        /// 
        /// Unlike priv_data, this is not codec-specific. It is used in general
        /// libavcodec functions.
        /// </summary>
        [FieldOffset(64)]
        public AVCodecInternal* @internal;

        /// <summary>
        /// Private data of the user, can be used to carry app specific stuff.
        /// - encoding: Set by user.
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(68)]
        public global::System.IntPtr opaque;

        /// <summary>
        /// the average bitrate
        /// - encoding: Set by user; unused for constant quantizer encoding.
        /// - decoding: Set by libavcodec. 0 or some bitrate if this info is
        /// available in the stream.
        /// </summary>
        [FieldOffset(72)]
        public int bit_rate;

        /// <summary>
        /// number of bits the bitstream is allowed to diverge from the
        /// reference.
        /// the reference can be CBR (for CBR pass1) or VBR (for pass2)
        /// - encoding: Set by user; unused for constant quantizer encoding.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(76)]
        public int bit_rate_tolerance;

        /// <summary>
        /// Global quality for codecs which cannot change it per frame.
        /// This should be proportional to MPEG-1/2/4 qscale.
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(80)]
        public int global_quality;

        /// <summary>
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(84)]
        public int compression_level;

        /// <summary>
        /// CODEC_FLAG_*.
        /// - encoding: Set by user.
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(88)]
        public int flags;

        /// <summary>
        /// CODEC_FLAG2_*
        /// - encoding: Set by user.
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(92)]
        public int flags2;

        /// <summary>
        /// some codecs need / can use extradata like Huffman tables.
        /// mjpeg: Huffman tables
        /// rv10: additional flags
        /// mpeg4: global headers (they can be in the bitstream or here)
        /// The allocated memory should be FF_INPUT_BUFFER_PADDING_SIZE bytes
        /// larger
        /// than extradata_size to avoid problems if it is read with the
        /// bitstream reader.
        /// The bytewise contents of extradata must not depend on the
        /// architecture or CPU endianness.
        /// - encoding: Set/allocated/freed by libavcodec.
        /// - decoding: Set/allocated/freed by user.
        /// </summary>
        [FieldOffset(96)]
        public byte* extradata;

        [FieldOffset(100)]
        public int extradata_size;

        /// <summary>
        /// This is the fundamental unit of time (in seconds) in terms
        /// of which frame timestamps are represented. For fixed-fps content,
        /// timebase should be 1/framerate and timestamp increments should be
        /// identically 1.
        /// - encoding: MUST be set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(104)]
        public AVRational* time_base;

        /// <summary>
        /// For some codecs, the time base is closer to the field rate than the
        /// frame rate.
        /// Most notably, H.264 and MPEG-2 specify time_base as half of frame
        /// duration
        /// if no telecine is used ...
        /// 
        /// Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set
        /// it to 2.
        /// </summary>
        [FieldOffset(112)]
        public int ticks_per_frame;

        /// <summary>
        /// Codec delay.
        /// 
        /// Encoding: Number of frames delay there will be from the encoder
        /// input to
        /// the decoder output. (we assume the decoder matches the spec)
        /// Decoding: Number of frames delay in addition to what a standard
        /// decoder
        /// as specified in the spec would produce.
        /// 
        /// Video:
        /// Number of frames the decoded output will be delayed relative to the
        /// encoded input.
        /// 
        /// Audio:
        /// For encoding, this is the number of "priming" samples added to the
        /// beginning of the stream. The decoded output will be delayed by this
        /// many samples relative to the input to the encoder. Note that this
        /// field is purely informational and does not directly affect the pts
        /// output by the encoder, which should always be based on the actual
        /// presentation time, including any delay.
        /// For decoding, this is the number of samples the decoder needs to
        /// output before the decoder's output is valid. When seeking, you
        /// should
        /// start decoding this many samples prior to your desired seek point.
        /// 
        /// - encoding: Set by libavcodec.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(116)]
        public int delay;

        /// <summary>
        /// picture width / height.
        /// - encoding: MUST be set by user.
        /// - decoding: May be set by the user before opening the decoder if
        /// known e.g.
        /// from the container. Some decoders will require the dimensions
        /// to be set by the caller. During decoding, the decoder may
        /// overwrite those values as required.
        /// </summary>
        [FieldOffset(120)]
        public int width;

        /// <summary>
        /// picture width / height.
        /// - encoding: MUST be set by user.
        /// - decoding: May be set by the user before opening the decoder if
        /// known e.g.
        /// from the container. Some decoders will require the dimensions
        /// to be set by the caller. During decoding, the decoder may
        /// overwrite those values as required.
        /// </summary>
        [FieldOffset(124)]
        public int height;

        /// <summary>
        /// Bitstream width / height, may be different from width/height e.g.
        /// when
        /// the decoded frame is cropped before being output or lowres is
        /// enabled.
        /// - encoding: unused
        /// - decoding: May be set by the user before opening the decoder if
        /// known
        /// e.g. from the container. During decoding, the decoder may
        /// overwrite those values as required.
        /// </summary>
        [FieldOffset(128)]
        public int coded_width;

        /// <summary>
        /// Bitstream width / height, may be different from width/height e.g.
        /// when
        /// the decoded frame is cropped before being output or lowres is
        /// enabled.
        /// - encoding: unused
        /// - decoding: May be set by the user before opening the decoder if
        /// known
        /// e.g. from the container. During decoding, the decoder may
        /// overwrite those values as required.
        /// </summary>
        [FieldOffset(132)]
        public int coded_height;

        /// <summary>
        /// the number of pictures in a group of pictures, or 0 for intra_only
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(136)]
        public int gop_size;

        /// <summary>
        /// Pixel format, see AV_PIX_FMT_xxx.
        /// May be set by the demuxer if known from headers.
        /// May be overridden by the decoder if it knows better.
        /// - encoding: Set by user.
        /// - decoding: Set by user if known, overridden by libavcodec if known
        /// </summary>
        [FieldOffset(140)]
        public AVPixelFormat pix_fmt;

        /// <summary>
        /// Motion estimation algorithm used for video coding.
        /// 1 (zero), 2 (full), 3 (log), 4 (phods), 5 (epzs), 6 (x1), 7 (hex),
        /// 8 (umh), 9 (iter), 10 (tesa) [7, 8, 10 are x264 specific, 9 is snow
        /// specific]
        /// - encoding: MUST be set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(144)]
        public int me_method;

        /// <summary>
        /// If non NULL, 'draw_horiz_band' is called by the libavcodec
        /// decoder to draw a horizontal band. It improves cache usage. Not
        /// all codecs can do that. You must check the codec capabilities
        /// beforehand.
        /// When multithreading is used, it may be called from multiple threads
        /// at the same time; threads might draw different parts of the same
        /// AVFrame,
        /// or multiple AVFrames, and there is no guarantee that slices will be
        /// drawn
        /// in order.
        /// The function is also used by hardware acceleration APIs.
        /// It is called at least once during frame decoding to pass
        /// the data needed for hardware render.
        /// In that mode instead of pixel data, AVFrame points to
        /// a structure specific to the acceleration API. The application
        /// reads the structure and can change some fields to indicate progress
        /// or mark state.
        /// - encoding: unused
        /// - decoding: Set by user.
        /// @param height the height of the slice
        /// @param y the y position of the slice
        /// @param type 1->top field, 2->bottom field, 3->frame
        /// @param offset offset into the AVFrame.data from which the slice
        /// should be read
        /// </summary>
        [FieldOffset(148)]
        public global::System.IntPtr draw_horiz_band;

        /// <summary>
        /// callback to negotiate the pixelFormat
        /// @param fmt is the list of formats which are supported by the codec,
        /// it is terminated by -1 as 0 is a valid format, the formats are
        /// ordered by quality.
        /// The first is always the native one.
        /// @return the chosen format
        /// - encoding: unused
        /// - decoding: Set by user, if not set the native format will be
        /// chosen.
        /// </summary>
        [FieldOffset(152)]
        public global::System.IntPtr get_format;

        /// <summary>
        /// maximum number of B-frames between non-B-frames
        /// Note: The output will be delayed by max_b_frames+1 relative to the
        /// input.
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(156)]
        public int max_b_frames;

        /// <summary>
        /// qscale factor between IP and B-frames
        /// If > 0 then the last P-frame quantizer will be used (q=
        /// lastp_q*factor+offset).
        /// If < 0 then normal ratecontrol will be done (q=
        /// -normal_q*factor+offset).
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(160)]
        public float b_quant_factor;

        /// <summary>
        /// </summary>
        [FieldOffset(164)]
        public int rc_strategy;

        [FieldOffset(168)]
        public int b_frame_strategy;

        /// <summary>
        /// qscale offset between IP and B-frames
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(172)]
        public float b_quant_offset;

        /// <summary>
        /// Size of the frame reordering buffer in the decoder.
        /// For MPEG-2 it is 1 IPB or 0 low delay IP.
        /// - encoding: Set by libavcodec.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(176)]
        public int has_b_frames;

        /// <summary>
        /// 0-> h263 quant 1-> mpeg quant
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(180)]
        public int mpeg_quant;

        /// <summary>
        /// qscale factor between P and I-frames
        /// If > 0 then the last p frame quantizer will be used (q=
        /// lastp_q*factor+offset).
        /// If < 0 then normal ratecontrol will be done (q=
        /// -normal_q*factor+offset).
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(184)]
        public float i_quant_factor;

        /// <summary>
        /// qscale offset between P and I-frames
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(188)]
        public float i_quant_offset;

        /// <summary>
        /// luminance masking (0-> disabled)
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(192)]
        public float lumi_masking;

        /// <summary>
        /// temporary complexity masking (0-> disabled)
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(196)]
        public float temporal_cplx_masking;

        /// <summary>
        /// spatial complexity masking (0-> disabled)
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(200)]
        public float spatial_cplx_masking;

        /// <summary>
        /// p block masking (0-> disabled)
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(204)]
        public float p_masking;

        /// <summary>
        /// darkness masking (0-> disabled)
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(208)]
        public float dark_masking;

        /// <summary>
        /// slice count
        /// - encoding: Set by libavcodec.
        /// - decoding: Set by user (or 0).
        /// </summary>
        [FieldOffset(212)]
        public int slice_count;

        /// <summary>
        /// prediction method (needed for huffyuv)
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(216)]
        public int prediction_method;

        /// <summary>
        /// slice offsets in the frame in bytes
        /// - encoding: Set/allocated by libavcodec.
        /// - decoding: Set/allocated by user (or NULL).
        /// </summary>
        [FieldOffset(220)]
        public int* slice_offset;

        /// <summary>
        /// sample aspect ratio (0 if unknown)
        /// That is the width of a pixel divided by the height of the pixel.
        /// Numerator and denominator must be relatively prime and smaller than
        /// 256 for some video standards.
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(224)]
        public AVRational* sample_aspect_ratio;

        /// <summary>
        /// motion estimation comparison function
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(232)]
        public int me_cmp;

        /// <summary>
        /// subpixel motion estimation comparison function
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(236)]
        public int me_sub_cmp;

        /// <summary>
        /// macroblock comparison function (not supported yet)
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(240)]
        public int mb_cmp;

        /// <summary>
        /// interlaced DCT comparison function
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(244)]
        public int ildct_cmp;

        /// <summary>
        /// ME diamond size & shape
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(248)]
        public int dia_size;

        /// <summary>
        /// amount of previous MV predictors (2a+1 x 2a+1 square)
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(252)]
        public int last_predictor_count;

        /// <summary>
        /// prepass for motion estimation
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(256)]
        public int pre_me;

        /// <summary>
        /// motion estimation prepass comparison function
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(260)]
        public int me_pre_cmp;

        /// <summary>
        /// ME prepass diamond size & shape
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(264)]
        public int pre_dia_size;

        /// <summary>
        /// subpel ME quality
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(268)]
        public int me_subpel_quality;

        /// <summary>
        /// DTG active format information (additional aspect ratio
        /// information only used in DVB MPEG-2 transport streams)
        /// 0 if not set.
        /// 
        /// - encoding: unused
        /// - decoding: Set by decoder.
        /// </summary>
        [FieldOffset(272)]
        public int dtg_active_format;

        /// <summary>
        /// maximum motion estimation search range in subpel units
        /// If 0 then no limit.
        /// 
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(276)]
        public int me_range;

        /// <summary>
        /// intra quantizer bias
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(280)]
        public int intra_quant_bias;

        /// <summary>
        /// inter quantizer bias
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(284)]
        public int inter_quant_bias;

        /// <summary>
        /// slice flags
        /// - encoding: unused
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(288)]
        public int slice_flags;

        /// <summary>
        /// XVideo Motion Acceleration
        /// - encoding: forbidden
        /// - decoding: set by decoder
        /// </summary>
        [FieldOffset(292)]
        public int xvmc_acceleration;

        /// <summary>
        /// macroblock decision mode
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(296)]
        public int mb_decision;

        /// <summary>
        /// custom intra quantization matrix
        /// - encoding: Set by user, can be NULL.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(300)]
        public ushort* intra_matrix;

        /// <summary>
        /// custom inter quantization matrix
        /// - encoding: Set by user, can be NULL.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(304)]
        public ushort* inter_matrix;

        /// <summary>
        /// scene change detection threshold
        /// 0 is default, larger means fewer detected scene changes.
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(308)]
        public int scenechange_threshold;

        /// <summary>
        /// noise reduction strength
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(312)]
        public int noise_reduction;

        /// <summary>
        /// Motion estimation threshold below which no motion estimation is
        /// performed, but instead the user specified motion vectors are used.
        /// 
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(316)]
        public int me_threshold;

        /// <summary>
        /// Macroblock threshold below which the user specified macroblock
        /// types will be used.
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(320)]
        public int mb_threshold;

        /// <summary>
        /// precision of the intra DC coefficient - 8
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(324)]
        public int intra_dc_precision;

        /// <summary>
        /// Number of macroblock rows at the top which are skipped.
        /// - encoding: unused
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(328)]
        public int skip_top;

        /// <summary>
        /// Number of macroblock rows at the bottom which are skipped.
        /// - encoding: unused
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(332)]
        public int skip_bottom;

        /// <summary>
        /// Border processing masking, raises the quantizer for mbs on the
        /// borders
        /// of the picture.
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(336)]
        public float border_masking;

        /// <summary>
        /// minimum MB lagrange multipler
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(340)]
        public int mb_lmin;

        /// <summary>
        /// maximum MB lagrange multipler
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(344)]
        public int mb_lmax;

        /// <summary>
        /// 
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(348)]
        public int me_penalty_compensation;

        /// <summary>
        /// 
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(352)]
        public int bidir_refine;

        /// <summary>
        /// 
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(356)]
        public int brd_scale;

        /// <summary>
        /// minimum GOP size
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(360)]
        public int keyint_min;

        /// <summary>
        /// number of reference frames
        /// - encoding: Set by user.
        /// - decoding: Set by lavc.
        /// </summary>
        [FieldOffset(364)]
        public int refs;

        /// <summary>
        /// chroma qp offset from luma
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(368)]
        public int chromaoffset;

        /// <summary>
        /// Multiplied by qscale for each frame and added to
        /// scene_change_score.
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(372)]
        public int scenechange_factor;

        /// <summary>
        /// 
        /// Note: Value depends upon the compare function used for fullpel ME.
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(376)]
        public int mv0_threshold;

        /// <summary>
        /// Adjust sensitivity of b_frame_strategy 1.
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(380)]
        public int b_sensitivity;

        /// <summary>
        /// Chromaticity coordinates of the source primaries.
        /// - encoding: Set by user
        /// - decoding: Set by libavcodec
        /// </summary>
        [FieldOffset(384)]
        public AVColorPrimaries color_primaries;

        /// <summary>
        /// Color Transfer Characteristic.
        /// - encoding: Set by user
        /// - decoding: Set by libavcodec
        /// </summary>
        [FieldOffset(388)]
        public AVColorTransferCharacteristic color_trc;

        /// <summary>
        /// YUV colorspace type.
        /// - encoding: Set by user
        /// - decoding: Set by libavcodec
        /// </summary>
        [FieldOffset(392)]
        public AVColorSpace colorspace;

        /// <summary>
        /// MPEG vs JPEG YUV range.
        /// - encoding: Set by user
        /// - decoding: Set by libavcodec
        /// </summary>
        [FieldOffset(396)]
        public AVColorRange color_range;

        /// <summary>
        /// This defines the location of chroma samples.
        /// - encoding: Set by user
        /// - decoding: Set by libavcodec
        /// </summary>
        [FieldOffset(400)]
        public AVChromaLocation chroma_sample_location;

        /// <summary>
        /// Number of slices.
        /// Indicates number of picture subdivisions. Used for parallelized
        /// decoding.
        /// - encoding: Set by user
        /// - decoding: unused
        /// </summary>
        [FieldOffset(404)]
        public int slices;

        /// <summary>
        /// - encoding: set by libavcodec
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(408)]
        public AVFieldOrder field_order;

        /// <summary>
        /// < samples per second
        /// </summary>
        [FieldOffset(412)]
        public int sample_rate;

        /// <summary>
        /// < number of audio channels
        /// </summary>
        [FieldOffset(416)]
        public int channels;

        /// <summary>
        /// < sample format
        /// </summary>
        [FieldOffset(420)]
        public AVSampleFormat sample_fmt;

        /// <summary>
        /// Number of samples per channel in an audio frame.
        /// 
        /// - encoding: set by libavcodec in avcodec_open2(). Each submitted
        /// frame
        /// except the last must contain exactly frame_size samples per
        /// channel.
        /// May be 0 when the codec has CODEC_CAP_VARIABLE_FRAME_SIZE set, then
        /// the
        /// frame size is not restricted.
        /// - decoding: may be set by some decoders to indicate constant frame
        /// size
        /// </summary>
        [FieldOffset(424)]
        public int frame_size;

        /// <summary>
        /// Frame counter, set by libavcodec.
        /// 
        /// - decoding: total number of frames returned from the decoder so
        /// far.
        /// - encoding: total number of frames passed to the encoder so far.
        /// 
        /// @note the counter is not incremented if encoding/decoding resulted
        /// in
        /// an error.
        /// </summary>
        [FieldOffset(428)]
        public int frame_number;

        /// <summary>
        /// number of bytes per packet if constant and known or 0
        /// Used by some WAV based audio codecs.
        /// </summary>
        [FieldOffset(432)]
        public int block_align;

        /// <summary>
        /// Audio cutoff bandwidth (0 means "automatic")
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(436)]
        public int cutoff;

        /// <summary>
        /// Decoder should decode to this many channels if it can (0 for
        /// default)
        /// - encoding: unused
        /// - decoding: Set by user.
        /// @deprecated Deprecated in favor of request_channel_layout.
        /// </summary>
        [FieldOffset(440)]
        public int request_channels;

        /// <summary>
        /// Audio channel layout.
        /// - encoding: set by user.
        /// - decoding: set by user, may be overwritten by libavcodec.
        /// </summary>
        [FieldOffset(448)]
        public ulong channel_layout;

        /// <summary>
        /// Request decoder to use this channel layout if it can (0 for
        /// default)
        /// - encoding: unused
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(456)]
        public ulong request_channel_layout;

        /// <summary>
        /// Type of service that the audio stream conveys.
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(464)]
        public AVAudioServiceType audio_service_type;

        /// <summary>
        /// desired sample format
        /// - encoding: Not used.
        /// - decoding: Set by user.
        /// Decoder will decode to this format if it can.
        /// </summary>
        [FieldOffset(468)]
        public AVSampleFormat request_sample_fmt;

        /// <summary>
        /// Called at the beginning of each frame to get a buffer for it.
        /// 
        /// The function will set AVFrame.data[], AVFrame.linesize[].
        /// AVFrame.extended_data[] must also be set, but it should be the same
        /// as
        /// AVFrame.data[] except for planar audio with more channels than can
        /// fit
        /// in AVFrame.data[]. In that case, AVFrame.data[] shall still contain
        /// as
        /// many data pointers as it can hold.
        /// 
        /// if CODEC_CAP_DR1 is not set then get_buffer() must call
        /// avcodec_default_get_buffer() instead of providing buffers allocated
        /// by
        /// some other means.
        /// 
        /// AVFrame.data[] should be 32- or 16-byte-aligned unless the CPU
        /// doesn't
        /// need it. avcodec_default_get_buffer() aligns the output buffer
        /// properly,
        /// but if get_buffer() is overridden then alignment considerations
        /// should
        /// be taken into account.
        /// 
        /// @see avcodec_default_get_buffer()
        /// 
        /// Video:
        /// 
        /// If pic.reference is set then the frame will be read later by
        /// libavcodec.
        /// avcodec_align_dimensions2() should be used to find the required
        /// width and
        /// height, as they normally need to be rounded up to the next multiple
        /// of 16.
        /// 
        /// If frame multithreading is used and thread_safe_callbacks is set,
        /// it may be called from a different thread, but not from more than
        /// one at
        /// once. Does not need to be reentrant.
        /// 
        /// @see release_buffer(), reget_buffer()
        /// @see avcodec_align_dimensions2()
        /// 
        /// Audio:
        /// 
        /// Decoders request a buffer of a particular size by setting
        /// AVFrame.nb_samples prior to calling get_buffer(). The decoder may,
        /// however, utilize only part of the buffer by setting
        /// AVFrame.nb_samples
        /// to a smaller value in the output frame.
        /// 
        /// Decoders cannot use the buffer after returning from
        /// avcodec_decode_audio4(), so they will not call release_buffer(), as
        /// it
        /// is assumed to be released immediately upon return. In some rare
        /// cases,
        /// a decoder may need to call get_buffer() more than once in a single
        /// call to avcodec_decode_audio4(). In that case, when get_buffer() is
        /// called again after it has already been called once, the previously
        /// acquired buffer is assumed to be released at that time and may not
        /// be
        /// reused by the decoder.
        /// 
        /// As a convenience, av_samples_get_buffer_size() and
        /// av_samples_fill_arrays() in libavutil may be used by custom
        /// get_buffer()
        /// functions to find the required data size and to fill data pointers
        /// and
        /// linesize. In AVFrame.linesize, only linesize[0] may be set for
        /// audio
        /// since all planes must be the same size.
        /// 
        /// @see av_samples_get_buffer_size(), av_samples_fill_arrays()
        /// 
        /// - encoding: unused
        /// - decoding: Set by libavcodec, user can override.
        /// 
        /// @deprecated use get_buffer2()
        /// </summary>
        [FieldOffset(472)]
        public global::System.IntPtr get_buffer;

        /// <summary>
        /// Called to release buffers which were allocated with get_buffer.
        /// A released buffer can be reused in get_buffer().
        /// pic.data[*] must be set to NULL.
        /// May be called from a different thread if frame multithreading is
        /// used,
        /// but not by more than one thread at once, so does not need to be
        /// reentrant.
        /// - encoding: unused
        /// - decoding: Set by libavcodec, user can override.
        /// 
        /// @deprecated custom freeing callbacks should be set from
        /// get_buffer2()
        /// </summary>
        [FieldOffset(476)]
        public global::System.IntPtr release_buffer;

        /// <summary>
        /// Called at the beginning of a frame to get cr buffer for it.
        /// Buffer type (size, hints) must be the same. libavcodec won't check
        /// it.
        /// libavcodec will pass previous buffer in pic, function should return
        /// same buffer or new buffer with old frame "painted" into it.
        /// If pic.data[0] == NULL must behave like get_buffer().
        /// if CODEC_CAP_DR1 is not set then reget_buffer() must call
        /// avcodec_default_reget_buffer() instead of providing buffers
        /// allocated by
        /// some other means.
        /// - encoding: unused
        /// - decoding: Set by libavcodec, user can override.
        /// </summary>
        [FieldOffset(480)]
        public global::System.IntPtr reget_buffer;

        /// <summary>
        /// This callback is called at the beginning of each frame to get data
        /// buffer(s) for it. There may be one contiguous buffer for all the
        /// data or
        /// there may be a buffer per each data plane or anything in between.
        /// What
        /// this means is, you may set however many entries in buf[] you feel
        /// necessary.
        /// Each buffer must be reference-counted using the AVBuffer API (see
        /// description
        /// of buf[] below).
        /// 
        /// The following fields will be set in the frame before this callback
        /// is
        /// called:
        /// - format
        /// - width, height (video only)
        /// - sample_rate, channel_layout, nb_samples (audio only)
        /// Their values may differ from the corresponding values in
        /// AVCodecContext. This callback must use the frame values, not the
        /// codec
        /// context values, to calculate the required buffer size.
        /// 
        /// This callback must fill the following fields in the frame:
        /// - data[]
        /// - linesize[]
        /// - extended_data:
        /// if the data is planar audio with more than 8 channels, then this
        /// callback must allocate and fill extended_data to contain all
        /// pointers
        /// to all data planes. data[] must hold as many pointers as it can.
        /// extended_data must be allocated with av_malloc() and will be freed
        /// in
        /// av_frame_unref().
        /// otherwise exended_data must point to data
        /// - buf[] must contain one or more pointers to AVBufferRef
        /// structures. Each of
        /// the frame's data and extended_data pointers must be contained in
        /// these. That
        /// is, one AVBufferRef for each allocated chunk of memory, not
        /// necessarily one
        /// AVBufferRef per data[] entry. See: av_buffer_create(),
        /// av_buffer_alloc(),
        /// and av_buffer_ref().
        /// - extended_buf and nb_extended_buf must be allocated with
        /// av_malloc() by
        /// this callback and filled with the extra buffers if there are more
        /// buffers than buf[] can hold. extended_buf will be freed in
        /// av_frame_unref().
        /// 
        /// If CODEC_CAP_DR1 is not set then get_buffer2() must call
        /// avcodec_default_get_buffer2() instead of providing buffers
        /// allocated by
        /// some other means.
        /// 
        /// Each data plane must be aligned to the maximum required by the
        /// target
        /// CPU.
        /// 
        /// @see avcodec_default_get_buffer2()
        /// 
        /// Video:
        /// 
        /// If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be
        /// reused
        /// (read and/or written to if it is writable) later by libavcodec.
        /// 
        /// If CODEC_FLAG_EMU_EDGE is not set in s->flags, the buffer must
        /// contain an
        /// edge of the size returned by avcodec_get_edge_width() on all sides.
        /// 
        /// avcodec_align_dimensions2() should be used to find the required
        /// width and
        /// height, as they normally need to be rounded up to the next multiple
        /// of 16.
        /// 
        /// If frame multithreading is used and thread_safe_callbacks is set,
        /// this callback may be called from a different thread, but not from
        /// more
        /// than one at once. Does not need to be reentrant.
        /// 
        /// @see avcodec_align_dimensions2()
        /// 
        /// Audio:
        /// 
        /// Decoders request a buffer of a particular size by setting
        /// AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
        /// however, utilize only part of the buffer by setting
        /// AVFrame.nb_samples
        /// to a smaller value in the output frame.
        /// 
        /// As a convenience, av_samples_get_buffer_size() and
        /// av_samples_fill_arrays() in libavutil may be used by custom
        /// get_buffer2()
        /// functions to find the required data size and to fill data pointers
        /// and
        /// linesize. In AVFrame.linesize, only linesize[0] may be set for
        /// audio
        /// since all planes must be the same size.
        /// 
        /// @see av_samples_get_buffer_size(), av_samples_fill_arrays()
        /// 
        /// - encoding: unused
        /// - decoding: Set by libavcodec, user can override.
        /// </summary>
        [FieldOffset(484)]
        public global::System.IntPtr get_buffer2;

        /// <summary>
        /// If non-zero, the decoded audio and video frames returned from
        /// avcodec_decode_video2() and avcodec_decode_audio4() are
        /// reference-counted
        /// and are valid indefinitely. The caller must free them with
        /// av_frame_unref() when they are not needed anymore.
        /// Otherwise, the decoded frames must not be freed by the caller and
        /// are
        /// only valid until the next decode call.
        /// 
        /// - encoding: unused
        /// - decoding: set by the caller before avcodec_open2().
        /// </summary>
        [FieldOffset(488)]
        public int refcounted_frames;

        /// <summary>
        /// < amount of qscale change between easy & hard scenes (0.0-1.0)
        /// </summary>
        [FieldOffset(492)]
        public float qcompress;

        /// <summary>
        /// < amount of qscale smoothing over time (0.0-1.0)
        /// </summary>
        [FieldOffset(496)]
        public float qblur;

        /// <summary>
        /// minimum quantizer
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(500)]
        public int qmin;

        /// <summary>
        /// maximum quantizer
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(504)]
        public int qmax;

        /// <summary>
        /// maximum quantizer difference between frames
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(508)]
        public int max_qdiff;

        /// <summary>
        /// ratecontrol qmin qmax limiting method
        /// 0-> clipping, 1-> use a nice continuous function to limit qscale
        /// wthin qmin/qmax.
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(512)]
        public float rc_qsquish;

        [FieldOffset(516)]
        public float rc_qmod_amp;

        [FieldOffset(520)]
        public int rc_qmod_freq;

        /// <summary>
        /// decoder bitstream buffer size
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(524)]
        public int rc_buffer_size;

        /// <summary>
        /// ratecontrol override, see RcOverride
        /// - encoding: Allocated/set/freed by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(528)]
        public int rc_override_count;

        [FieldOffset(532)]
        public RcOverride* rc_override;

        /// <summary>
        /// rate control equation
        /// - encoding: Set by user
        /// - decoding: unused
        /// </summary>
        [FieldOffset(536)]
        public global::System.IntPtr rc_eq;

        /// <summary>
        /// maximum bitrate
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(540)]
        public int rc_max_rate;

        /// <summary>
        /// minimum bitrate
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(544)]
        public int rc_min_rate;

        [FieldOffset(548)]
        public float rc_buffer_aggressivity;

        /// <summary>
        /// initial complexity for pass1 ratecontrol
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(552)]
        public float rc_initial_cplx;

        /// <summary>
        /// Ratecontrol attempt to use, at maximum, <value> of what can be used
        /// without an underflow.
        /// - encoding: Set by user.
        /// - decoding: unused.
        /// </summary>
        [FieldOffset(556)]
        public float rc_max_available_vbv_use;

        /// <summary>
        /// Ratecontrol attempt to use, at least, <value> times the amount
        /// needed to prevent a vbv overflow.
        /// - encoding: Set by user.
        /// - decoding: unused.
        /// </summary>
        [FieldOffset(560)]
        public float rc_min_vbv_overflow_use;

        /// <summary>
        /// Number of bits which should be loaded into the rc buffer before
        /// decoding starts.
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(564)]
        public int rc_initial_buffer_occupancy;

        /// <summary>
        /// coder type
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(568)]
        public int coder_type;

        /// <summary>
        /// context model
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(572)]
        public int context_model;

        /// <summary>
        /// minimum Lagrange multipler
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(576)]
        public int lmin;

        /// <summary>
        /// maximum Lagrange multipler
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(580)]
        public int lmax;

        /// <summary>
        /// frame skip threshold
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(584)]
        public int frame_skip_threshold;

        /// <summary>
        /// frame skip factor
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(588)]
        public int frame_skip_factor;

        /// <summary>
        /// frame skip exponent
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(592)]
        public int frame_skip_exp;

        /// <summary>
        /// frame skip comparison function
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(596)]
        public int frame_skip_cmp;

        /// <summary>
        /// trellis RD quantization
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(600)]
        public int trellis;

        /// <summary>
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(604)]
        public int min_prediction_order;

        /// <summary>
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(608)]
        public int max_prediction_order;

        /// <summary>
        /// GOP timecode frame start number
        /// - encoding: Set by user, in non drop frame format
        /// - decoding: Set by libavcodec (timecode in the 25 bits format, -1
        /// if unset)
        /// </summary>
        [FieldOffset(616)]
        public long timecode_frame_start;

        [FieldOffset(624)]
        public global::System.IntPtr rtp_callback;

        [FieldOffset(628)]
        public int rtp_payload_size;

        [FieldOffset(632)]
        public int mv_bits;

        [FieldOffset(636)]
        public int header_bits;

        [FieldOffset(640)]
        public int i_tex_bits;

        [FieldOffset(644)]
        public int p_tex_bits;

        [FieldOffset(648)]
        public int i_count;

        [FieldOffset(652)]
        public int p_count;

        [FieldOffset(656)]
        public int skip_count;

        [FieldOffset(660)]
        public int misc_bits;

        /// <summary>
        /// number of bits used for the previously encoded frame
        /// - encoding: Set by libavcodec.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(664)]
        public int frame_bits;

        /// <summary>
        /// pass1 encoding statistics output buffer
        /// - encoding: Set by libavcodec.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(668)]
        public sbyte* stats_out;

        /// <summary>
        /// pass2 encoding statistics input buffer
        /// Concatenated stuff from stats_out of pass1 should be placed here.
        /// - encoding: Allocated/set/freed by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(672)]
        public sbyte* stats_in;

        /// <summary>
        /// Work around bugs in encoders which sometimes cannot be detected
        /// automatically.
        /// - encoding: Set by user
        /// - decoding: Set by user
        /// </summary>
        [FieldOffset(676)]
        public int workaround_bugs;

        /// <summary>
        /// strictly follow the standard (MPEG4, ...).
        /// - encoding: Set by user.
        /// - decoding: Set by user.
        /// Setting this to STRICT or higher means the encoder and decoder will
        /// generally do stupid things, whereas setting it to unofficial or
        /// lower
        /// will mean the encoder might produce output that is not supported by
        /// all
        /// spec-compliant decoders. Decoders don't differentiate between
        /// normal,
        /// unofficial and experimental (that is, they always try to decode
        /// things
        /// when they can) unless they are explicitly asked to behave stupidly
        /// (=strictly conform to the specs)
        /// </summary>
        [FieldOffset(680)]
        public int strict_std_compliance;

        /// <summary>
        /// error concealment flags
        /// - encoding: unused
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(684)]
        public int error_concealment;

        /// <summary>
        /// debug
        /// - encoding: Set by user.
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(688)]
        public int debug;

        /// <summary>
        /// debug
        /// - encoding: Set by user.
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(692)]
        public int debug_mv;

        /// <summary>
        /// Error recognition; may misdetect some more or less valid parts as
        /// errors.
        /// - encoding: unused
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(696)]
        public int err_recognition;

        /// <summary>
        /// opaque 64bit number (generally a PTS) that will be reordered and
        /// output in AVFrame.reordered_opaque
        /// @deprecated in favor of pkt_pts
        /// - encoding: unused
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(704)]
        public long reordered_opaque;

        /// <summary>
        /// Hardware accelerator in use
        /// - encoding: unused.
        /// - decoding: Set by libavcodec
        /// </summary>
        [FieldOffset(712)]
        public AVHWAccel* hwaccel;

        /// <summary>
        /// Hardware accelerator context.
        /// For some hardware accelerators, a global context needs to be
        /// provided by the user. In that case, this holds display-dependent
        /// data FFmpeg cannot instantiate itself. Please refer to the
        /// FFmpeg HW accelerator documentation to know how to fill this
        /// is. e.g. for VA API, this is a struct vaapi_context.
        /// - encoding: unused
        /// - decoding: Set by user
        /// </summary>
        [FieldOffset(716)]
        public global::System.IntPtr hwaccel_context;

        /// <summary>
        /// error
        /// - encoding: Set by libavcodec if flags&CODEC_FLAG_PSNR.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(720)]
        public fixed ulong error[8];

        /// <summary>
        /// DCT algorithm, see FF_DCT_* below
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(784)]
        public int dct_algo;

        /// <summary>
        /// IDCT algorithm, see FF_IDCT_* below.
        /// - encoding: Set by user.
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(788)]
        public int idct_algo;

        /// <summary>
        /// bits per sample/pixel from the demuxer (needed for huffyuv).
        /// - encoding: Set by libavcodec.
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(792)]
        public int bits_per_coded_sample;

        /// <summary>
        /// Bits per sample/pixel of internal libavcodec pixel/sample format.
        /// - encoding: set by user.
        /// - decoding: set by libavcodec.
        /// </summary>
        [FieldOffset(796)]
        public int bits_per_raw_sample;

        /// <summary>
        /// low resolution decoding, 1-> 1/2 size, 2->1/4 size
        /// - encoding: unused
        /// - decoding: Set by user.
        /// Code outside libavcodec should access this field using:
        /// av_codec_{get,set}_lowres(avctx)
        /// </summary>
        [FieldOffset(800)]
        public int lowres;

        /// <summary>
        /// the picture in the bitstream
        /// - encoding: Set by libavcodec.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(804)]
        public AVFrame* coded_frame;

        /// <summary>
        /// thread count
        /// is used to decide how many independent tasks should be passed to
        /// execute()
        /// - encoding: Set by user.
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(808)]
        public int thread_count;

        /// <summary>
        /// Which multithreading methods to use.
        /// Use of FF_THREAD_FRAME will increase decoding delay by one frame
        /// per thread,
        /// so clients which cannot provide future frames should not use it.
        /// 
        /// - encoding: Set by user, otherwise the default is used.
        /// - decoding: Set by user, otherwise the default is used.
        /// </summary>
        [FieldOffset(812)]
        public int thread_type;

        /// <summary>
        /// Which multithreading methods are in use by the codec.
        /// - encoding: Set by libavcodec.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(816)]
        public int active_thread_type;

        /// <summary>
        /// Set by the client if its custom get_buffer() callback can be called
        /// synchronously from another thread, which allows faster
        /// multithreaded decoding.
        /// draw_horiz_band() will be called from other threads regardless of
        /// this setting.
        /// Ignored if the default get_buffer() is used.
        /// - encoding: Set by user.
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(820)]
        public int thread_safe_callbacks;

        /// <summary>
        /// The codec may call this to execute several independent things.
        /// It will return only after finishing all tasks.
        /// The user may replace this with some multithreaded implementation,
        /// the default implementation will execute the parts serially.
        /// @param count the number of things to execute
        /// - encoding: Set by libavcodec, user can override.
        /// - decoding: Set by libavcodec, user can override.
        /// </summary>
        [FieldOffset(824)]
        public global::System.IntPtr execute;

        /// <summary>
        /// The codec may call this to execute several independent things.
        /// It will return only after finishing all tasks.
        /// The user may replace this with some multithreaded implementation,
        /// the default implementation will execute the parts serially.
        /// Also see avcodec_thread_init and e.g. the --enable-pthread
        /// configure option.
        /// @param c context passed also to func
        /// @param count the number of things to execute
        /// @param arg2 argument passed unchanged to func
        /// @param ret return values of executed functions, must have space for
        /// "count" values. May be NULL.
        /// @param func function that will be called count times, with jobnr
        /// from 0 to count-1.
        /// threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS
        /// and so that no
        /// two instances of func executing at the same time will have the same
        /// threadnr.
        /// @return always 0 currently, but code should handle a future
        /// improvement where when any call to func
        /// returns < 0 no further calls to func may be done and < 0 is
        /// returned.
        /// - encoding: Set by libavcodec, user can override.
        /// - decoding: Set by libavcodec, user can override.
        /// </summary>
        [FieldOffset(828)]
        public global::System.IntPtr execute2;

        /// <summary>
        /// thread opaque
        /// Can be used by execute() to store some per AVCodecContext stuff.
        /// - encoding: set by execute()
        /// - decoding: set by execute()
        /// </summary>
        [FieldOffset(832)]
        public global::System.IntPtr thread_opaque;

        /// <summary>
        /// noise vs. sse weight for the nsse comparsion function
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(836)]
        public int nsse_weight;

        /// <summary>
        /// profile
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(840)]
        public int profile;

        /// <summary>
        /// level
        /// - encoding: Set by user.
        /// - decoding: Set by libavcodec.
        /// </summary>
        [FieldOffset(844)]
        public int level;

        /// <summary>
        /// Skip loop filtering for selected frames.
        /// - encoding: unused
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(848)]
        public AVDiscard skip_loop_filter;

        /// <summary>
        /// Skip IDCT/dequantization for selected frames.
        /// - encoding: unused
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(852)]
        public AVDiscard skip_idct;

        /// <summary>
        /// Skip decoding for selected frames.
        /// - encoding: unused
        /// - decoding: Set by user.
        /// </summary>
        [FieldOffset(856)]
        public AVDiscard skip_frame;

        /// <summary>
        /// Header containing style information for text subtitles.
        /// For SUBTITLE_ASS subtitle type, it should contain the whole ASS
        /// [Script Info] and [V4+ Styles] section, plus the [Events] line and
        /// the Format line following. It shouldn't include any Dialogue line.
        /// - encoding: Set/allocated/freed by user (before avcodec_open2())
        /// - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
        /// </summary>
        [FieldOffset(860)]
        public byte* subtitle_header;

        [FieldOffset(864)]
        public int subtitle_header_size;

        /// <summary>
        /// Simulates errors in the bitstream to test error concealment.
        /// - encoding: Set by user.
        /// - decoding: unused
        /// </summary>
        [FieldOffset(868)]
        public int error_rate;

        /// <summary>
        /// Current packet as passed into the decoder, to avoid having
        /// to pass the packet into every function. Currently only valid
        /// inside lavc and get/release_buffer callbacks.
        /// - decoding: set by avcodec_decode_*, read by get_buffer() for
        /// setting pkt_pts
        /// - encoding: unused
        /// </summary>
        [FieldOffset(872)]
        public AVPacket* pkt;

        /// <summary>
        /// VBV delay coded in the last frame (in periods of a 27 MHz clock).
        /// Used for compliant TS muxing.
        /// - encoding: Set by libavcodec.
        /// - decoding: unused.
        /// </summary>
        [FieldOffset(880)]
        public ulong vbv_delay;

        /// <summary>
        /// Timebase in which pkt_dts/pts and AVPacket.dts/pts are.
        /// Code outside libavcodec should access this field using:
        /// av_codec_{get,set}_pkt_timebase(avctx)
        /// - encoding unused.
        /// - decoding set by user.
        /// </summary>
        [FieldOffset(888)]
        public AVRational* pkt_timebase;

        /// <summary>
        /// AVCodecDescriptor
        /// Code outside libavcodec should access this field using:
        /// av_codec_{get,set}_codec_descriptor(avctx)
        /// - encoding: unused.
        /// - decoding: set by libavcodec.
        /// </summary>
        [FieldOffset(896)]
        public AVCodecDescriptor* codec_descriptor;

        /// <summary>
        /// Current statistics for PTS correction.
        /// - decoding: maintained and used by libavcodec, not intended to be
        /// used by user apps
        /// - encoding: unused
        /// </summary>
        [FieldOffset(904)]
        public long pts_correction_num_faulty_pts;

        /// <summary>
        /// Number of incorrect PTS values so far
        /// </summary>
        [FieldOffset(912)]
        public long pts_correction_num_faulty_dts;

        /// <summary>
        /// Number of incorrect DTS values so far
        /// </summary>
        [FieldOffset(920)]
        public long pts_correction_last_pts;

        /// <summary>
        /// PTS of the last frame
        /// </summary>
        [FieldOffset(928)]
        public long pts_correction_last_dts;

        /// <summary>
        /// Character encoding of the input subtitles file.
        /// - decoding: set by user
        /// - encoding: unused
        /// </summary>
        [FieldOffset(936)]
        public sbyte* sub_charenc;

        /// <summary>
        /// Subtitles character encoding mode. Formats or codecs might be
        /// adjusting
        /// this setting (if they are doing the conversion themselves for
        /// instance).
        /// - decoding: set by libavcodec
        /// - encoding: unused
        /// </summary>
        [FieldOffset(940)]
        public int sub_charenc_mode;

        /// <summary>
        /// Skip processing alpha if supported by codec.
        /// Note that if the format uses pre-multiplied alpha (common with VP6,
        /// and recommended due to better video quality/compression)
        /// the image will look as if alpha-blended onto a black background.
        /// However for formats that do not use pre-multiplied alpha
        /// there might be serious artefacts (though e.g. libswscale currently
        /// assumes pre-multiplied alpha anyway).
        /// Code outside libavcodec should access this field using AVOptions
        /// 
        /// - decoding: set by user
        /// - encoding: unused
        /// </summary>
        [FieldOffset(944)]
        public int skip_alpha;

        /// <summary>
        /// Number of samples to skip after a discontinuity
        /// - decoding: unused
        /// - encoding: set by libavcodec
        /// </summary>
        [FieldOffset(948)]
        public int seek_preroll;
    }

    /// <summary>
    /// AVProfile.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVProfile
    {
        [FieldOffset(0)]
        public int profile;

        /// <summary>
        /// < short name for the profile
        /// </summary>
        [FieldOffset(4)]
        public global::System.IntPtr name;
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVCodecDefault
    {
    }

    /// <summary>
    /// AVCodec.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVCodec
    {
        /// <summary>
        /// Name of the codec implementation.
        /// The name is globally unique among encoders and among decoders (but
        /// an
        /// encoder and a decoder can share the same name).
        /// This is the primary way to find a codec from the user perspective.
        /// </summary>
        [FieldOffset(0)]
        public global::System.IntPtr name;

        /// <summary>
        /// Descriptive name for the codec, meant to be more human readable
        /// than name.
        /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
        /// </summary>
        [FieldOffset(4)]
        public global::System.IntPtr long_name;

        [FieldOffset(8)]
        public AVMediaType type;

        [FieldOffset(12)]
        public AVCodecID id;

        /// <summary>
        /// Codec capabilities.
        /// see CODEC_CAP_*
        /// </summary>
        [FieldOffset(16)]
        public int capabilities;

        /// <summary>
        /// < array of supported framerates, or NULL if any, array is
        /// terminated by {0,0}
        /// </summary>
        [FieldOffset(20)]
        public AVRational* supported_framerates;

        /// <summary>
        /// < array of supported pixel formats, or NULL if unknown, array is
        /// terminated by -1
        /// </summary>
        [FieldOffset(24)]
        public AVPixelFormat pix_fmts;

        /// <summary>
        /// < array of supported audio samplerates, or NULL if unknown, array
        /// is terminated by 0
        /// </summary>
        [FieldOffset(28)]
        public int* supported_samplerates;

        /// <summary>
        /// < array of supported sample formats, or NULL if unknown, array is
        /// terminated by -1
        /// </summary>
        [FieldOffset(32)]
        public AVSampleFormat sample_fmts;

        /// <summary>
        /// < array of support channel layouts, or NULL if unknown. array is
        /// terminated by 0
        /// </summary>
        [FieldOffset(36)]
        public ulong* channel_layouts;

        /// <summary>
        /// < maximum value for lowres supported by the decoder, no direct
        /// access, use av_codec_get_max_lowres()
        /// </summary>
        [FieldOffset(40)]
        public byte max_lowres;

        /// <summary>
        /// < AVClass for the private context
        /// </summary>
        [FieldOffset(44)]
        public AVClass* priv_class;

        /// <summary>
        /// < array of recognized profiles, or NULL if unknown, array is
        /// terminated by {FF_PROFILE_UNKNOWN}
        /// </summary>
        [FieldOffset(48)]
        public AVProfile* profiles;

        /// <summary>
        /// No fields below this line are part of the public API. They
        /// may not be used outside of libavcodec and can be changed and
        /// removed at will.
        /// New public fields should be added right above.
        /// 
        /// </summary>
        [FieldOffset(52)]
        public int priv_data_size;

        [FieldOffset(56)]
        public AVCodec* next;

        /// <summary>
        /// @name Frame-level threading support functions
        /// @{
        /// 
        /// 
        /// If defined, called on thread contexts when they are created.
        /// If the codec allocates writable tables in init(), re-allocate them
        /// here.
        /// priv_data will be set to a copy of the original.
        /// </summary>
        [FieldOffset(60)]
        public global::System.IntPtr init_thread_copy;

        /// <summary>
        /// Copy necessary context variables from a previous thread context to
        /// the current one.
        /// If not defined, the next thread will start automatically;
        /// otherwise, the codec
        /// must call ff_thread_finish_setup().
        /// 
        /// dst and src will (rarely) point to the same context, in which case
        /// memcpy should be skipped.
        /// </summary>
        [FieldOffset(64)]
        public global::System.IntPtr update_thread_context;

        /// <summary>
        /// Private codec-specific defaults.
        /// </summary>
        [FieldOffset(68)]
        public AVCodecDefault* defaults;

        /// <summary>
        /// Initialize codec static data, called from avcodec_register().
        /// </summary>
        [FieldOffset(72)]
        public global::System.IntPtr init_static_data;

        [FieldOffset(76)]
        public global::System.IntPtr init;

        [FieldOffset(80)]
        public global::System.IntPtr encode_sub;

        /// <summary>
        /// Encode data to an AVPacket.
        /// 
        /// @param      avctx          codec context
        /// @param      avpkt          output AVPacket (may contain a
        /// user-provided buffer)
        /// @param[in]  frame          AVFrame containing the raw data to be
        /// encoded
        /// @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that
        /// a
        /// non-empty packet was returned in avpkt.
        /// @return 0 on success, negative error code on failure
        /// </summary>
        [FieldOffset(84)]
        public global::System.IntPtr encode2;

        [FieldOffset(88)]
        public global::System.IntPtr decode;

        [FieldOffset(92)]
        public global::System.IntPtr close;

        /// <summary>
        /// Flush buffers.
        /// Will be called when seeking
        /// </summary>
        [FieldOffset(96)]
        public global::System.IntPtr flush;
    }

    /// <summary>
    /// AVHWAccel.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVHWAccel
    {
        /// <summary>
        /// Name of the hardware accelerated codec.
        /// The name is globally unique among encoders and among decoders (but
        /// an
        /// encoder and a decoder can share the same name).
        /// </summary>
        [FieldOffset(0)]
        public global::System.IntPtr name;

        /// <summary>
        /// Type of codec implemented by the hardware accelerator.
        /// 
        /// See AVMEDIA_TYPE_xxx
        /// </summary>
        [FieldOffset(4)]
        public AVMediaType type;

        /// <summary>
        /// Codec implemented by the hardware accelerator.
        /// 
        /// See AV_CODEC_ID_xxx
        /// </summary>
        [FieldOffset(8)]
        public AVCodecID id;

        /// <summary>
        /// Supported pixel format.
        /// 
        /// Only hardware accelerated formats are supported here.
        /// </summary>
        [FieldOffset(12)]
        public AVPixelFormat pix_fmt;

        /// <summary>
        /// Hardware accelerated codec capabilities.
        /// see FF_HWACCEL_CODEC_CAP_*
        /// </summary>
        [FieldOffset(16)]
        public int capabilities;

        [FieldOffset(20)]
        public AVHWAccel* next;

        /// <summary>
        /// Called at the beginning of each frame or field picture.
        /// 
        /// Meaningful frame information (codec specific) is guaranteed to
        /// be parsed at this point. This function is mandatory.
        /// 
        /// Note that buf can be NULL along with buf_size set to 0.
        /// Otherwise, this means the whole frame is available at this point.
        /// 
        /// @param avctx the codec context
        /// @param buf the frame data buffer base
        /// @param buf_size the size of the frame in bytes
        /// @return zero if successful, a negative value otherwise
        /// </summary>
        [FieldOffset(24)]
        public global::System.IntPtr start_frame;

        /// <summary>
        /// Callback for each slice.
        /// 
        /// Meaningful slice information (codec specific) is guaranteed to
        /// be parsed at this point. This function is mandatory.
        /// 
        /// @param avctx the codec context
        /// @param buf the slice data buffer base
        /// @param buf_size the size of the slice in bytes
        /// @return zero if successful, a negative value otherwise
        /// </summary>
        [FieldOffset(28)]
        public global::System.IntPtr decode_slice;

        /// <summary>
        /// Called at the end of each frame or field picture.
        /// 
        /// The whole picture is parsed at this point and can now be sent
        /// to the hardware accelerator. This function is mandatory.
        /// 
        /// @param avctx the codec context
        /// @return zero if successful, a negative value otherwise
        /// </summary>
        [FieldOffset(32)]
        public global::System.IntPtr end_frame;

        /// <summary>
        /// Size of HW accelerator private data.
        /// 
        /// Private data is allocated with av_mallocz() before
        /// AVCodecContext.get_buffer() and deallocated after
        /// AVCodecContext.release_buffer().
        /// </summary>
        [FieldOffset(36)]
        public int priv_data_size;
    }

    /// <summary>
    /// Picture data structure.
    /// 
    /// Up to four components can be stored into it, the last component is
    /// alpha.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVPicture
    {
        /// <summary>
        /// < pointers to the image data planes
        /// </summary>
        [FieldOffset(0)]
        public byte* data_0;

        /// <summary>
        /// < pointers to the image data planes
        /// </summary>
        [FieldOffset(4)]
        public byte* data_1;

        /// <summary>
        /// < pointers to the image data planes
        /// </summary>
        [FieldOffset(8)]
        public byte* data_2;

        /// <summary>
        /// < pointers to the image data planes
        /// </summary>
        [FieldOffset(12)]
        public byte* data_3;

        /// <summary>
        /// < pointers to the image data planes
        /// </summary>
        [FieldOffset(16)]
        public byte* data_4;

        /// <summary>
        /// < pointers to the image data planes
        /// </summary>
        [FieldOffset(20)]
        public byte* data_5;

        /// <summary>
        /// < pointers to the image data planes
        /// </summary>
        [FieldOffset(24)]
        public byte* data_6;

        /// <summary>
        /// < pointers to the image data planes
        /// </summary>
        [FieldOffset(28)]
        public byte* data_7;

        /// <summary>
        /// < number of bytes per line
        /// </summary>
        [FieldOffset(32)]
        public fixed int linesize[8];
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVSubtitleRect
    {
        /// <summary>
        /// < top left corner  of pict, undefined when pict is not set
        /// </summary>
        [FieldOffset(0)]
        public int x;

        /// <summary>
        /// < top left corner  of pict, undefined when pict is not set
        /// </summary>
        [FieldOffset(4)]
        public int y;

        /// <summary>
        /// < width            of pict, undefined when pict is not set
        /// </summary>
        [FieldOffset(8)]
        public int w;

        /// <summary>
        /// < height           of pict, undefined when pict is not set
        /// </summary>
        [FieldOffset(12)]
        public int h;

        /// <summary>
        /// < number of colors in pict, undefined when pict is not set
        /// </summary>
        [FieldOffset(16)]
        public int nb_colors;

        /// <summary>
        /// data+linesize for the bitmap of this subtitle.
        /// can be set for text/ass as well once they where rendered
        /// </summary>
        [FieldOffset(20)]
        public AVPicture* pict;

        [FieldOffset(84)]
        public AVSubtitleType type;

        /// <summary>
        /// < 0 terminated plain UTF-8 text
        /// </summary>
        [FieldOffset(88)]
        public sbyte* text;

        /// <summary>
        /// 0 terminated ASS/SSA compatible event line.
        /// The presentation of this is unaffected by the other values in this
        /// struct.
        /// </summary>
        [FieldOffset(92)]
        public sbyte* ass;

        [FieldOffset(96)]
        public int flags;
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVSubtitle
    {
        [FieldOffset(0)]
        public ushort format;

        [FieldOffset(4)]
        public uint start_display_time;

        [FieldOffset(8)]
        public uint end_display_time;

        [FieldOffset(12)]
        public uint num_rects;

        [FieldOffset(16)]
        public AVSubtitleRect* rects;

        /// <summary>
        /// < Same as packet pts, in AV_TIME_BASE
        /// </summary>
        [FieldOffset(24)]
        public long pts;
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVCodecParserContext
    {
        [FieldOffset(0)]
        public global::System.IntPtr priv_data;

        [FieldOffset(4)]
        public AVCodecParser* parser;

        [FieldOffset(8)]
        public long frame_offset;

        [FieldOffset(16)]
        public long cur_offset;

        [FieldOffset(24)]
        public long next_frame_offset;

        [FieldOffset(32)]
        public int pict_type;

        /// <summary>
        /// This field is used for proper frame duration computation in lavf.
        /// It signals, how much longer the frame duration of the current frame
        /// is compared to normal frame duration.
        /// 
        /// frame_duration = (1 + repeat_pict) * time_base
        /// 
        /// It is used by codecs like H.264 to display telecined material.
        /// </summary>
        [FieldOffset(36)]
        public int repeat_pict;

        [FieldOffset(40)]
        public long pts;

        [FieldOffset(48)]
        public long dts;

        [FieldOffset(56)]
        public long last_pts;

        [FieldOffset(64)]
        public long last_dts;

        [FieldOffset(72)]
        public int fetch_timestamp;

        [FieldOffset(76)]
        public int cur_frame_start_index;

        [FieldOffset(80)]
        public fixed long cur_frame_offset[4];

        [FieldOffset(112)]
        public fixed long cur_frame_pts[4];

        [FieldOffset(144)]
        public fixed long cur_frame_dts[4];

        [FieldOffset(176)]
        public int flags;

        /// <summary>
        /// < byte offset from starting packet start
        /// </summary>
        [FieldOffset(184)]
        public long offset;

        [FieldOffset(192)]
        public fixed long cur_frame_end[4];

        /// <summary>
        /// Set by parser to 1 for key frames and 0 for non-key frames.
        /// It is initialized to -1, so if the parser doesn't set this flag,
        /// old-style fallback using AV_PICTURE_TYPE_I picture type as key
        /// frames
        /// will be used.
        /// </summary>
        [FieldOffset(224)]
        public int key_frame;

        /// <summary>
        /// Time difference in stream time base units from the pts of this
        /// packet to the point at which the output from the decoder has
        /// converged
        /// independent from the availability of previous frames. That is, the
        /// frames are virtually identical no matter if decoding started from
        /// the very first frame or from this keyframe.
        /// Is AV_NOPTS_VALUE if unknown.
        /// This field is not the display duration of the current frame.
        /// This field has no meaning if the packet does not have
        /// AV_PKT_FLAG_KEY
        /// set.
        /// 
        /// The purpose of this field is to allow seeking in streams that have
        /// no
        /// keyframes in the conventional sense. It corresponds to the
        /// recovery point SEI in H.264 and match_time_delta in NUT. It is also
        /// essential for some types of subtitle streams to ensure that all
        /// subtitles are correctly displayed after seeking.
        /// </summary>
        [FieldOffset(232)]
        public long convergence_duration;

        /// <summary>
        /// Synchronization point for start of timestamp generation.
        /// 
        /// Set to >0 for sync point, 0 for no sync point and <0 for undefined
        /// (default).
        /// 
        /// For example, this corresponds to presence of H.264 buffering period
        /// SEI message.
        /// </summary>
        [FieldOffset(240)]
        public int dts_sync_point;

        /// <summary>
        /// Offset of the current timestamp against last timestamp sync point
        /// in
        /// units of AVCodecContext.time_base.
        /// 
        /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
        /// contain a valid timestamp offset.
        /// 
        /// Note that the timestamp of sync point has usually a nonzero
        /// dts_ref_dts_delta, which refers to the previous sync point. Offset
        /// of
        /// the next frame after timestamp sync point will be usually 1.
        /// 
        /// For example, this corresponds to H.264 cpb_removal_delay.
        /// </summary>
        [FieldOffset(244)]
        public int dts_ref_dts_delta;

        /// <summary>
        /// Presentation delay of current frame in units of
        /// AVCodecContext.time_base.
        /// 
        /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
        /// contain valid non-negative timestamp delta (presentation time of a
        /// frame
        /// must not lie in the past).
        /// 
        /// This delay represents the difference between decoding and
        /// presentation
        /// time of the frame.
        /// 
        /// For example, this corresponds to H.264 dpb_output_delay.
        /// </summary>
        [FieldOffset(248)]
        public int pts_dts_delta;

        /// <summary>
        /// Position of the packet in file.
        /// 
        /// Analogous to cur_frame_pts/dts
        /// </summary>
        [FieldOffset(256)]
        public fixed long cur_frame_pos[4];

        /// <summary>
        /// Byte position of currently parsed frame in stream.
        /// </summary>
        [FieldOffset(288)]
        public long pos;

        /// <summary>
        /// Previous frame byte position.
        /// </summary>
        [FieldOffset(296)]
        public long last_pos;

        /// <summary>
        /// Duration of the current frame.
        /// For audio, this is in units of 1 / AVCodecContext.sample_rate.
        /// For all other types, this is in units of AVCodecContext.time_base.
        /// </summary>
        [FieldOffset(304)]
        public int duration;

        [FieldOffset(308)]
        public AVFieldOrder field_order;

        /// <summary>
        /// Indicate whether a picture is coded as a frame, top field or bottom
        /// field.
        /// 
        /// For example, H.264 field_pic_flag equal to 0 corresponds to
        /// AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag
        /// equal to 1 and bottom_field_flag equal to 0 corresponds to
        /// AV_PICTURE_STRUCTURE_TOP_FIELD.
        /// </summary>
        [FieldOffset(312)]
        public AVPictureStructure picture_structure;

        /// <summary>
        /// Picture number incremented in presentation or output order.
        /// This field may be reinitialized at the first picture of a new
        /// sequence.
        /// 
        /// For example, this corresponds to H.264 PicOrderCnt.
        /// </summary>
        [FieldOffset(316)]
        public int output_picture_number;
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVCodecParser
    {
        [FieldOffset(0)]
        public fixed int codec_ids[5];

        [FieldOffset(20)]
        public int priv_data_size;

        [FieldOffset(24)]
        public global::System.IntPtr parser_init;

        [FieldOffset(28)]
        public global::System.IntPtr parser_parse;

        [FieldOffset(32)]
        public global::System.IntPtr parser_close;

        [FieldOffset(36)]
        public global::System.IntPtr split;

        [FieldOffset(40)]
        public AVCodecParser* next;
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct ReSampleContext
    {
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVResampleContext
    {
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVBitStreamFilterContext
    {
        [FieldOffset(0)]
        public global::System.IntPtr priv_data;

        [FieldOffset(4)]
        public AVBitStreamFilter* filter;

        [FieldOffset(8)]
        public AVCodecParserContext* parser;

        [FieldOffset(12)]
        public AVBitStreamFilterContext* next;
    }

    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct AVBitStreamFilter
    {
        [FieldOffset(0)]
        public global::System.IntPtr name;

        [FieldOffset(4)]
        public int priv_data_size;

        [FieldOffset(8)]
        public global::System.IntPtr filter;

        [FieldOffset(12)]
        public global::System.IntPtr close;

        [FieldOffset(16)]
        public AVBitStreamFilter* next;
    }

    public unsafe partial class libavcodec
    {
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_get_pkt_timebase")]
        internal static extern AVRational* av_codec_get_pkt_timebase(AVCodecContext* avctx);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_set_pkt_timebase")]
        internal static extern void av_codec_set_pkt_timebase(AVCodecContext* avctx, AVRational* val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_get_codec_descriptor")]
        internal static extern AVCodecDescriptor* av_codec_get_codec_descriptor(AVCodecContext* avctx);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_set_codec_descriptor")]
        internal static extern void av_codec_set_codec_descriptor(AVCodecContext* avctx, AVCodecDescriptor* desc);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_get_lowres")]
        internal static extern int av_codec_get_lowres(AVCodecContext* avctx);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_set_lowres")]
        internal static extern void av_codec_set_lowres(AVCodecContext* avctx, int val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_get_seek_preroll")]
        internal static extern int av_codec_get_seek_preroll(AVCodecContext* avctx);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_set_seek_preroll")]
        internal static extern void av_codec_set_seek_preroll(AVCodecContext* avctx, int val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_get_max_lowres")]
        internal static extern int av_codec_get_max_lowres(AVCodec* codec);

        /// <summary>
        /// If c is NULL, returns the first registered codec,
        /// if c is non-NULL, returns the next registered codec after c,
        /// or NULL if c is the last one.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_next")]
        internal static extern AVCodec* av_codec_next(AVCodec* c);

        /// <summary>
        /// Return the LIBAVCODEC_VERSION_INT constant.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_version")]
        internal static extern uint avcodec_version();

        /// <summary>
        /// Return the libavcodec build-time configuration.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_configuration")]
        internal static extern global::System.IntPtr avcodec_configuration();

        /// <summary>
        /// Return the libavcodec license.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_license")]
        internal static extern global::System.IntPtr avcodec_license();

        /// <summary>
        /// Register the codec codec and initialize libavcodec.
        /// 
        /// @warning either this function or avcodec_register_all() must be called
        /// before any other libavcodec functions.
        /// 
        /// @see avcodec_register_all()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_register")]
        internal static extern void avcodec_register(AVCodec* codec);

        /// <summary>
        /// Register all the codecs, parsers and bitstream filters which were
        /// enabled at
        /// configuration time. If you do not call this function you can select
        /// exactly
        /// which formats you want to support, by using the individual registration
        /// functions.
        /// 
        /// @see avcodec_register
        /// @see av_register_codec_parser
        /// @see av_register_bitstream_filter
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_register_all")]
        internal static extern void avcodec_register_all();

        /// <summary>
        /// Allocate an AVCodecContext and set its fields to default values.  The
        /// resulting struct can be deallocated by calling avcodec_close() on it
        /// followed
        /// by av_free().
        /// 
        /// @param codec if non-NULL, allocate private data and initialize defaults
        /// for the given codec. It is illegal to then call avcodec_open2()
        /// with a different codec.
        /// If NULL, then the codec-specific defaults won't be initialized,
        /// which may result in suboptimal default settings (this is
        /// important mainly for encoders, e.g. libx264).
        /// 
        /// @return An AVCodecContext filled with default values or NULL on
        /// failure.
        /// @see avcodec_get_context_defaults
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_alloc_context3")]
        internal static extern AVCodecContext* avcodec_alloc_context3(AVCodec* codec);

        /// <summary>
        /// Set the fields of the given AVCodecContext to default values
        /// corresponding
        /// to the given codec (defaults may be codec-dependent).
        /// 
        /// Do not call this function if a non-NULL codec has been passed
        /// to avcodec_alloc_context3() that allocated this AVCodecContext.
        /// If codec is non-NULL, it is illegal to call avcodec_open2() with a
        /// different codec on this AVCodecContext.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_get_context_defaults3")]
        internal static extern int avcodec_get_context_defaults3(AVCodecContext* s, AVCodec* codec);

        /// <summary>
        /// Get the AVClass for AVCodecContext. It can be used in combination with
        /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
        /// 
        /// @see av_opt_find().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_get_class")]
        internal static extern AVClass* avcodec_get_class();

        /// <summary>
        /// Get the AVClass for AVFrame. It can be used in combination with
        /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
        /// 
        /// @see av_opt_find().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_get_frame_class")]
        internal static extern AVClass* avcodec_get_frame_class();

        /// <summary>
        /// Get the AVClass for AVSubtitleRect. It can be used in combination with
        /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
        /// 
        /// @see av_opt_find().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_get_subtitle_rect_class")]
        internal static extern AVClass* avcodec_get_subtitle_rect_class();

        /// <summary>
        /// Copy the settings of the source AVCodecContext into the destination
        /// AVCodecContext. The resulting destination codec context will be
        /// unopened, i.e. you are required to call avcodec_open2() before you
        /// can use this AVCodecContext to decode/encode video/audio data.
        /// 
        /// @param dest target codec context, should be initialized with
        /// avcodec_alloc_context3(NULL), but otherwise uninitialized
        /// @param src source codec context
        /// @return AVERROR() on error (e.g. memory allocation error), 0 on success
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_copy_context")]
        internal static extern int avcodec_copy_context(AVCodecContext* dest, AVCodecContext* src);

        /// <summary>
        /// Allocate an AVFrame and set its fields to default values.  The
        /// resulting
        /// struct must be freed using avcodec_free_frame().
        /// 
        /// @return An AVFrame filled with default values or NULL on failure.
        /// @see avcodec_get_frame_defaults
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_alloc_frame")]
        internal static extern AVFrame* avcodec_alloc_frame();

        /// <summary>
        /// Set the fields of the given AVFrame to default values.
        /// 
        /// @param frame The AVFrame of which the fields should be set to default
        /// values.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_get_frame_defaults")]
        internal static extern void avcodec_get_frame_defaults(AVFrame* frame);

        /// <summary>
        /// Free the frame and any dynamically allocated objects in it,
        /// e.g. extended_data.
        /// 
        /// @param frame frame to be freed. The pointer will be set to NULL.
        /// 
        /// @warning this function does NOT free the data buffers themselves
        /// (it does not know how, since they might have been allocated with
        /// a custom get_buffer()).
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_free_frame")]
        internal static extern void avcodec_free_frame(AVFrame* frame);

        /// <summary>
        /// Initialize the AVCodecContext to use the given AVCodec. Prior to using
        /// this
        /// function the context has to be allocated with avcodec_alloc_context3().
        /// 
        /// The functions avcodec_find_decoder_by_name(),
        /// avcodec_find_encoder_by_name(),
        /// avcodec_find_decoder() and avcodec_find_encoder() provide an easy way
        /// for
        /// retrieving a codec.
        /// 
        /// @warning This function is not thread safe!
        /// 
        /// @code
        /// avcodec_register_all();
        /// av_dict_set(&opts, "b", "2.5M", 0);
        /// codec = avcodec_find_decoder(AV_CODEC_ID_H264);
        /// if (!codec)
        /// exit(1);
        /// 
        /// context = avcodec_alloc_context3(codec);
        /// 
        /// if (avcodec_open2(context, codec, opts) < 0)
        /// exit(1);
        /// @endcode
        /// 
        /// @param avctx The context to initialize.
        /// @param codec The codec to open this context for. If a non-NULL codec
        /// has been
        /// previously passed to avcodec_alloc_context3() or
        /// avcodec_get_context_defaults3() for this context, then this
        /// parameter MUST be either NULL or equal to the previously passed
        /// codec.
        /// @param options A dictionary filled with AVCodecContext and
        /// codec-private options.
        /// On return this object will be filled with options that were not found.
        /// 
        /// @return zero on success, a negative value on error
        /// @see avcodec_alloc_context3(), avcodec_find_decoder(),
        /// avcodec_find_encoder(),
        /// av_dict_set(), av_opt_find().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_open2")]
        internal static extern int avcodec_open2(AVCodecContext* avctx, AVCodec* codec, AVDictionary* options);

        /// <summary>
        /// Close a given AVCodecContext and free all the data associated with it
        /// (but not the AVCodecContext itself).
        /// 
        /// Calling this function on an AVCodecContext that hasn't been opened will
        /// free
        /// the codec-specific data allocated in avcodec_alloc_context3() /
        /// avcodec_get_context_defaults3() with a non-NULL codec. Subsequent calls
        /// will
        /// do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_close")]
        internal static extern int avcodec_close(AVCodecContext* avctx);

        /// <summary>
        /// Free all allocated data in the given subtitle struct.
        /// 
        /// @param sub AVSubtitle to free.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avsubtitle_free")]
        internal static extern void avsubtitle_free(AVSubtitle* sub);

        /// <summary>
        /// Default packet destructor.
        /// @deprecated use the AVBuffer API instead
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_destruct_packet")]
        internal static extern void av_destruct_packet(AVPacket* pkt);

        /// <summary>
        /// Initialize optional fields of a packet with default values.
        /// 
        /// Note, this does not touch the data and size members, which have to be
        /// initialized separately.
        /// 
        /// @param pkt packet
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_init_packet")]
        internal static extern void av_init_packet(AVPacket* pkt);

        /// <summary>
        /// Allocate the payload of a packet and initialize its fields with
        /// default values.
        /// 
        /// @param pkt packet
        /// @param size wanted payload size
        /// @return 0 if OK, AVERROR_xxx otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_new_packet")]
        internal static extern int av_new_packet(AVPacket* pkt, int size);

        /// <summary>
        /// Reduce packet size, correctly zeroing padding
        /// 
        /// @param pkt packet
        /// @param size new size
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_shrink_packet")]
        internal static extern void av_shrink_packet(AVPacket* pkt, int size);

        /// <summary>
        /// Increase packet size, correctly zeroing padding
        /// 
        /// @param pkt packet
        /// @param grow_by number of bytes by which to increase the size of the
        /// packet
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_grow_packet")]
        internal static extern int av_grow_packet(AVPacket* pkt, int grow_by);

        /// <summary>
        /// Initialize a reference-counted packet from av_malloc()ed data.
        /// 
        /// @param pkt packet to be initialized. This function will set the data,
        /// size,
        /// buf and destruct fields, all others are left untouched.
        /// @param data Data allocated by av_malloc() to be used as packet data. If
        /// this
        /// function returns successfully, the data is owned by the underlying
        /// AVBuffer.
        /// The caller may not access the data through other means.
        /// @param size size of data in bytes, without the padding. I.e. the full
        /// buffer
        /// size is assumed to be size + FF_INPUT_BUFFER_PADDING_SIZE.
        /// 
        /// @return 0 on success, a negative AVERROR on error
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_packet_from_data")]
        internal static extern int av_packet_from_data(AVPacket* pkt, byte* data, int size);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_dup_packet")]
        internal static extern int av_dup_packet(AVPacket* pkt);

        /// <summary>
        /// Copy packet, including contents
        /// 
        /// @return 0 on success, negative AVERROR on fail
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_copy_packet")]
        internal static extern int av_copy_packet(AVPacket* dst, AVPacket* src);

        /// <summary>
        /// Copy packet side data
        /// 
        /// @return 0 on success, negative AVERROR on fail
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_copy_packet_side_data")]
        internal static extern int av_copy_packet_side_data(AVPacket* dst, AVPacket* src);

        /// <summary>
        /// Free a packet.
        /// 
        /// @param pkt packet to free
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_free_packet")]
        internal static extern void av_free_packet(AVPacket* pkt);

        /// <summary>
        /// Allocate new information of a packet.
        /// 
        /// @param pkt packet
        /// @param type side information type
        /// @param size side information size
        /// @return pointer to fresh allocated data or NULL otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_packet_new_side_data")]
        internal static extern byte* av_packet_new_side_data(AVPacket* pkt, AVPacketSideDataType type, int size);

        /// <summary>
        /// Shrink the already allocated side data buffer
        /// 
        /// @param pkt packet
        /// @param type side information type
        /// @param size new side information size
        /// @return 0 on success, < 0 on failure
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_packet_shrink_side_data")]
        internal static extern int av_packet_shrink_side_data(AVPacket* pkt, AVPacketSideDataType type, int size);

        /// <summary>
        /// Get side information from packet.
        /// 
        /// @param pkt packet
        /// @param type desired side information type
        /// @param size pointer for side information size to store (optional)
        /// @return pointer to data if present or NULL otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_packet_get_side_data")]
        internal static extern byte* av_packet_get_side_data(AVPacket* pkt, AVPacketSideDataType type, int* size);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_packet_merge_side_data")]
        internal static extern int av_packet_merge_side_data(AVPacket* pkt);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_packet_split_side_data")]
        internal static extern int av_packet_split_side_data(AVPacket* pkt);

        /// <summary>
        /// Convenience function to free all the side data stored.
        /// All the other fields stay untouched.
        /// 
        /// @param pkt packet
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_packet_free_side_data")]
        internal static extern void av_packet_free_side_data(AVPacket* pkt);

        /// <summary>
        /// Setup a new reference to the data described by a given packet
        /// 
        /// If src is reference-counted, setup dst as a new reference to the
        /// buffer in src. Otherwise allocate a new buffer in dst and copy the
        /// data from src into it.
        /// 
        /// All the other fields are copied from src.
        /// 
        /// @see av_packet_unref
        /// 
        /// @param dst Destination packet
        /// @param src Source packet
        /// 
        /// @return 0 on success, a negative AVERROR on error.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_packet_ref")]
        internal static extern int av_packet_ref(AVPacket* dst, AVPacket* src);

        /// <summary>
        /// Wipe the packet.
        /// 
        /// Unreference the buffer referenced by the packet and reset the
        /// remaining packet fields to their default values.
        /// 
        /// @param pkt The packet to be unreferenced.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_packet_unref")]
        internal static extern void av_packet_unref(AVPacket* pkt);

        /// <summary>
        /// Move every field in src to dst and reset src.
        /// 
        /// @see av_packet_unref
        /// 
        /// @param src Source packet, will be reset
        /// @param dst Destination packet
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_packet_move_ref")]
        internal static extern void av_packet_move_ref(AVPacket* dst, AVPacket* src);

        /// <summary>
        /// Copy only "properties" fields from src to dst.
        /// 
        /// Properties for the purpose of this function are all the fields
        /// beside those related to the packet data (buf, data, size)
        /// 
        /// @param dst Destination packet
        /// @param src Source packet
        /// 
        /// @return 0 on success AVERROR on failure.
        /// 
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_packet_copy_props")]
        internal static extern int av_packet_copy_props(AVPacket* dst, AVPacket* src);

        /// <summary>
        /// Find a registered decoder with a matching codec ID.
        /// 
        /// @param id AVCodecID of the requested decoder
        /// @return A decoder if one was found, NULL otherwise.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_find_decoder")]
        internal static extern AVCodec* avcodec_find_decoder(AVCodecID id);

        /// <summary>
        /// Find a registered decoder with the specified name.
        /// 
        /// @param name name of the requested decoder
        /// @return A decoder if one was found, NULL otherwise.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_find_decoder_by_name")]
        internal static extern AVCodec* avcodec_find_decoder_by_name(global::System.IntPtr name);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_default_get_buffer")]
        internal static extern int avcodec_default_get_buffer(AVCodecContext* s, AVFrame* pic);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_default_release_buffer")]
        internal static extern void avcodec_default_release_buffer(AVCodecContext* s, AVFrame* pic);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_default_reget_buffer")]
        internal static extern int avcodec_default_reget_buffer(AVCodecContext* s, AVFrame* pic);

        /// <summary>
        /// The default callback for AVCodecContext.get_buffer2(). It is made
        /// public so
        /// it can be called by custom get_buffer2() implementations for decoders
        /// without
        /// CODEC_CAP_DR1 set.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_default_get_buffer2")]
        internal static extern int avcodec_default_get_buffer2(AVCodecContext* s, AVFrame* frame, int flags);

        /// <summary>
        /// Return the amount of padding in pixels which the get_buffer callback
        /// must
        /// provide around the edge of the image for codecs which do not have the
        /// CODEC_FLAG_EMU_EDGE flag.
        /// 
        /// @return Required padding in pixels.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_get_edge_width")]
        internal static extern uint avcodec_get_edge_width();

        /// <summary>
        /// Modify width and height values so that they will result in a memory
        /// buffer that is acceptable for the codec if you do not use any
        /// horizontal
        /// padding.
        /// 
        /// May only be used if a codec with CODEC_CAP_DR1 has been opened.
        /// If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been
        /// increased
        /// according to avcodec_get_edge_width() before.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_align_dimensions")]
        internal static extern void avcodec_align_dimensions(AVCodecContext* s, int* width, int* height);

        /// <summary>
        /// Modify width and height values so that they will result in a memory
        /// buffer that is acceptable for the codec if you also ensure that all
        /// line sizes are a multiple of the respective linesize_align[i].
        /// 
        /// May only be used if a codec with CODEC_CAP_DR1 has been opened.
        /// If CODEC_FLAG_EMU_EDGE is not set, the dimensions must have been
        /// increased
        /// according to avcodec_get_edge_width() before.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_align_dimensions2")]
        internal static extern void avcodec_align_dimensions2(AVCodecContext* s, int* width, int* height, int* linesize_align);

        /// <summary>
        /// Converts AVChromaLocation to swscale x/y chroma position.
        /// 
        /// The positions represent the chroma (0,0) position in a coordinates
        /// system
        /// with luma (0,0) representing the origin and luma(1,1) representing
        /// 256,256
        /// 
        /// @param xpos  horizontal chroma sample position
        /// @param ypos  vertical   chroma sample position
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_enum_to_chroma_pos")]
        internal static extern int avcodec_enum_to_chroma_pos(int* xpos, int* ypos, AVChromaLocation pos);

        /// <summary>
        /// Converts swscale x/y chroma position to AVChromaLocation.
        /// 
        /// The positions represent the chroma (0,0) position in a coordinates
        /// system
        /// with luma (0,0) representing the origin and luma(1,1) representing
        /// 256,256
        /// 
        /// @param xpos  horizontal chroma sample position
        /// @param ypos  vertical   chroma sample position
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_chroma_pos_to_enum")]
        internal static extern AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos);

        /// <summary>
        /// Wrapper function which calls avcodec_decode_audio4.
        /// 
        /// @deprecated Use avcodec_decode_audio4 instead.
        /// 
        /// Decode the audio frame of size avpkt->size from avpkt->data into
        /// samples.
        /// Some decoders may support multiple frames in a single AVPacket, such
        /// decoders would then just decode the first frame. In this case,
        /// avcodec_decode_audio3 has to be called again with an AVPacket that
        /// contains
        /// the remaining data in order to decode the second frame etc.
        /// If no frame
        /// could be outputted, frame_size_ptr is zero. Otherwise, it is the
        /// decompressed frame size in bytes.
        /// 
        /// @warning You must set frame_size_ptr to the allocated size of the
        /// output buffer before calling avcodec_decode_audio3().
        /// 
        /// @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger
        /// than
        /// the actual read bytes because some optimized bitstream readers read 32
        /// or 64
        /// bits at once and could read over the end.
        /// 
        /// @warning The end of the input buffer avpkt->data should be set to 0 to
        /// ensure that
        /// no overreading happens for damaged MPEG streams.
        /// 
        /// @warning You must not provide a custom get_buffer() when using
        /// avcodec_decode_audio3().  Doing so will override it with
        /// avcodec_default_get_buffer.  Use avcodec_decode_audio4() instead,
        /// which does allow the application to provide a custom get_buffer().
        /// 
        /// @note You might have to align the input buffer avpkt->data and output
        /// buffer
        /// samples. The alignment requirements depend on the CPU: On some CPUs it
        /// isn't
        /// necessary at all, on others it won't work at all if not aligned and on
        /// others
        /// it will work but it will have an impact on performance.
        /// 
        /// In practice, avpkt->data should have 4 byte alignment at minimum and
        /// samples should be 16 byte aligned unless the CPU doesn't need it
        /// (AltiVec and SSE do).
        /// 
        /// @note Codecs which have the CODEC_CAP_DELAY capability set have a delay
        /// between input and output, these need to be fed with avpkt->data=NULL,
        /// avpkt->size=0 at the end to return the remaining frames.
        /// 
        /// @param avctx the codec context
        /// @param[out] samples the output buffer, sample type in avctx->sample_fmt
        /// If the sample format is planar, each channel plane will
        /// be the same size, with no padding between channels.
        /// @param[in,out] frame_size_ptr the output buffer size in bytes
        /// @param[in] avpkt The input AVPacket containing the input buffer.
        /// You can create such packet with av_init_packet() and by then setting
        /// data and size, some decoders might in addition need other fields.
        /// All decoders are designed to use the least fields possible though.
        /// @return On error a negative value is returned, otherwise the number of
        /// bytes
        /// used or zero if no frame data was decompressed (used) from the input
        /// AVPacket.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_decode_audio3")]
        internal static extern int avcodec_decode_audio3(AVCodecContext* avctx, short* samples, int* frame_size_ptr, AVPacket* avpkt);

        /// <summary>
        /// Decode the audio frame of size avpkt->size from avpkt->data into frame.
        /// 
        /// Some decoders may support multiple frames in a single AVPacket. Such
        /// decoders would then just decode the first frame and the return value
        /// would be
        /// less than the packet size. In this case, avcodec_decode_audio4 has to
        /// be
        /// called again with an AVPacket containing the remaining data in order to
        /// decode the second frame, etc...  Even if no frames are returned, the
        /// packet
        /// needs to be fed to the decoder with remaining data until it is
        /// completely
        /// consumed or an error occurs.
        /// 
        /// Some decoders (those marked with CODEC_CAP_DELAY) have a delay between
        /// input
        /// and output. This means that for some packets they will not immediately
        /// produce decoded output and need to be flushed at the end of decoding to
        /// get
        /// all the decoded data. Flushing is done by calling this function with
        /// packets
        /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
        /// returning samples. It is safe to flush even those decoders that are not
        /// marked with CODEC_CAP_DELAY, then no samples will be returned.
        /// 
        /// @warning The input buffer, avpkt->data must be
        /// FF_INPUT_BUFFER_PADDING_SIZE
        /// larger than the actual read bytes because some optimized bitstream
        /// readers read 32 or 64 bits at once and could read over the end.
        /// 
        /// @param      avctx the codec context
        /// @param[out] frame The AVFrame in which to store decoded audio samples.
        /// The decoder will allocate a buffer for the decoded frame by
        /// calling the AVCodecContext.get_buffer2() callback.
        /// When AVCodecContext.refcounted_frames is set to 1, the frame is
        /// reference counted and the returned reference belongs to the
        /// caller. The caller must release the frame using av_frame_unref()
        /// when the frame is no longer needed. The caller may safely write
        /// to the frame if av_frame_is_writable() returns 1.
        /// When AVCodecContext.refcounted_frames is set to 0, the returned
        /// reference belongs to the decoder and is valid only until the
        /// next call to this function or until closing or flushing the
        /// decoder. The caller may not write to it.
        /// @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise
        /// it is
        /// non-zero. Note that this field being set to zero
        /// does not mean that an error has occurred. For
        /// decoders with CODEC_CAP_DELAY set, no given decode
        /// call is guaranteed to produce a frame.
        /// @param[in]  avpkt The input AVPacket containing the input buffer.
        /// At least avpkt->data and avpkt->size should be set. Some
        /// decoders might also require additional fields to be set.
        /// @return A negative error code is returned if an error occurred during
        /// decoding, otherwise the number of bytes consumed from the input
        /// AVPacket is returned.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_decode_audio4")]
        internal static extern int avcodec_decode_audio4(AVCodecContext* avctx, AVFrame* frame, int* got_frame_ptr, AVPacket* avpkt);

        /// <summary>
        /// Decode the video frame of size avpkt->size from avpkt->data into
        /// picture.
        /// Some decoders may support multiple frames in a single AVPacket, such
        /// decoders would then just decode the first frame.
        /// 
        /// @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger
        /// than
        /// the actual read bytes because some optimized bitstream readers read 32
        /// or 64
        /// bits at once and could read over the end.
        /// 
        /// @warning The end of the input buffer buf should be set to 0 to ensure
        /// that
        /// no overreading happens for damaged MPEG streams.
        /// 
        /// @note Codecs which have the CODEC_CAP_DELAY capability set have a delay
        /// between input and output, these need to be fed with avpkt->data=NULL,
        /// avpkt->size=0 at the end to return the remaining frames.
        /// 
        /// @param avctx the codec context
        /// @param[out] picture The AVFrame in which the decoded video frame will
        /// be stored.
        /// Use av_frame_alloc() to get an AVFrame. The codec will
        /// allocate memory for the actual bitmap by calling the
        /// AVCodecContext.get_buffer2() callback.
        /// When AVCodecContext.refcounted_frames is set to 1, the frame is
        /// reference counted and the returned reference belongs to the
        /// caller. The caller must release the frame using av_frame_unref()
        /// when the frame is no longer needed. The caller may safely write
        /// to the frame if av_frame_is_writable() returns 1.
        /// When AVCodecContext.refcounted_frames is set to 0, the returned
        /// reference belongs to the decoder and is valid only until the
        /// next call to this function or until closing or flushing the
        /// decoder. The caller may not write to it.
        /// 
        /// @param[in] avpkt The input AVPacket containing the input buffer.
        /// You can create such packet with av_init_packet() and by then setting
        /// data and size, some decoders might in addition need other fields like
        /// flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least
        /// fields possible.
        /// @param[in,out] got_picture_ptr Zero if no frame could be decompressed,
        /// otherwise, it is nonzero.
        /// @return On error a negative value is returned, otherwise the number of
        /// bytes
        /// used or zero if no frame could be decompressed.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_decode_video2")]
        internal static extern int avcodec_decode_video2(AVCodecContext* avctx, AVFrame* picture, int* got_picture_ptr, AVPacket* avpkt);

        /// <summary>
        /// Decode a subtitle message.
        /// Return a negative value on error, otherwise return the number of bytes
        /// used.
        /// If no subtitle could be decompressed, got_sub_ptr is zero.
        /// Otherwise, the subtitle is stored in *sub.
        /// Note that CODEC_CAP_DR1 is not available for subtitle codecs. This is
        /// for
        /// simplicity, because the performance difference is expect to be
        /// negligible
        /// and reusing a get_buffer written for video codecs would probably
        /// perform badly
        /// due to a potentially very different allocation pattern.
        /// 
        /// Some decoders (those marked with CODEC_CAP_DELAY) have a delay between
        /// input
        /// and output. This means that for some packets they will not immediately
        /// produce decoded output and need to be flushed at the end of decoding to
        /// get
        /// all the decoded data. Flushing is done by calling this function with
        /// packets
        /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
        /// returning subtitles. It is safe to flush even those decoders that are
        /// not
        /// marked with CODEC_CAP_DELAY, then no subtitles will be returned.
        /// 
        /// @param avctx the codec context
        /// @param[out] sub The AVSubtitle in which the decoded subtitle will be
        /// stored, must be
        /// freed with avsubtitle_free if *got_sub_ptr is set.
        /// @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed,
        /// otherwise, it is nonzero.
        /// @param[in] avpkt The input AVPacket containing the input buffer.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_decode_subtitle2")]
        internal static extern int avcodec_decode_subtitle2(AVCodecContext* avctx, AVSubtitle* sub, int* got_sub_ptr, AVPacket* avpkt);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_parser_next")]
        internal static extern AVCodecParser* av_parser_next(AVCodecParser* c);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_register_codec_parser")]
        internal static extern void av_register_codec_parser(AVCodecParser* parser);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_parser_init")]
        internal static extern AVCodecParserContext* av_parser_init(int codec_id);

        /// <summary>
        /// Parse a packet.
        /// 
        /// @param s             parser context.
        /// @param avctx         codec context.
        /// @param poutbuf       set to pointer to parsed buffer or NULL if not yet
        /// finished.
        /// @param poutbuf_size  set to size of parsed buffer or zero if not yet
        /// finished.
        /// @param buf           input buffer.
        /// @param buf_size      input length, to signal EOF, this should be 0 (so
        /// that the last frame can be output).
        /// @param pts           input presentation timestamp.
        /// @param dts           input decoding timestamp.
        /// @param pos           input byte position in stream.
        /// @return the number of bytes of the input bitstream used.
        /// 
        /// Example:
        /// @code
        /// while(in_len){
        /// len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
        /// in_data, in_len,
        /// pts, dts, pos);
        /// in_data += len;
        /// in_len  -= len;
        /// 
        /// if(size)
        /// decode_frame(data, size);
        /// }
        /// @endcode
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_parser_parse2")]
        internal static extern int av_parser_parse2(AVCodecParserContext* s, AVCodecContext* avctx, byte* poutbuf, int* poutbuf_size, byte* buf, int buf_size, long pts, long dts, long pos);

        /// <summary>
        /// @return 0 if the output buffer is a subset of the input, 1 if it is
        /// allocated and must be freed
        /// @deprecated use AVBitStreamFilter
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_parser_change")]
        internal static extern int av_parser_change(AVCodecParserContext* s, AVCodecContext* avctx, byte* poutbuf, int* poutbuf_size, byte* buf, int buf_size, int keyframe);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_parser_close")]
        internal static extern void av_parser_close(AVCodecParserContext* s);

        /// <summary>
        /// Find a registered encoder with a matching codec ID.
        /// 
        /// @param id AVCodecID of the requested encoder
        /// @return An encoder if one was found, NULL otherwise.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_find_encoder")]
        internal static extern AVCodec* avcodec_find_encoder(AVCodecID id);

        /// <summary>
        /// Find a registered encoder with the specified name.
        /// 
        /// @param name name of the requested encoder
        /// @return An encoder if one was found, NULL otherwise.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_find_encoder_by_name")]
        internal static extern AVCodec* avcodec_find_encoder_by_name(global::System.IntPtr name);

        /// <summary>
        /// Encode an audio frame from samples into buf.
        /// 
        /// @deprecated Use avcodec_encode_audio2 instead.
        /// 
        /// @note The output buffer should be at least FF_MIN_BUFFER_SIZE bytes
        /// large.
        /// However, for codecs with avctx->frame_size equal to 0 (e.g. PCM) the
        /// user
        /// will know how much space is needed because it depends on the value
        /// passed
        /// in buf_size as described below. In that case a lower value can be used.
        /// 
        /// @param avctx the codec context
        /// @param[out] buf the output buffer
        /// @param[in] buf_size the output buffer size
        /// @param[in] samples the input buffer containing the samples
        /// The number of samples read from this buffer is frame_size*channels,
        /// both of which are defined in avctx.
        /// For codecs which have avctx->frame_size equal to 0 (e.g. PCM) the
        /// number of
        /// samples read from samples is equal to:
        /// buf_size * 8 / (avctx->channels *
        /// av_get_bits_per_sample(avctx->codec_id))
        /// This also implies that av_get_bits_per_sample() must not return 0 for
        /// these
        /// codecs.
        /// @return On error a negative value is returned, on success zero or the
        /// number
        /// of bytes used to encode the data read from the input buffer.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_encode_audio")]
        internal static extern int avcodec_encode_audio(AVCodecContext* avctx, byte* buf, int buf_size, short* samples);

        /// <summary>
        /// Encode a frame of audio.
        /// 
        /// Takes input samples from frame and writes the next output packet, if
        /// available, to avpkt. The output packet does not necessarily contain
        /// data for
        /// the most recent frame, as encoders can delay, split, and combine input
        /// frames
        /// internally as needed.
        /// 
        /// @param avctx     codec context
        /// @param avpkt     output AVPacket.
        /// The user can supply an output buffer by setting
        /// avpkt->data and avpkt->size prior to calling the
        /// function, but if the size of the user-provided data is not
        /// large enough, encoding will fail. If avpkt->data and
        /// avpkt->size are set, avpkt->destruct must also be set. All
        /// other AVPacket fields will be reset by the encoder using
        /// av_init_packet(). If avpkt->data is NULL, the encoder will
        /// allocate it. The encoder will set avpkt->size to the size
        /// of the output packet.
        /// 
        /// If this function fails or produces no output, avpkt will be
        /// freed using av_free_packet() (i.e. avpkt->destruct will be
        /// called to free the user supplied buffer).
        /// @param[in] frame AVFrame containing the raw audio data to be encoded.
        /// May be NULL when flushing an encoder that has the
        /// CODEC_CAP_DELAY capability set.
        /// If CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
        /// can have any number of samples.
        /// If it is not set, frame->nb_samples must be equal to
        /// avctx->frame_size for all frames except the last.
        /// The final frame may be smaller than avctx->frame_size.
        /// @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
        /// output packet is non-empty, and to 0 if it is
        /// empty. If the function returns an error, the
        /// packet can be assumed to be invalid, and the
        /// value of got_packet_ptr is undefined and should
        /// not be used.
        /// @return          0 on success, negative error code on failure
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_encode_audio2")]
        internal static extern int avcodec_encode_audio2(AVCodecContext* avctx, AVPacket* avpkt, AVFrame* frame, int* got_packet_ptr);

        /// <summary>
        /// @deprecated use avcodec_encode_video2() instead.
        /// 
        /// Encode a video frame from pict into buf.
        /// The input picture should be
        /// stored using a specific format, namely avctx.pix_fmt.
        /// 
        /// @param avctx the codec context
        /// @param[out] buf the output buffer for the bitstream of encoded frame
        /// @param[in] buf_size the size of the output buffer in bytes
        /// @param[in] pict the input picture to encode
        /// @return On error a negative value is returned, on success zero or the
        /// number
        /// of bytes used from the output buffer.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_encode_video")]
        internal static extern int avcodec_encode_video(AVCodecContext* avctx, byte* buf, int buf_size, AVFrame* pict);

        /// <summary>
        /// Encode a frame of video.
        /// 
        /// Takes input raw video data from frame and writes the next output
        /// packet, if
        /// available, to avpkt. The output packet does not necessarily contain
        /// data for
        /// the most recent frame, as encoders can delay and reorder input frames
        /// internally as needed.
        /// 
        /// @param avctx     codec context
        /// @param avpkt     output AVPacket.
        /// The user can supply an output buffer by setting
        /// avpkt->data and avpkt->size prior to calling the
        /// function, but if the size of the user-provided data is not
        /// large enough, encoding will fail. All other AVPacket fields
        /// will be reset by the encoder using av_init_packet(). If
        /// avpkt->data is NULL, the encoder will allocate it.
        /// The encoder will set avpkt->size to the size of the
        /// output packet. The returned data (if any) belongs to the
        /// caller, he is responsible for freeing it.
        /// 
        /// If this function fails or produces no output, avpkt will be
        /// freed using av_free_packet() (i.e. avpkt->destruct will be
        /// called to free the user supplied buffer).
        /// @param[in] frame AVFrame containing the raw video data to be encoded.
        /// May be NULL when flushing an encoder that has the
        /// CODEC_CAP_DELAY capability set.
        /// @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
        /// output packet is non-empty, and to 0 if it is
        /// empty. If the function returns an error, the
        /// packet can be assumed to be invalid, and the
        /// value of got_packet_ptr is undefined and should
        /// not be used.
        /// @return          0 on success, negative error code on failure
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_encode_video2")]
        internal static extern int avcodec_encode_video2(AVCodecContext* avctx, AVPacket* avpkt, AVFrame* frame, int* got_packet_ptr);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_encode_subtitle")]
        internal static extern int avcodec_encode_subtitle(AVCodecContext* avctx, byte* buf, int buf_size, AVSubtitle* sub);

        /// <summary>
        /// Initialize audio resampling context.
        /// 
        /// @param output_channels  number of output channels
        /// @param input_channels   number of input channels
        /// @param output_rate      output sample rate
        /// @param input_rate       input sample rate
        /// @param sample_fmt_out   requested output sample format
        /// @param sample_fmt_in    input sample format
        /// @param filter_length    length of each FIR filter in the filterbank
        /// relative to the cutoff frequency
        /// @param log2_phase_count log2 of the number of entries in the polyphase
        /// filterbank
        /// @param linear           if 1 then the used FIR filter will be linearly
        /// interpolated
        /// between the 2 closest, if 0 the closest will be used
        /// @param cutoff           cutoff frequency, 1.0 corresponds to half the
        /// output sampling rate
        /// @return allocated ReSampleContext, NULL if error occurred
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_audio_resample_init")]
        internal static extern ReSampleContext* av_audio_resample_init(int output_channels, int input_channels, int output_rate, int input_rate, AVSampleFormat sample_fmt_out, AVSampleFormat sample_fmt_in, int filter_length, int log2_phase_count, int linear, double cutoff);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="audio_resample")]
        internal static extern int audio_resample(ReSampleContext* s, short* output, short* input, int nb_samples);

        /// <summary>
        /// Free resample context.
        /// 
        /// @param s a non-NULL pointer to a resample context previously
        /// created with av_audio_resample_init()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="audio_resample_close")]
        internal static extern void audio_resample_close(ReSampleContext* s);

        /// <summary>
        /// Initialize an audio resampler.
        /// Note, if either rate is not an integer then simply scale both rates up
        /// so they are.
        /// @param filter_length length of each FIR filter in the filterbank
        /// relative to the cutoff freq
        /// @param log2_phase_count log2 of the number of entries in the polyphase
        /// filterbank
        /// @param linear If 1 then the used FIR filter will be linearly
        /// interpolated
        /// between the 2 closest, if 0 the closest will be used
        /// @param cutoff cutoff frequency, 1.0 corresponds to half the output
        /// sampling rate
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_resample_init")]
        internal static extern AVResampleContext* av_resample_init(int out_rate, int in_rate, int filter_length, int log2_phase_count, int linear, double cutoff);

        /// <summary>
        /// Resample an array of samples using a previously configured context.
        /// @param src an array of unconsumed samples
        /// @param consumed the number of samples of src which have been consumed
        /// are returned here
        /// @param src_size the number of unconsumed samples available
        /// @param dst_size the amount of space in samples available in dst
        /// @param update_ctx If this is 0 then the context will not be modified,
        /// that way several channels can be resampled with the same context.
        /// @return the number of samples written in dst or -1 if an error occurred
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_resample")]
        internal static extern int av_resample(AVResampleContext* c, short* dst, short* src, int* consumed, int src_size, int dst_size, int update_ctx);

        /// <summary>
        /// Compensate samplerate/timestamp drift. The compensation is done by
        /// changing
        /// the resampler parameters, so no audible clicks or similar distortions
        /// occur
        /// @param compensation_distance distance in output samples over which the
        /// compensation should be performed
        /// @param sample_delta number of output samples which should be output
        /// less
        /// 
        /// example: av_resample_compensate(c, 10, 500)
        /// here instead of 510 samples only 500 samples would be output
        /// 
        /// note, due to rounding the actual compensation might be slightly
        /// different,
        /// especially if the compensation_distance is large and the in_rate used
        /// during init is small
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_resample_compensate")]
        internal static extern void av_resample_compensate(AVResampleContext* c, int sample_delta, int compensation_distance);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_resample_close")]
        internal static extern void av_resample_close(AVResampleContext* c);

        /// <summary>
        /// Allocate memory for the pixels of a picture and setup the AVPicture
        /// fields for it.
        /// 
        /// Call avpicture_free() to free it.
        /// 
        /// @param picture            the picture structure to be filled in
        /// @param pix_fmt            the pixel format of the picture
        /// @param width              the width of the picture
        /// @param height             the height of the picture
        /// @return zero if successful, a negative error code otherwise
        /// 
        /// @see av_image_alloc(), avpicture_fill()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avpicture_alloc")]
        internal static extern int avpicture_alloc(AVPicture* picture, AVPixelFormat pix_fmt, int width, int height);

        /// <summary>
        /// Free a picture previously allocated by avpicture_alloc().
        /// The data buffer used by the AVPicture is freed, but the AVPicture
        /// structure
        /// itself is not.
        /// 
        /// @param picture the AVPicture to be freed
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avpicture_free")]
        internal static extern void avpicture_free(AVPicture* picture);

        /// <summary>
        /// Setup the picture fields based on the specified image parameters
        /// and the provided image data buffer.
        /// 
        /// The picture fields are filled in by using the image data buffer
        /// pointed to by ptr.
        /// 
        /// If ptr is NULL, the function will fill only the picture linesize
        /// array and return the required size for the image buffer.
        /// 
        /// To allocate an image buffer and fill the picture data in one call,
        /// use avpicture_alloc().
        /// 
        /// @param picture       the picture to be filled in
        /// @param ptr           buffer where the image data is stored, or NULL
        /// @param pix_fmt       the pixel format of the image
        /// @param width         the width of the image in pixels
        /// @param height        the height of the image in pixels
        /// @return the size in bytes required for src, a negative error code
        /// in case of failure
        /// 
        /// @see av_image_fill_arrays()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avpicture_fill")]
        internal static extern int avpicture_fill(AVPicture* picture, byte* ptr, AVPixelFormat pix_fmt, int width, int height);

        /// <summary>
        /// Copy pixel data from an AVPicture into a buffer.
        /// 
        /// avpicture_get_size() can be used to compute the required size for
        /// the buffer to fill.
        /// 
        /// @param src        source picture with filled data
        /// @param pix_fmt    picture pixel format
        /// @param width      picture width
        /// @param height     picture height
        /// @param dest       destination buffer
        /// @param dest_size  destination buffer size in bytes
        /// @return the number of bytes written to dest, or a negative value
        /// (error code) on error, for example if the destination buffer is not
        /// big enough
        /// 
        /// @see av_image_copy_to_buffer()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avpicture_layout")]
        internal static extern int avpicture_layout(AVPicture* src, AVPixelFormat pix_fmt, int width, int height, byte* dest, int dest_size);

        /// <summary>
        /// Calculate the size in bytes that a picture of the given width and
        /// height
        /// would occupy if stored in the given picture format.
        /// 
        /// @param pix_fmt    picture pixel format
        /// @param width      picture width
        /// @param height     picture height
        /// @return the computed picture buffer size or a negative error code
        /// in case of error
        /// 
        /// @see av_image_get_buffer_size().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avpicture_get_size")]
        internal static extern int avpicture_get_size(AVPixelFormat pix_fmt, int width, int height);

        /// <summary>
        /// deinterlace - if not supported return -1
        /// 
        /// @deprecated - use yadif (in libavfilter) instead
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avpicture_deinterlace")]
        internal static extern int avpicture_deinterlace(AVPicture* dst, AVPicture* src, AVPixelFormat pix_fmt, int width, int height);

        /// <summary>
        /// Copy image src to dst. Wraps av_image_copy().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_picture_copy")]
        internal static extern void av_picture_copy(AVPicture* dst, AVPicture* src, AVPixelFormat pix_fmt, int width, int height);

        /// <summary>
        /// Crop image top and left side.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_picture_crop")]
        internal static extern int av_picture_crop(AVPicture* dst, AVPicture* src, AVPixelFormat pix_fmt, int top_band, int left_band);

        /// <summary>
        /// Pad image.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_picture_pad")]
        internal static extern int av_picture_pad(AVPicture* dst, AVPicture* src, int height, int width, AVPixelFormat pix_fmt, int padtop, int padbottom, int padleft, int padright, int* color);

        /// <summary>
        /// Utility function to access log2_chroma_w log2_chroma_h from
        /// the pixel format AVPixFmtDescriptor.
        /// 
        /// This function asserts that pix_fmt is valid. See
        /// av_pix_fmt_get_chroma_sub_sample
        /// for one that returns a failure code and continues in case of invalid
        /// pix_fmts.
        /// 
        /// @param[in]  pix_fmt the pixel format
        /// @param[out] h_shift store log2_chroma_w
        /// @param[out] v_shift store log2_chroma_h
        /// 
        /// @see av_pix_fmt_get_chroma_sub_sample
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_get_chroma_sub_sample")]
        internal static extern void avcodec_get_chroma_sub_sample(AVPixelFormat pix_fmt, int* h_shift, int* v_shift);

        /// <summary>
        /// Return a value representing the fourCC code associated to the
        /// pixel format pix_fmt, or 0 if no associated fourCC code can be
        /// found.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_pix_fmt_to_codec_tag")]
        internal static extern uint avcodec_pix_fmt_to_codec_tag(AVPixelFormat pix_fmt);

        /// <summary>
        /// Compute what kind of losses will occur when converting from one
        /// specific
        /// pixel format to another.
        /// When converting from one pixel format to another, information loss may
        /// occur.
        /// For example, when converting from RGB24 to GRAY, the color information
        /// will
        /// be lost. Similarly, other losses occur when converting from some
        /// formats to
        /// other formats. These losses can involve loss of chroma, but also loss
        /// of
        /// resolution, loss of color depth, loss due to the color space
        /// conversion, loss
        /// of the alpha bits or loss due to color quantization.
        /// avcodec_get_fix_fmt_loss() informs you about the various types of
        /// losses
        /// which will occur when converting from one pixel format to another.
        /// 
        /// @param[in] dst_pix_fmt destination pixel format
        /// @param[in] src_pix_fmt source pixel format
        /// @param[in] has_alpha Whether the source pixel format alpha channel is
        /// used.
        /// @return Combination of flags informing you what kind of losses will
        /// occur
        /// (maximum loss for an invalid dst_pix_fmt).
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_get_pix_fmt_loss")]
        internal static extern int avcodec_get_pix_fmt_loss(AVPixelFormat dst_pix_fmt, AVPixelFormat src_pix_fmt, int has_alpha);

        /// <summary>
        /// Find the best pixel format to convert to given a certain source pixel
        /// format.  When converting from one pixel format to another, information
        /// loss
        /// may occur.  For example, when converting from RGB24 to GRAY, the color
        /// information will be lost. Similarly, other losses occur when converting
        /// from
        /// some formats to other formats. avcodec_find_best_pix_fmt_of_2()
        /// searches which of
        /// the given pixel formats should be used to suffer the least amount of
        /// loss.
        /// The pixel formats from which it chooses one, are determined by the
        /// pix_fmt_list parameter.
        /// 
        /// 
        /// @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel
        /// formats to choose from
        /// @param[in] src_pix_fmt source pixel format
        /// @param[in] has_alpha Whether the source pixel format alpha channel is
        /// used.
        /// @param[out] loss_ptr Combination of flags informing you what kind of
        /// losses will occur.
        /// @return The best pixel format to convert to or -1 if none was found.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_find_best_pix_fmt_of_list")]
        internal static extern AVPixelFormat avcodec_find_best_pix_fmt_of_list(AVPixelFormat pix_fmt_list, AVPixelFormat src_pix_fmt, int has_alpha, int* loss_ptr);

        /// <summary>
        /// Find the best pixel format to convert to given a certain source pixel
        /// format and a selection of two destination pixel formats. When
        /// converting from
        /// one pixel format to another, information loss may occur.  For example,
        /// when converting
        /// from RGB24 to GRAY, the color information will be lost. Similarly,
        /// other losses occur when
        /// converting from some formats to other formats.
        /// avcodec_find_best_pix_fmt_of_2() selects which of
        /// the given pixel formats should be used to suffer the least amount of
        /// loss.
        /// 
        /// If one of the destination formats is AV_PIX_FMT_NONE the other pixel
        /// format (if valid) will be
        /// returned.
        /// 
        /// @code
        /// src_pix_fmt = AV_PIX_FMT_YUV420P;
        /// dst_pix_fmt1= AV_PIX_FMT_RGB24;
        /// dst_pix_fmt2= AV_PIX_FMT_GRAY8;
        /// dst_pix_fmt3= AV_PIX_FMT_RGB8;
        /// loss= FF_LOSS_CHROMA; // don't care about chroma loss, so chroma loss
        /// will be ignored.
        /// dst_pix_fmt = avcodec_find_best_pix_fmt_of_2(dst_pix_fmt1,
        /// dst_pix_fmt2, src_pix_fmt, alpha, &loss);
        /// dst_pix_fmt = avcodec_find_best_pix_fmt_of_2(dst_pix_fmt, dst_pix_fmt3,
        /// src_pix_fmt, alpha, &loss);
        /// @endcode
        /// 
        /// @param[in] dst_pix_fmt1 One of the two destination pixel formats to
        /// choose from
        /// @param[in] dst_pix_fmt2 The other of the two destination pixel formats
        /// to choose from
        /// @param[in] src_pix_fmt Source pixel format
        /// @param[in] has_alpha Whether the source pixel format alpha channel is
        /// used.
        /// @param[in, out] loss_ptr Combination of loss flags. In: selects which
        /// of the losses to ignore, i.e.
        /// NULL or value of zero means we care about all losses. Out: the loss
        /// that occurs when converting from src to selected dst pixel format.
        /// @return The best pixel format to convert to or -1 if none was found.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_find_best_pix_fmt_of_2")]
        internal static extern AVPixelFormat avcodec_find_best_pix_fmt_of_2(AVPixelFormat dst_pix_fmt1, AVPixelFormat dst_pix_fmt2, AVPixelFormat src_pix_fmt, int has_alpha, int* loss_ptr);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_find_best_pix_fmt2")]
        internal static extern AVPixelFormat avcodec_find_best_pix_fmt2(AVPixelFormat dst_pix_fmt1, AVPixelFormat dst_pix_fmt2, AVPixelFormat src_pix_fmt, int has_alpha, int* loss_ptr);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_default_get_format")]
        internal static extern AVPixelFormat avcodec_default_get_format(AVCodecContext* s, AVPixelFormat fmt);

        /// <summary>
        /// @}
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_set_dimensions")]
        internal static extern void avcodec_set_dimensions(AVCodecContext* s, int width, int height);

        /// <summary>
        /// Put a string representing the codec tag codec_tag in buf.
        /// 
        /// @param buf_size size in bytes of buf
        /// @return the length of the string that would have been generated if
        /// enough space had been available, excluding the trailing null
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_get_codec_tag_string")]
        internal static extern uint av_get_codec_tag_string(sbyte* buf, uint buf_size, uint codec_tag);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_string")]
        internal static extern void avcodec_string(sbyte* buf, int buf_size, AVCodecContext* enc, int encode);

        /// <summary>
        /// Return a name for the specified profile, if available.
        /// 
        /// @param codec the codec that is searched for the given profile
        /// @param profile the profile value for which a name is requested
        /// @return A name for the profile if found, NULL otherwise.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_get_profile_name")]
        internal static extern global::System.IntPtr av_get_profile_name(AVCodec* codec, int profile);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_default_execute")]
        internal static extern int avcodec_default_execute(AVCodecContext* c, global::System.IntPtr func, global::System.IntPtr arg, int* ret, int count, int size);

        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_default_execute2")]
        internal static extern int avcodec_default_execute2(AVCodecContext* c, global::System.IntPtr func, global::System.IntPtr arg, int* ret, int count);

        /// <summary>
        /// Fill AVFrame audio data and linesize pointers.
        /// 
        /// The buffer buf must be a preallocated buffer with a size big enough
        /// to contain the specified samples amount. The filled AVFrame data
        /// pointers will point to this buffer.
        /// 
        /// AVFrame extended_data channel pointers are allocated if necessary for
        /// planar audio.
        /// 
        /// @param frame       the AVFrame
        /// frame->nb_samples must be set prior to calling the
        /// function. This function fills in frame->data,
        /// frame->extended_data, frame->linesize[0].
        /// @param nb_channels channel count
        /// @param sample_fmt  sample format
        /// @param buf         buffer to use for frame data
        /// @param buf_size    size of buffer
        /// @param align       plane size sample alignment (0 = default)
        /// @return            >=0 on success, negative error code on failure
        /// @todo return the size in bytes required to store the samples in
        /// case of success, at the next libavutil bump
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_fill_audio_frame")]
        internal static extern int avcodec_fill_audio_frame(AVFrame* frame, int nb_channels, AVSampleFormat sample_fmt, byte* buf, int buf_size, int align);

        /// <summary>
        /// Reset the internal decoder state / flush internal buffers. Should be
        /// called
        /// e.g. when seeking or when switching to a different stream.
        /// 
        /// @note when refcounted frames are not used (i.e.
        /// avctx->refcounted_frames is 0),
        /// this invalidates the frames previously returned from the decoder. When
        /// refcounted frames are used, the decoder just releases any references it
        /// might
        /// keep internally, but the caller's reference remains valid.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_flush_buffers")]
        internal static extern void avcodec_flush_buffers(AVCodecContext* avctx);

        /// <summary>
        /// Return codec bits per sample.
        /// 
        /// @param[in] codec_id the codec
        /// @return Number of bits per sample or zero if unknown for the given
        /// codec.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_get_bits_per_sample")]
        internal static extern int av_get_bits_per_sample(AVCodecID codec_id);

        /// <summary>
        /// Return the PCM codec associated with a sample format.
        /// @param be  endianness, 0 for little, 1 for big,
        /// -1 (or anything else) for native
        /// @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_get_pcm_codec")]
        internal static extern AVCodecID av_get_pcm_codec(AVSampleFormat fmt, int be);

        /// <summary>
        /// Return codec bits per sample.
        /// Only return non-zero if the bits per sample is exactly correct, not an
        /// approximation.
        /// 
        /// @param[in] codec_id the codec
        /// @return Number of bits per sample or zero if unknown for the given
        /// codec.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_get_exact_bits_per_sample")]
        internal static extern int av_get_exact_bits_per_sample(AVCodecID codec_id);

        /// <summary>
        /// Return audio frame duration.
        /// 
        /// @param avctx        codec context
        /// @param frame_bytes  size of the frame, or 0 if unknown
        /// @return             frame duration, in samples, if known. 0 if not able
        /// to
        /// determine.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_get_audio_frame_duration")]
        internal static extern int av_get_audio_frame_duration(AVCodecContext* avctx, int frame_bytes);

        /// <summary>
        /// Register a bitstream filter.
        /// 
        /// The filter will be accessible to the application code through
        /// av_bitstream_filter_next() or can be directly initialized with
        /// av_bitstream_filter_init().
        /// 
        /// @see avcodec_register_all()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_register_bitstream_filter")]
        internal static extern void av_register_bitstream_filter(AVBitStreamFilter* bsf);

        /// <summary>
        /// Create and initialize a bitstream filter context given a bitstream
        /// filter name.
        /// 
        /// The returned context must be freed with av_bitstream_filter_close().
        /// 
        /// @param name    the name of the bitstream filter
        /// @return a bitstream filter context if a matching filter was found
        /// and successfully initialized, NULL otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_bitstream_filter_init")]
        internal static extern AVBitStreamFilterContext* av_bitstream_filter_init(global::System.IntPtr name);

        /// <summary>
        /// Filter bitstream.
        /// 
        /// This function filters the buffer buf with size buf_size, and places the
        /// filtered buffer in the buffer pointed to by poutbuf.
        /// 
        /// The output buffer must be freed by the caller.
        /// 
        /// @param bsfc            bitstream filter context created by
        /// av_bitstream_filter_init()
        /// @param avctx           AVCodecContext accessed by the filter, may be
        /// NULL.
        /// If specified, this must point to the encoder context of the
        /// output stream the packet is sent to.
        /// @param args            arguments which specify the filter
        /// configuration, may be NULL
        /// @param poutbuf         pointer which is updated to point to the
        /// filtered buffer
        /// @param poutbuf_size    pointer which is updated to the filtered buffer
        /// size in bytes
        /// @param buf             buffer containing the data to filter
        /// @param buf_size        size in bytes of buf
        /// @param keyframe        set to non-zero if the buffer to filter
        /// corresponds to a key-frame packet data
        /// @return >= 0 in case of success, or a negative error code in case of
        /// failure
        /// 
        /// If the return value is positive, an output buffer is allocated and
        /// is availble in *poutbuf, and is distinct from the input buffer.
        /// 
        /// If the return value is 0, the output buffer is not allocated and
        /// should be considered identical to the input buffer, or in case
        /// poutbuf was set it points to the input buffer (not necessarily to
        /// its starting address).
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_bitstream_filter_filter")]
        internal static extern int av_bitstream_filter_filter(AVBitStreamFilterContext* bsfc, AVCodecContext* avctx, global::System.IntPtr args, byte* poutbuf, int* poutbuf_size, byte* buf, int buf_size, int keyframe);

        /// <summary>
        /// Release bitstream filter context.
        /// 
        /// @param bsf the bitstream filter context created with
        /// av_bitstream_filter_init(), can be NULL
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_bitstream_filter_close")]
        internal static extern void av_bitstream_filter_close(AVBitStreamFilterContext* bsf);

        /// <summary>
        /// If f is NULL, return the first registered bitstream filter,
        /// if f is non-NULL, return the next registered bitstream filter
        /// after f, or NULL if f is the last one.
        /// 
        /// This function can be used to iterate over all registered bitstream
        /// filters.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_bitstream_filter_next")]
        internal static extern AVBitStreamFilter* av_bitstream_filter_next(AVBitStreamFilter* f);

        /// <summary>
        /// Reallocate the given block if it is not large enough, otherwise do
        /// nothing.
        /// 
        /// @see av_realloc
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_fast_realloc")]
        internal static extern global::System.IntPtr av_fast_realloc(global::System.IntPtr ptr, uint* size, uint min_size);

        /// <summary>
        /// Allocate a buffer, reusing the given one if large enough.
        /// 
        /// Contrary to av_fast_realloc the current buffer contents might not be
        /// preserved and on error the old buffer is freed, thus no special
        /// handling to avoid memleaks is necessary.
        /// 
        /// @param ptr pointer to pointer to already allocated buffer, overwritten
        /// with pointer to new buffer
        /// @param size size of the buffer *ptr points to
        /// @param min_size minimum size of *ptr buffer after returning, *ptr will
        /// be NULL and
        /// size 0 if an error occurred.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_fast_malloc")]
        internal static extern void av_fast_malloc(global::System.IntPtr ptr, uint* size, uint min_size);

        /// <summary>
        /// Same behaviour av_fast_malloc but the buffer has additional
        /// FF_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.
        /// 
        /// In addition the whole buffer will initially and after resizes
        /// be 0-initialized so that no uninitialized data will ever appear.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_fast_padded_malloc")]
        internal static extern void av_fast_padded_malloc(global::System.IntPtr ptr, uint* size, uint min_size);

        /// <summary>
        /// Same behaviour av_fast_padded_malloc except that buffer will always
        /// be 0-initialized after call.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_fast_padded_mallocz")]
        internal static extern void av_fast_padded_mallocz(global::System.IntPtr ptr, uint* size, uint min_size);

        /// <summary>
        /// Encode extradata length to a buffer. Used by xiph codecs.
        /// 
        /// @param s buffer to write to; must be at least (v/255+1) bytes long
        /// @param v size of extradata in bytes
        /// @return number of bytes written to the buffer.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_xiphlacing")]
        internal static extern uint av_xiphlacing(byte* s, uint v);

        /// <summary>
        /// Log a generic warning message about a missing feature. This function is
        /// intended to be used internally by FFmpeg (libavcodec, libavformat,
        /// etc.)
        /// only, and would normally not be used by applications.
        /// @param[in] avc a pointer to an arbitrary struct of which the first
        /// field is
        /// a pointer to an AVClass struct
        /// @param[in] feature string containing the name of the missing feature
        /// @param[in] want_sample indicates if samples are wanted which exhibit
        /// this feature.
        /// If want_sample is non-zero, additional verbage will be added to the log
        /// message which tells the user how to report samples to the development
        /// mailing list.
        /// @deprecated Use avpriv_report_missing_feature() instead.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_log_missing_feature")]
        internal static extern void av_log_missing_feature(global::System.IntPtr avc, global::System.IntPtr feature, int want_sample);

        /// <summary>
        /// Log a generic warning message asking for a sample. This function is
        /// intended to be used internally by FFmpeg (libavcodec, libavformat,
        /// etc.)
        /// only, and would normally not be used by applications.
        /// @param[in] avc a pointer to an arbitrary struct of which the first
        /// field is
        /// a pointer to an AVClass struct
        /// @param[in] msg string containing an optional message, or NULL if no
        /// message
        /// @deprecated Use avpriv_request_sample() instead.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_log_ask_for_sample")]
        internal static extern void av_log_ask_for_sample(global::System.IntPtr avc, global::System.IntPtr msg);

        /// <summary>
        /// Register the hardware accelerator hwaccel.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_register_hwaccel")]
        internal static extern void av_register_hwaccel(AVHWAccel* hwaccel);

        /// <summary>
        /// If hwaccel is NULL, returns the first registered hardware accelerator,
        /// if hwaccel is non-NULL, returns the next registered hardware
        /// accelerator
        /// after hwaccel, or NULL if hwaccel is the last one.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_hwaccel_next")]
        internal static extern AVHWAccel* av_hwaccel_next(AVHWAccel* hwaccel);

        /// <summary>
        /// Register a user provided lock manager supporting the operations
        /// specified by AVLockOp. mutex points to a (void *) where the
        /// lockmgr should store/get a pointer to a user allocated mutex. It's
        /// NULL upon AV_LOCK_CREATE and != NULL for all other ops.
        /// 
        /// @param cb User defined callback. Note: FFmpeg may invoke calls to this
        /// callback during the call to av_lockmgr_register().
        /// Thus, the application must be prepared to handle that.
        /// If cb is set to NULL the lockmgr will be unregistered.
        /// Also note that during unregistration the previously registered
        /// lockmgr callback may also be invoked.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_lockmgr_register")]
        internal static extern int av_lockmgr_register(global::System.IntPtr cb);

        /// <summary>
        /// Get the type of the given codec.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_get_type")]
        internal static extern AVMediaType avcodec_get_type(AVCodecID codec_id);

        /// <summary>
        /// Get the name of a codec.
        /// @return  a static string identifying the codec; never NULL
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_get_name")]
        internal static extern global::System.IntPtr avcodec_get_name(AVCodecID id);

        /// <summary>
        /// @return a positive value if s is open (i.e. avcodec_open2() was called
        /// on it
        /// with no corresponding avcodec_close()), 0 otherwise.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_is_open")]
        internal static extern int avcodec_is_open(AVCodecContext* s);

        /// <summary>
        /// @return a non-zero number if codec is an encoder, zero otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_is_encoder")]
        internal static extern int av_codec_is_encoder(AVCodec* codec);

        /// <summary>
        /// @return a non-zero number if codec is a decoder, zero otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_codec_is_decoder")]
        internal static extern int av_codec_is_decoder(AVCodec* codec);

        /// <summary>
        /// @return descriptor for given codec ID or NULL if no descriptor exists.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_descriptor_get")]
        internal static extern AVCodecDescriptor* avcodec_descriptor_get(AVCodecID id);

        /// <summary>
        /// Iterate over all codec descriptors known to libavcodec.
        /// 
        /// @param prev previous descriptor. NULL to get the first descriptor.
        /// 
        /// @return next descriptor or NULL after the last descriptor
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_descriptor_next")]
        internal static extern AVCodecDescriptor* avcodec_descriptor_next(AVCodecDescriptor* prev);

        /// <summary>
        /// @return codec descriptor with the given name or NULL if no such
        /// descriptor
        /// exists.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avcodec-if-55.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="avcodec_descriptor_get_by_name")]
        internal static extern AVCodecDescriptor* avcodec_descriptor_get_by_name(global::System.IntPtr name);
    }
}
