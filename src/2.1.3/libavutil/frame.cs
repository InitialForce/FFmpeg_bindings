//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FFmpeg
{
    public unsafe static partial class libavutil
    {
        public const sbyte AV_NUM_DATA_POINTERS = 8;

        public const sbyte FF_DECODE_ERROR_INVALID_BITSTREAM = 1;

        public const sbyte FF_DECODE_ERROR_MISSING_REFERENCE = 2;

        public enum AVColorSpace
        {
            AVCOL_SPC_RGB = 0,
            /// <summary>also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B</summary>
            AVCOL_SPC_BT709 = 1,
            AVCOL_SPC_UNSPECIFIED = 2,
            AVCOL_SPC_FCC = 4,
            /// <summary>also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601</summary>
            AVCOL_SPC_BT470BG = 5,
            /// <summary>also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above</summary>
            AVCOL_SPC_SMPTE170M = 6,
            AVCOL_SPC_SMPTE240M = 7,
            /// <summary>Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16</summary>
            AVCOL_SPC_YCOCG = 8,
            /// <summary>Not part of ABI</summary>
            AVCOL_SPC_NB = 9
        }

        public enum AVColorRange
        {
            AVCOL_RANGE_UNSPECIFIED = 0,
            /// <summary>the normal 219*2^(n-8) "MPEG" YUV ranges</summary>
            AVCOL_RANGE_MPEG = 1,
            /// <summary>the normal 2^n-1 "JPEG" YUV ranges</summary>
            AVCOL_RANGE_JPEG = 2,
            /// <summary>Not part of ABI</summary>
            AVCOL_RANGE_NB = 3
        }

        public enum AVFrameSideDataType
        {
            /// <summary>The data is the AVPanScan struct defined in libavcodec.</summary>
            AV_FRAME_DATA_PANSCAN = 0
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVPanScan
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVCodecContext
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFrameSideData
        {
            public libavutil.AVFrameSideDataType type;

            public byte* data;

            public int size;

            public libavutil.AVDictionary* metadata;
        }

        /// <summary>
        /// This structure describes decoded (raw) audio or video data.
        /// 
        /// AVFrame must be allocated using av_frame_alloc(). Note that this only
        /// allocates the AVFrame itself, the buffers for the data must be managed
        /// through other means (see below).
        /// AVFrame must be freed with av_frame_free().
        /// 
        /// AVFrame is typically allocated once and then reused multiple times to
        /// hold
        /// different data (e.g. a single AVFrame to hold frames received from a
        /// decoder). In such a case, av_frame_unref() will free any references
        /// held by
        /// the frame and reset it to its original clean state before it
        /// is reused again.
        /// 
        /// The data described by an AVFrame is usually reference counted through
        /// the
        /// AVBuffer API. The underlying buffer references are stored in
        /// AVFrame.buf
        /// AVFrame.extended_buf. An AVFrame is considered to be reference counted
        /// if at
        /// least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a
        /// case,
        /// every single data plane must be contained in one of the buffers in
        /// AVFrame.buf or AVFrame.extended_buf.
        /// There may be a single buffer for all the data, or one separate buffer
        /// for
        /// each plane, or anything in between.
        /// 
        /// sizeof(AVFrame) is not a part of the public ABI, so new fields may be
        /// added
        /// to the end with a minor bump.
        /// Similarly fields that are marked as to be only accessed by
        /// av_opt_ptr() can be reordered. This allows 2 forks to add fields
        /// without breaking compatibility with each other.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFrame
        {
            /// <summary>
            /// pointer to the picture/channel planes.
            /// This might be different from the first allocated byte
            /// 
            /// Some decoders access areas outside 0,0 - width,height, please
            /// see avcodec_align_dimensions2(). Some filters and swscale can read
            /// up to 16 bytes beyond the planes, if these filters are to be used,
            /// then 16 extra bytes must be allocated.
            /// </summary>
            public ArrayWrapper_BytePtr8 data;

            /// <summary>
            /// For video, size in bytes of each picture line.
            /// For audio, size in bytes of each plane.
            /// 
            /// For audio, only linesize[0] may be set. For planar audio, each channel
            /// plane must be the same size.
            /// 
            /// For video the linesizes should be multiplies of the CPUs alignment
            /// preference, this is 16 or 32 for modern desktop CPUs.
            /// Some code requires such alignment other code can be slower without
            /// correct alignment, for yet other it makes no difference.
            /// 
            /// @note The linesize may be larger than the size of usable data -- there
            /// may be extra padding present for performance reasons.
            /// </summary>
            public fixed int linesize[8];

            /// <summary>
            /// pointers to the data planes/channels.
            /// 
            /// For video, this should simply point to data[].
            /// 
            /// For planar audio, each channel has a separate data pointer, and
            /// linesize[0] contains the size of each channel buffer.
            /// For packed audio, there is just one data pointer, and linesize[0]
            /// contains the total size of the buffer for all channels.
            /// 
            /// Note: Both data and extended_data should always be set in a valid
            /// frame,
            /// but for planar audio with more channels that can fit in data,
            /// extended_data must be used in order to access all channels.
            /// </summary>
            public byte** extended_data;

            /// <summary>
            /// width and height of the video frame
            /// </summary>
            public int width;

            /// <summary>
            /// width and height of the video frame
            /// </summary>
            public int height;

            /// <summary>
            /// number of audio samples (per channel) described by this frame
            /// </summary>
            public int nb_samples;

            /// <summary>
            /// format of the frame, -1 if unknown or unset
            /// Values correspond to enum AVPixelFormat for video frames,
            /// enum AVSampleFormat for audio)
            /// </summary>
            public int format;

            /// <summary>
            /// 1 -> keyframe, 0-> not
            /// </summary>
            public int key_frame;

            /// <summary>
            /// Picture type of the frame.
            /// </summary>
            public libavutil.AVPictureType pict_type;

            public ArrayWrapper_BytePtr8 @base;

            /// <summary>
            /// Sample aspect ratio for the video frame, 0/1 if unknown/unspecified.
            /// </summary>
            public libavutil.AVRational sample_aspect_ratio;

            /// <summary>
            /// Presentation timestamp in time_base units (time when frame should be
            /// shown to user).
            /// </summary>
            public long pts;

            /// <summary>
            /// PTS copied from the AVPacket that was decoded to produce this frame.
            /// </summary>
            public long pkt_pts;

            /// <summary>
            /// DTS copied from the AVPacket that triggered returning this frame. (if
            /// frame threading isnt used)
            /// This is also the Presentation time of this AVFrame calculated from
            /// only AVPacket.dts values without pts values.
            /// </summary>
            public long pkt_dts;

            /// <summary>
            /// picture number in bitstream order
            /// </summary>
            public int coded_picture_number;

            /// <summary>
            /// picture number in display order
            /// </summary>
            public int display_picture_number;

            /// <summary>
            /// quality (between 1 (good) and FF_LAMBDA_MAX (bad))
            /// </summary>
            public int quality;

            public int reference;

            /// <summary>
            /// QP table
            /// </summary>
            public sbyte* qscale_table;

            /// <summary>
            /// QP store stride
            /// </summary>
            public int qstride;

            public int qscale_type;

            /// <summary>
            /// mbskip_table[mb]>=1 if MB didn't change
            /// stride= mb_width = (width+15)>>4
            /// </summary>
            public byte* mbskip_table;

            /// <summary>
            /// motion vector table
            /// @code
            /// example:
            /// int mv_sample_log2= 4 - motion_subsample_log2;
            /// int mb_width= (width+15)>>4;
            /// int mv_stride= (mb_width << mv_sample_log2) + 1;
            /// motion_val[direction][x + y*mv_stride][0->mv_x, 1->mv_y];
            /// @endcode
            /// </summary>
            public ArrayWrapper_ShortPtrPtr2 motion_val;

            /// <summary>
            /// macroblock type table
            /// mb_type_base + mb_width + 2
            /// </summary>
            public uint* mb_type;

            /// <summary>
            /// DCT coefficients
            /// </summary>
            public short* dct_coeff;

            /// <summary>
            /// motion reference frame index
            /// the order in which these are stored can depend on the codec.
            /// </summary>
            public ArrayWrapper_SbytePtr2 ref_index;

            /// <summary>
            /// for some private data of the user
            /// </summary>
            public void* opaque;

            /// <summary>
            /// error
            /// </summary>
            public fixed ulong error[8];

            public int type;

            /// <summary>
            /// When decoding, this signals how much the picture must be delayed.
            /// extra_delay = repeat_pict / (2*fps)
            /// </summary>
            public int repeat_pict;

            /// <summary>
            /// The content of the picture is interlaced.
            /// </summary>
            public int interlaced_frame;

            /// <summary>
            /// If the content is interlaced, is top field displayed first.
            /// </summary>
            public int top_field_first;

            /// <summary>
            /// Tell user application that palette has changed from previous frame.
            /// </summary>
            public int palette_has_changed;

            public int buffer_hints;

            /// <summary>
            /// Pan scan.
            /// </summary>
            public libavutil.AVPanScan* pan_scan;

            /// <summary>
            /// reordered opaque 64bit (generally an integer or a double precision
            /// float
            /// PTS but can be anything).
            /// The user sets AVCodecContext.reordered_opaque to represent the input at
            /// that time,
            /// the decoder reorders values as needed and sets AVFrame.reordered_opaque
            /// to exactly one of the values provided by the user through
            /// AVCodecContext.reordered_opaque
            /// @deprecated in favor of pkt_pts
            /// </summary>
            public long reordered_opaque;

            public void* hwaccel_picture_private;

            public libavutil.AVCodecContext* owner;

            public void* thread_opaque;

            /// <summary>
            /// log2 of the size of the block which a single vector in motion_val
            /// represents:
            /// (4->16x16, 3->8x8, 2-> 4x4, 1-> 2x2)
            /// </summary>
            public byte motion_subsample_log2;

            /// <summary>
            /// Sample rate of the audio data.
            /// </summary>
            public int sample_rate;

            /// <summary>
            /// Channel layout of the audio data.
            /// </summary>
            public ulong channel_layout;

            /// <summary>
            /// AVBuffer references backing the data for this frame. If all elements of
            /// this array are NULL, then this frame is not reference counted.
            /// 
            /// There may be at most one AVBuffer per data plane, so for video this
            /// array
            /// always contains all the references. For planar audio with more than
            /// AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit
            /// in
            /// this array. Then the extra AVBufferRef pointers are stored in the
            /// extended_buf array.
            /// </summary>
            public ArrayWrapper_AVBufferRef8 buf;

            /// <summary>
            /// For planar audio which requires more than AV_NUM_DATA_POINTERS
            /// AVBufferRef pointers, this array will hold all the references which
            /// cannot fit into AVFrame.buf.
            /// 
            /// Note that this is different from AVFrame.extended_data, which always
            /// contains all the pointers. This array only contains the extra pointers,
            /// which cannot fit into AVFrame.buf.
            /// 
            /// This array is always allocated using av_malloc() by whoever constructs
            /// the frame. It is freed in av_frame_unref().
            /// </summary>
            public libavutil.AVBufferRef** extended_buf;

            /// <summary>
            /// Number of elements in extended_buf.
            /// </summary>
            public int nb_extended_buf;

            public libavutil.AVFrameSideData** side_data;

            public int nb_side_data;

            /// <summary>
            /// frame timestamp estimated using various heuristics, in stream time base
            /// Code outside libavcodec should access this field using:
            /// av_frame_get_best_effort_timestamp(frame)
            /// - encoding: unused
            /// - decoding: set by libavcodec, read by user.
            /// </summary>
            public long best_effort_timestamp;

            /// <summary>
            /// reordered pos from the last AVPacket that has been input into the
            /// decoder
            /// Code outside libavcodec should access this field using:
            /// av_frame_get_pkt_pos(frame)
            /// - encoding: unused
            /// - decoding: Read by user.
            /// </summary>
            public long pkt_pos;

            /// <summary>
            /// duration of the corresponding packet, expressed in
            /// AVStream->time_base units, 0 if unknown.
            /// Code outside libavcodec should access this field using:
            /// av_frame_get_pkt_duration(frame)
            /// - encoding: unused
            /// - decoding: Read by user.
            /// </summary>
            public long pkt_duration;

            /// <summary>
            /// metadata.
            /// Code outside libavcodec should access this field using:
            /// av_frame_get_metadata(frame)
            /// - encoding: Set by user.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public libavutil.AVDictionary* metadata;

            /// <summary>
            /// decode error flags of the frame, set to a combination of
            /// FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there
            /// were errors during the decoding.
            /// Code outside libavcodec should access this field using:
            /// av_frame_get_decode_error_flags(frame)
            /// - encoding: unused
            /// - decoding: set by libavcodec, read by user.
            /// </summary>
            public int decode_error_flags;

            /// <summary>
            /// number of audio channels, only used for audio.
            /// Code outside libavcodec should access this field using:
            /// av_frame_get_channels(frame)
            /// - encoding: unused
            /// - decoding: Read by user.
            /// </summary>
            public int channels;

            /// <summary>
            /// size of the corresponding packet containing the compressed
            /// frame. It must be accessed using av_frame_get_pkt_size() and
            /// av_frame_set_pkt_size().
            /// It is set to a negative value if unknown.
            /// - encoding: unused
            /// - decoding: set by libavcodec, read by user.
            /// </summary>
            public int pkt_size;

            /// <summary>
            /// YUV colorspace type.
            /// It must be accessed using av_frame_get_colorspace() and
            /// av_frame_set_colorspace().
            /// - encoding: Set by user
            /// - decoding: Set by libavcodec
            /// </summary>
            public libavutil.AVColorSpace colorspace;

            /// <summary>
            /// MPEG vs JPEG YUV range.
            /// It must be accessed using av_frame_get_color_range() and
            /// av_frame_set_color_range().
            /// - encoding: Set by user
            /// - decoding: Set by libavcodec
            /// </summary>
            public libavutil.AVColorRange color_range;

            /// <summary>
            /// Not to be accessed directly from outside libavutil
            /// </summary>
            public libavutil.AVBufferRef* qp_table_buf;
        }

        /// <summary>
        /// Accessors for some AVFrame fields.
        /// The position of these field in the structure is not part of the ABI,
        /// they should not be accessed directly outside libavcodec.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_best_effort_timestamp")]
        public static extern long av_frame_get_best_effort_timestamp(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_best_effort_timestamp")]
        public static extern void av_frame_set_best_effort_timestamp(libavutil.AVFrame* frame, long val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_pkt_duration")]
        public static extern long av_frame_get_pkt_duration(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_pkt_duration")]
        public static extern void av_frame_set_pkt_duration(libavutil.AVFrame* frame, long val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_pkt_pos")]
        public static extern long av_frame_get_pkt_pos(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_pkt_pos")]
        public static extern void av_frame_set_pkt_pos(libavutil.AVFrame* frame, long val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_channel_layout")]
        public static extern long av_frame_get_channel_layout(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_channel_layout")]
        public static extern void av_frame_set_channel_layout(libavutil.AVFrame* frame, long val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_channels")]
        public static extern int av_frame_get_channels(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_channels")]
        public static extern void av_frame_set_channels(libavutil.AVFrame* frame, int val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_sample_rate")]
        public static extern int av_frame_get_sample_rate(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_sample_rate")]
        public static extern void av_frame_set_sample_rate(libavutil.AVFrame* frame, int val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_metadata")]
        public static extern libavutil.AVDictionary* av_frame_get_metadata(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_metadata")]
        public static extern void av_frame_set_metadata(libavutil.AVFrame* frame, libavutil.AVDictionary* val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_decode_error_flags")]
        public static extern int av_frame_get_decode_error_flags(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_decode_error_flags")]
        public static extern void av_frame_set_decode_error_flags(libavutil.AVFrame* frame, int val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_pkt_size")]
        public static extern int av_frame_get_pkt_size(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_pkt_size")]
        public static extern void av_frame_set_pkt_size(libavutil.AVFrame* frame, int val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avpriv_frame_get_metadatap")]
        public static extern libavutil.AVDictionary** avpriv_frame_get_metadatap(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_qp_table")]
        public static extern sbyte* av_frame_get_qp_table(libavutil.AVFrame* f, int* stride, int* type);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_qp_table")]
        public static extern int av_frame_set_qp_table(libavutil.AVFrame* f, libavutil.AVBufferRef* buf, int stride, int type);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_colorspace")]
        public static extern libavutil.AVColorSpace av_frame_get_colorspace(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_colorspace")]
        public static extern void av_frame_set_colorspace(libavutil.AVFrame* frame, libavutil.AVColorSpace val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_color_range")]
        public static extern libavutil.AVColorRange av_frame_get_color_range(libavutil.AVFrame* frame);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_set_color_range")]
        public static extern void av_frame_set_color_range(libavutil.AVFrame* frame, libavutil.AVColorRange val);

        /// <summary>
        /// Get the name of a colorspace.
        /// @return a static string identifying the colorspace; can be NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_colorspace_name")]
        public static extern sbyte* av_get_colorspace_name(libavutil.AVColorSpace val);

        /// <summary>
        /// Allocate an AVFrame and set its fields to default values.  The
        /// resulting
        /// struct must be freed using av_frame_free().
        /// 
        /// @return An AVFrame filled with default values or NULL on failure.
        /// 
        /// @note this only allocates the AVFrame itself, not the data buffers.
        /// Those
        /// must be allocated through other means, e.g. with av_frame_get_buffer()
        /// or
        /// manually.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_alloc")]
        public static extern libavutil.AVFrame* av_frame_alloc();

        /// <summary>
        /// Free the frame and any dynamically allocated objects in it,
        /// e.g. extended_data. If the frame is reference counted, it will be
        /// unreferenced first.
        /// 
        /// @param frame frame to be freed. The pointer will be set to NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_free")]
        public static extern void av_frame_free(libavutil.AVFrame** frame);

        /// <summary>
        /// Free the frame and any dynamically allocated objects in it,
        /// e.g. extended_data. If the frame is reference counted, it will be
        /// unreferenced first.
        /// 
        /// @param frame frame to be freed. The pointer will be set to NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_free")]
        public static extern void av_frame_free(ref libavutil.AVFrame* frame);

        /// <summary>
        /// Setup a new reference to the data described by a given frame.
        /// 
        /// Copy frame properties from src to dst and create a new reference for
        /// each
        /// AVBufferRef from src.
        /// 
        /// If src is not reference counted, new buffers are allocated and the data
        /// is
        /// copied.
        /// 
        /// @return 0 on success, a negative AVERROR on error
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_ref")]
        public static extern int av_frame_ref(libavutil.AVFrame* dst, libavutil.AVFrame* src);

        /// <summary>
        /// Create a new frame that references the same data as src.
        /// 
        /// This is a shortcut for av_frame_alloc()+av_frame_ref().
        /// 
        /// @return newly created AVFrame on success, NULL on error.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_clone")]
        public static extern libavutil.AVFrame* av_frame_clone(libavutil.AVFrame* src);

        /// <summary>
        /// Unreference all the buffers referenced by frame and reset the frame
        /// fields.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_unref")]
        public static extern void av_frame_unref(libavutil.AVFrame* frame);

        /// <summary>
        /// Move everythnig contained in src to dst and reset src.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_move_ref")]
        public static extern void av_frame_move_ref(libavutil.AVFrame* dst, libavutil.AVFrame* src);

        /// <summary>
        /// Allocate new buffer(s) for audio or video data.
        /// 
        /// The following fields must be set on frame before calling this function:
        /// - format (pixel format for video, sample format for audio)
        /// - width and height for video
        /// - nb_samples and channel_layout for audio
        /// 
        /// This function will fill AVFrame.data and AVFrame.buf arrays and, if
        /// necessary, allocate and fill AVFrame.extended_data and
        /// AVFrame.extended_buf.
        /// For planar formats, one buffer will be allocated for each plane.
        /// 
        /// @param frame frame in which to store the new buffers.
        /// @param align required buffer size alignment
        /// 
        /// @return 0 on success, a negative AVERROR on error.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_buffer")]
        public static extern int av_frame_get_buffer(libavutil.AVFrame* frame, int align);

        /// <summary>
        /// Check if the frame data is writable.
        /// 
        /// @return A positive value if the frame data is writable (which is true
        /// if and
        /// only if each of the underlying buffers has only one reference, namely
        /// the one
        /// stored in this frame). Return 0 otherwise.
        /// 
        /// If 1 is returned the answer is valid until av_buffer_ref() is called on
        /// any
        /// of the underlying AVBufferRefs (e.g. through av_frame_ref() or
        /// directly).
        /// 
        /// @see av_frame_make_writable(), av_buffer_is_writable()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_is_writable")]
        public static extern int av_frame_is_writable(libavutil.AVFrame* frame);

        /// <summary>
        /// Ensure that the frame data is writable, avoiding data copy if possible.
        /// 
        /// Do nothing if the frame is writable, allocate new buffers and copy the
        /// data
        /// if it is not.
        /// 
        /// @return 0 on success, a negative AVERROR on error.
        /// 
        /// @see av_frame_is_writable(), av_buffer_is_writable(),
        /// av_buffer_make_writable()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_make_writable")]
        public static extern int av_frame_make_writable(libavutil.AVFrame* frame);

        /// <summary>
        /// Copy only "metadata" fields from src to dst.
        /// 
        /// Metadata for the purpose of this function are those fields that do not
        /// affect
        /// the data layout in the buffers.  E.g. pts, sample rate (for audio) or
        /// sample
        /// aspect ratio (for video), but not width/height or channel layout.
        /// Side data is also copied.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_copy_props")]
        public static extern int av_frame_copy_props(libavutil.AVFrame* dst, libavutil.AVFrame* src);

        /// <summary>
        /// Get the buffer reference a given data plane is stored in.
        /// 
        /// @param plane index of the data plane of interest in
        /// frame->extended_data.
        /// 
        /// @return the buffer reference that contains the plane or NULL if the
        /// input
        /// frame is not valid.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_plane_buffer")]
        public static extern libavutil.AVBufferRef* av_frame_get_plane_buffer(libavutil.AVFrame* frame, int plane);

        /// <summary>
        /// Add a new side data to a frame.
        /// 
        /// @param frame a frame to which the side data should be added
        /// @param type type of the added side data
        /// @param size size of the side data
        /// 
        /// @return newly added side data on success, NULL on error
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_new_side_data")]
        public static extern libavutil.AVFrameSideData* av_frame_new_side_data(libavutil.AVFrame* frame, libavutil.AVFrameSideDataType type, int size);

        /// <summary>
        /// @return a pointer to the side data of a given type on success, NULL if
        /// there
        /// is no side data with such type in this frame.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_frame_get_side_data")]
        public static extern libavutil.AVFrameSideData* av_frame_get_side_data(libavutil.AVFrame* frame, libavutil.AVFrameSideDataType type);
    }
}
