//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace libavutil
{
    public unsafe partial class libavutil
    {
        /// <summary>
        /// Allocate a block of size bytes with alignment suitable for all
        /// memory accesses (including vectors if available on the CPU).
        /// @param size Size in bytes for the memory block to be allocated.
        /// @return Pointer to the allocated block, NULL if the block cannot
        /// be allocated.
        /// @see av_mallocz()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_malloc")]
        internal static extern global::System.IntPtr av_malloc(uint size);

        /// <summary>
        /// Allocate a block of size * nmemb bytes with av_malloc().
        /// @param nmemb Number of elements
        /// @param size Size of the single element
        /// @return Pointer to the allocated block, NULL if the block cannot
        /// be allocated.
        /// @see av_malloc()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_malloc_array")]
        internal static extern global::System.IntPtr av_malloc_array(uint nmemb, uint size);

        /// <summary>
        /// Allocate or reallocate a block of memory.
        /// If ptr is NULL and size > 0, allocate a new block. If
        /// size is zero, free the memory block pointed to by ptr.
        /// @param ptr Pointer to a memory block already allocated with
        /// av_realloc() or NULL.
        /// @param size Size in bytes of the memory block to be allocated or
        /// reallocated.
        /// @return Pointer to a newly-reallocated block or NULL if the block
        /// cannot be reallocated or the function is used to free the memory block.
        /// @warning Pointers originating from the av_malloc() family of functions
        /// must
        /// not be passed to av_realloc(). The former can be implemented using
        /// memalign() (or other functions), and there is no guarantee that
        /// pointers from such functions can be passed to realloc() at all.
        /// The situation is undefined according to POSIX and may crash with
        /// some libc implementations.
        /// @see av_fast_realloc()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_realloc")]
        internal static extern global::System.IntPtr av_realloc(global::System.IntPtr ptr, uint size);

        /// <summary>
        /// Allocate or reallocate a block of memory.
        /// This function does the same thing as av_realloc, except:
        /// - It takes two arguments and checks the result of the multiplication
        /// for
        /// integer overflow.
        /// - It frees the input block in case of failure, thus avoiding the memory
        /// leak with the classic "buf = realloc(buf); if (!buf) return -1;".
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_realloc_f")]
        internal static extern global::System.IntPtr av_realloc_f(global::System.IntPtr ptr, uint nelem, uint elsize);

        /// <summary>
        /// Allocate or reallocate a block of memory.
        /// If *ptr is NULL and size > 0, allocate a new block. If
        /// size is zero, free the memory block pointed to by ptr.
        /// @param   ptr Pointer to a pointer to a memory block already allocated
        /// with av_realloc(), or pointer to a pointer to NULL.
        /// The pointer is updated on success, or freed on failure.
        /// @param   size Size in bytes for the memory block to be allocated or
        /// reallocated
        /// @return  Zero on success, an AVERROR error code on failure.
        /// @warning Pointers originating from the av_malloc() family of functions
        /// must
        /// not be passed to av_reallocp(). The former can be implemented using
        /// memalign() (or other functions), and there is no guarantee that
        /// pointers from such functions can be passed to realloc() at all.
        /// The situation is undefined according to POSIX and may crash with
        /// some libc implementations.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_reallocp")]
        internal static extern int av_reallocp(global::System.IntPtr ptr, uint size);

        /// <summary>
        /// Allocate or reallocate an array.
        /// If ptr is NULL and nmemb > 0, allocate a new block. If
        /// nmemb is zero, free the memory block pointed to by ptr.
        /// @param ptr Pointer to a memory block already allocated with
        /// av_realloc() or NULL.
        /// @param nmemb Number of elements
        /// @param size Size of the single element
        /// @return Pointer to a newly-reallocated block or NULL if the block
        /// cannot be reallocated or the function is used to free the memory block.
        /// @warning Pointers originating from the av_malloc() family of functions
        /// must
        /// not be passed to av_realloc(). The former can be implemented using
        /// memalign() (or other functions), and there is no guarantee that
        /// pointers from such functions can be passed to realloc() at all.
        /// The situation is undefined according to POSIX and may crash with
        /// some libc implementations.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_realloc_array")]
        internal static extern global::System.IntPtr av_realloc_array(global::System.IntPtr ptr, uint nmemb, uint size);

        /// <summary>
        /// Allocate or reallocate an array through a pointer to a pointer.
        /// If *ptr is NULL and nmemb > 0, allocate a new block. If
        /// nmemb is zero, free the memory block pointed to by ptr.
        /// @param ptr Pointer to a pointer to a memory block already allocated
        /// with av_realloc(), or pointer to a pointer to NULL.
        /// The pointer is updated on success, or freed on failure.
        /// @param nmemb Number of elements
        /// @param size Size of the single element
        /// @return Zero on success, an AVERROR error code on failure.
        /// @warning Pointers originating from the av_malloc() family of functions
        /// must
        /// not be passed to av_realloc(). The former can be implemented using
        /// memalign() (or other functions), and there is no guarantee that
        /// pointers from such functions can be passed to realloc() at all.
        /// The situation is undefined according to POSIX and may crash with
        /// some libc implementations.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_reallocp_array")]
        internal static extern int av_reallocp_array(global::System.IntPtr ptr, uint nmemb, uint size);

        /// <summary>
        /// Free a memory block which has been allocated with av_malloc(z)() or
        /// av_realloc().
        /// @param ptr Pointer to the memory block which should be freed.
        /// @note ptr = NULL is explicitly allowed.
        /// @note It is recommended that you use av_freep() instead.
        /// @see av_freep()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_free")]
        internal static extern void av_free(global::System.IntPtr ptr);

        /// <summary>
        /// Allocate a block of size bytes with alignment suitable for all
        /// memory accesses (including vectors if available on the CPU) and
        /// zero all the bytes of the block.
        /// @param size Size in bytes for the memory block to be allocated.
        /// @return Pointer to the allocated block, NULL if it cannot be allocated.
        /// @see av_malloc()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_mallocz")]
        internal static extern global::System.IntPtr av_mallocz(uint size);

        /// <summary>
        /// Allocate a block of nmemb * size bytes with alignment suitable for all
        /// memory accesses (including vectors if available on the CPU) and
        /// zero all the bytes of the block.
        /// The allocation will fail if nmemb * size is greater than or equal
        /// to INT_MAX.
        /// @param nmemb
        /// @param size
        /// @return Pointer to the allocated block, NULL if it cannot be allocated.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_calloc")]
        internal static extern global::System.IntPtr av_calloc(uint nmemb, uint size);

        /// <summary>
        /// Allocate a block of size * nmemb bytes with av_mallocz().
        /// @param nmemb Number of elements
        /// @param size Size of the single element
        /// @return Pointer to the allocated block, NULL if the block cannot
        /// be allocated.
        /// @see av_mallocz()
        /// @see av_malloc_array()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_mallocz_array")]
        internal static extern global::System.IntPtr av_mallocz_array(uint nmemb, uint size);

        /// <summary>
        /// Duplicate the string s.
        /// @param s string to be duplicated
        /// @return Pointer to a newly-allocated string containing a
        /// copy of s or NULL if the string cannot be allocated.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_strdup")]
        internal static extern sbyte* av_strdup(global::System.IntPtr s);

        /// <summary>
        /// Duplicate the buffer p.
        /// @param p buffer to be duplicated
        /// @return Pointer to a newly allocated buffer containing a
        /// copy of p or NULL if the buffer cannot be allocated.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_memdup")]
        internal static extern global::System.IntPtr av_memdup(global::System.IntPtr p, uint size);

        /// <summary>
        /// Free a memory block which has been allocated with av_malloc(z)() or
        /// av_realloc() and set the pointer pointing to it to NULL.
        /// @param ptr Pointer to the pointer to the memory block which should
        /// be freed.
        /// @see av_free()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_freep")]
        internal static extern void av_freep(global::System.IntPtr ptr);

        /// <summary>
        /// Add an element to a dynamic array.
        /// 
        /// The array to grow is supposed to be an array of pointers to
        /// structures, and the element to add must be a pointer to an already
        /// allocated structure.
        /// 
        /// The array is reallocated when its size reaches powers of 2.
        /// Therefore, the amortized cost of adding an element is constant.
        /// 
        /// In case of success, the pointer to the array is updated in order to
        /// point to the new grown array, and the number pointed to by nb_ptr
        /// is incremented.
        /// In case of failure, the array is freed, *tab_ptr is set to NULL and
        /// nb_ptr is set to 0.
        /// 
        /// @param tab_ptr pointer to the array to grow
        /// @param nb_ptr  pointer to the number of elements in the array
        /// @param elem    element to add
        /// @see av_dynarray2_add()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_dynarray_add")]
        internal static extern void av_dynarray_add(global::System.IntPtr tab_ptr, int* nb_ptr, global::System.IntPtr elem);

        /// <summary>
        /// Add an element of size elem_size to a dynamic array.
        /// 
        /// The array is reallocated when its number of elements reaches powers of
        /// 2.
        /// Therefore, the amortized cost of adding an element is constant.
        /// 
        /// In case of success, the pointer to the array is updated in order to
        /// point to the new grown array, and the number pointed to by nb_ptr
        /// is incremented.
        /// In case of failure, the array is freed, *tab_ptr is set to NULL and
        /// nb_ptr is set to 0.
        /// 
        /// @param tab_ptr   pointer to the array to grow
        /// @param nb_ptr    pointer to the number of elements in the array
        /// @param elem_size size in bytes of the elements in the array
        /// @param elem_data pointer to the data of the element to add. If NULL,
        /// the space of
        /// the new added element is not filled.
        /// @return          pointer to the data of the element to copy in the new
        /// allocated space.
        /// If NULL, the new allocated space is left uninitialized."
        /// @see av_dynarray_add()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_dynarray2_add")]
        internal static extern global::System.IntPtr av_dynarray2_add(global::System.IntPtr tab_ptr, int* nb_ptr, uint elem_size, byte* elem_data);

        /// <summary>
        /// Multiply two size_t values checking for overflow.
        /// @return  0 if success, AVERROR(EINVAL) if overflow.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_size_mult")]
        internal static extern int av_size_mult(uint a, uint b, uint* r);

        /// <summary>
        /// Set the maximum size that may me allocated in one block.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_max_alloc")]
        internal static extern void av_max_alloc(uint max);

        /// <summary>
        /// deliberately overlapping memcpy implementation
        /// @param dst destination buffer
        /// @param back how many bytes back we start (the initial size of the
        /// overlapping window), must be > 0
        /// @param cnt number of bytes to copy, must be >= 0
        /// 
        /// cnt > back is valid, this will copy the bytes we just copied,
        /// thus creating a repeating pattern with a period length of back.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport("avutil-if-52.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            EntryPoint="av_memcpy_backptr")]
        internal static extern void av_memcpy_backptr(byte* dst, int back, int cnt);
    }
}
