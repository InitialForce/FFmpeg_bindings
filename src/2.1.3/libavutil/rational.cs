//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FFmpeg
{
    public unsafe static partial class libavutil
    {
        /// <summary>
        /// rational number numerator/denominator
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVRational
        {
            /// <summary>
            /// numerator
            /// </summary>
            public int num;

            /// <summary>
            /// denominator
            /// </summary>
            public int den;
        }

        /// <summary>
        /// Compare two rationals.
        /// @param a first rational
        /// @param b second rational
        /// @return 0 if a==b, 1 if a>b, -1 if a<b, and INT_MIN if one of the
        /// values is of the form 0/0
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_cmp_q")]
        public static extern int av_cmp_q(libavutil.AVRational a, libavutil.AVRational b);

        /// <summary>
        /// Convert rational to double.
        /// @param a rational to convert
        /// @return (double) a
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_q2d")]
        public static extern double av_q2d(libavutil.AVRational a);

        /// <summary>
        /// Reduce a fraction.
        /// This is useful for framerate calculations.
        /// @param dst_num destination numerator
        /// @param dst_den destination denominator
        /// @param num source numerator
        /// @param den source denominator
        /// @param max the maximum allowed for dst_num & dst_den
        /// @return 1 if exact, 0 otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_reduce")]
        public static extern int av_reduce(int* dst_num, int* dst_den, long num, long den, long max);

        /// <summary>
        /// Multiply two rationals.
        /// @param b first rational
        /// @param c second rational
        /// @return b*c
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_mul_q")]
        public static extern libavutil.AVRational av_mul_q(libavutil.AVRational b, libavutil.AVRational c);

        /// <summary>
        /// Divide one rational by another.
        /// @param b first rational
        /// @param c second rational
        /// @return b/c
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_div_q")]
        public static extern libavutil.AVRational av_div_q(libavutil.AVRational b, libavutil.AVRational c);

        /// <summary>
        /// Add two rationals.
        /// @param b first rational
        /// @param c second rational
        /// @return b+c
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_add_q")]
        public static extern libavutil.AVRational av_add_q(libavutil.AVRational b, libavutil.AVRational c);

        /// <summary>
        /// Subtract one rational from another.
        /// @param b first rational
        /// @param c second rational
        /// @return b-c
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_sub_q")]
        public static extern libavutil.AVRational av_sub_q(libavutil.AVRational b, libavutil.AVRational c);

        /// <summary>
        /// Invert a rational.
        /// @param q value
        /// @return 1 / q
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_inv_q")]
        public static extern libavutil.AVRational av_inv_q(libavutil.AVRational q);

        /// <summary>
        /// Convert a double precision floating point number to a rational.
        /// inf is expressed as {1,0} or {-1,0} depending on the sign.
        /// 
        /// @param d double to convert
        /// @param max the maximum allowed numerator and denominator
        /// @return (AVRational) d
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_d2q")]
        public static extern libavutil.AVRational av_d2q(double d, int max);

        /// <summary>
        /// @return 1 if q1 is nearer to q than q2, -1 if q2 is nearer
        /// than q1, 0 if they have the same distance.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_nearer_q")]
        public static extern int av_nearer_q(libavutil.AVRational q, libavutil.AVRational q1, libavutil.AVRational q2);

        /// <summary>
        /// Find the nearest value in q_list to q.
        /// @param q_list an array of rationals terminated by {0, 0}
        /// @return the index of the nearest value found in the array
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_find_nearest_q_idx")]
        public static extern int av_find_nearest_q_idx(libavutil.AVRational q, libavutil.AVRational* q_list);
    }
}
