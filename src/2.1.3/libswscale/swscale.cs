//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using FFmpeg;

namespace FFmpeg
{
    public unsafe static partial class libswscale
    {
        public const sbyte SWS_FAST_BILINEAR = 1;

        public const sbyte SWS_BILINEAR = 2;

        public const sbyte SWS_BICUBIC = 4;

        public const sbyte SWS_X = 8;

        public const sbyte SWS_POINT = 10;

        public const sbyte SWS_AREA = 20;

        public const sbyte SWS_BICUBLIN = 40;

        public const byte SWS_GAUSS = 80;

        public const short SWS_SINC = 100;

        public const short SWS_LANCZOS = 200;

        public const short SWS_SPLINE = 400;

        public const int SWS_SRC_V_CHR_DROP_MASK = 30000;

        public const sbyte SWS_SRC_V_CHR_DROP_SHIFT = 16;

        public const int SWS_PARAM_DEFAULT = 123456;

        public const short SWS_PRINT_INFO = 1000;

        public const short SWS_FULL_CHR_H_INT = 2000;

        public const short SWS_FULL_CHR_H_INP = 4000;

        public const ushort SWS_DIRECT_BGR = 8000;

        public const int SWS_ACCURATE_RND = 40000;

        public const int SWS_BITEXACT = 80000;

        public const int SWS_ERROR_DIFFUSION = 800000;

        public const uint SWS_CPU_CAPS_MMX = 80000000;

        public const int SWS_CPU_CAPS_MMXEXT = 20000000;

        public const int SWS_CPU_CAPS_MMX2 = 20000000;

        public const int SWS_CPU_CAPS_3DNOW = 40000000;

        public const int SWS_CPU_CAPS_ALTIVEC = 10000000;

        public const int SWS_CPU_CAPS_BFIN = 1000000;

        public const int SWS_CPU_CAPS_SSE2 = 2000000;

        public const double SWS_MAX_REDUCE_CUTOFF = 0.002D;

        public const sbyte SWS_CS_ITU709 = 1;

        public const sbyte SWS_CS_FCC = 4;

        public const sbyte SWS_CS_ITU601 = 5;

        public const sbyte SWS_CS_ITU624 = 5;

        public const sbyte SWS_CS_SMPTE170M = 5;

        public const sbyte SWS_CS_SMPTE240M = 7;

        public const sbyte SWS_CS_DEFAULT = 5;

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct SwsVector
        {
            /// <summary>
            /// pointer to the list of coefficients
            /// </summary>
            public double* coeff;

            /// <summary>
            /// number of coefficients in the vector
            /// </summary>
            public int length;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct SwsFilter
        {
            public libswscale.SwsVector* lumH;

            public libswscale.SwsVector* lumV;

            public libswscale.SwsVector* chrH;

            public libswscale.SwsVector* chrV;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct SwsContext
        {
        }

        /// <summary>
        /// Return the LIBSWSCALE_VERSION_INT constant.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="swscale_version")]
        public static extern uint swscale_version();

        /// <summary>
        /// Return the libswscale build-time configuration.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="swscale_configuration")]
        public static extern sbyte* swscale_configuration();

        /// <summary>
        /// Return the libswscale license.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="swscale_license")]
        public static extern sbyte* swscale_license();

        /// <summary>
        /// Return a pointer to yuv<->rgb coefficients for the given colorspace
        /// suitable for sws_setColorspaceDetails().
        /// 
        /// @param colorspace One of the SWS_CS_* macros. If invalid,
        /// SWS_CS_DEFAULT is used.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_getCoefficients")]
        public static extern int* sws_getCoefficients(int colorspace);

        /// <summary>
        /// Return a positive value if pix_fmt is a supported input format, 0
        /// otherwise.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_isSupportedInput")]
        public static extern int sws_isSupportedInput(libavutil.AVPixelFormat pix_fmt);

        /// <summary>
        /// Return a positive value if pix_fmt is a supported output format, 0
        /// otherwise.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_isSupportedOutput")]
        public static extern int sws_isSupportedOutput(libavutil.AVPixelFormat pix_fmt);

        /// <summary>
        /// @param[in]  pix_fmt the pixel format
        /// @return a positive value if an endianness conversion for pix_fmt is
        /// supported, 0 otherwise.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_isSupportedEndiannessConversion")]
        public static extern int sws_isSupportedEndiannessConversion(libavutil.AVPixelFormat pix_fmt);

        /// <summary>
        /// Allocate an empty SwsContext. This must be filled and passed to
        /// sws_init_context(). For filling see AVOptions, options.c and
        /// sws_setColorspaceDetails().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_alloc_context")]
        public static extern libswscale.SwsContext* sws_alloc_context();

        /// <summary>
        /// Initialize the swscaler context sws_context.
        /// 
        /// @return zero or positive value on success, a negative value on
        /// error
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_init_context")]
        public static extern int sws_init_context(libswscale.SwsContext* sws_context, libswscale.SwsFilter* srcFilter, libswscale.SwsFilter* dstFilter);

        /// <summary>
        /// Free the swscaler context swsContext.
        /// If swsContext is NULL, then does nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_freeContext")]
        public static extern void sws_freeContext(libswscale.SwsContext* swsContext);

        /// <summary>
        /// Allocate and return an SwsContext. You need it to perform
        /// scaling/conversion operations using sws_scale().
        /// 
        /// @param srcW the width of the source image
        /// @param srcH the height of the source image
        /// @param srcFormat the source image format
        /// @param dstW the width of the destination image
        /// @param dstH the height of the destination image
        /// @param dstFormat the destination image format
        /// @param flags specify which algorithm and options to use for rescaling
        /// @return a pointer to an allocated context, or NULL in case of error
        /// @note this function is to be removed after a saner alternative is
        /// written
        /// @deprecated Use sws_getCachedContext() instead.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_getContext")]
        public static extern libswscale.SwsContext* sws_getContext(int srcW, int srcH, libavutil.AVPixelFormat srcFormat, int dstW, int dstH, libavutil.AVPixelFormat dstFormat, int flags, libswscale.SwsFilter* srcFilter, libswscale.SwsFilter* dstFilter, double* param);

        /// <summary>
        /// Scale the image slice in srcSlice and put the resulting scaled
        /// slice in the image in dst. A slice is a sequence of consecutive
        /// rows in an image.
        /// 
        /// Slices have to be provided in sequential order, either in
        /// top-bottom or bottom-top order. If slices are provided in
        /// non-sequential order the behavior of the function is undefined.
        /// 
        /// @param c         the scaling context previously created with
        /// sws_getContext()
        /// @param srcSlice  the array containing the pointers to the planes of
        /// the source slice
        /// @param srcStride the array containing the strides for each plane of
        /// the source image
        /// @param srcSliceY the position in the source image of the slice to
        /// process, that is the number (counted starting from
        /// zero) in the image of the first row of the slice
        /// @param srcSliceH the height of the source slice, that is the number
        /// of rows in the slice
        /// @param dst       the array containing the pointers to the planes of
        /// the destination image
        /// @param dstStride the array containing the strides for each plane of
        /// the destination image
        /// @return          the height of the output slice
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_scale")]
        public static extern int sws_scale(libswscale.SwsContext* c, byte** srcSlice, int* srcStride, int srcSliceY, int srcSliceH, byte** dst, int* dstStride);

        /// <summary>
        /// @param dstRange flag indicating the while-black range of the output
        /// (1=jpeg / 0=mpeg)
        /// @param srcRange flag indicating the while-black range of the input
        /// (1=jpeg / 0=mpeg)
        /// @param table the yuv2rgb coefficients describing the output yuv space,
        /// normally ff_yuv2rgb_coeffs[x]
        /// @param inv_table the yuv2rgb coefficients describing the input yuv
        /// space, normally ff_yuv2rgb_coeffs[x]
        /// @param brightness 16.16 fixed point brightness correction
        /// @param contrast 16.16 fixed point contrast correction
        /// @param saturation 16.16 fixed point saturation correction
        /// @return -1 if not supported
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_setColorspaceDetails")]
        public static extern int sws_setColorspaceDetails(libswscale.SwsContext* c, int* inv_table, int srcRange, int* table, int dstRange, int brightness, int contrast, int saturation);

        /// <summary>
        /// @return -1 if not supported
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_getColorspaceDetails")]
        public static extern int sws_getColorspaceDetails(libswscale.SwsContext* c, int** inv_table, int* srcRange, int** table, int* dstRange, int* brightness, int* contrast, int* saturation);

        /// <summary>
        /// @return -1 if not supported
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_getColorspaceDetails")]
        public static extern int sws_getColorspaceDetails(libswscale.SwsContext* c, ref int* inv_table, int* srcRange, ref int* table, int* dstRange, int* brightness, int* contrast, int* saturation);

        /// <summary>
        /// Allocate and return an uninitialized vector with length coefficients.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_allocVec")]
        public static extern libswscale.SwsVector* sws_allocVec(int length);

        /// <summary>
        /// Return a normalized Gaussian curve used to filter stuff
        /// quality = 3 is high quality, lower is lower quality.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_getGaussianVec")]
        public static extern libswscale.SwsVector* sws_getGaussianVec(double variance, double quality);

        /// <summary>
        /// Allocate and return a vector with length coefficients, all
        /// with the same value c.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_getConstVec")]
        public static extern libswscale.SwsVector* sws_getConstVec(double c, int length);

        /// <summary>
        /// Allocate and return a vector with just one coefficient, with
        /// value 1.0.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_getIdentityVec")]
        public static extern libswscale.SwsVector* sws_getIdentityVec();

        /// <summary>
        /// Scale all the coefficients of a by the scalar value.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_scaleVec")]
        public static extern void sws_scaleVec(libswscale.SwsVector* a, double scalar);

        /// <summary>
        /// Scale all the coefficients of a so that their sum equals height.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_normalizeVec")]
        public static extern void sws_normalizeVec(libswscale.SwsVector* a, double height);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_convVec")]
        public static extern void sws_convVec(libswscale.SwsVector* a, libswscale.SwsVector* b);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_addVec")]
        public static extern void sws_addVec(libswscale.SwsVector* a, libswscale.SwsVector* b);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_subVec")]
        public static extern void sws_subVec(libswscale.SwsVector* a, libswscale.SwsVector* b);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_shiftVec")]
        public static extern void sws_shiftVec(libswscale.SwsVector* a, int shift);

        /// <summary>
        /// Allocate and return a clone of the vector a, that is a vector
        /// with the same coefficients as a.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_cloneVec")]
        public static extern libswscale.SwsVector* sws_cloneVec(libswscale.SwsVector* a);

        /// <summary>
        /// Print with av_log() a textual representation of the vector a
        /// if log_level <= av_log_level.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_printVec2")]
        public static extern void sws_printVec2(libswscale.SwsVector* a, libavutil.AVClass* log_ctx, int log_level);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_freeVec")]
        public static extern void sws_freeVec(libswscale.SwsVector* a);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_getDefaultFilter")]
        public static extern libswscale.SwsFilter* sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_freeFilter")]
        public static extern void sws_freeFilter(libswscale.SwsFilter* filter);

        /// <summary>
        /// Check if context can be reused, otherwise reallocate a new one.
        /// 
        /// If context is NULL, just calls sws_getContext() to get a new
        /// context. Otherwise, checks if the parameters are the ones already
        /// saved in context. If that is the case, returns the current
        /// context. Otherwise, frees context and gets a new context with
        /// the new parameters.
        /// 
        /// Be warned that srcFilter and dstFilter are not checked, they
        /// are assumed to remain the same.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_getCachedContext")]
        public static extern libswscale.SwsContext* sws_getCachedContext(libswscale.SwsContext* context, int srcW, int srcH, libavutil.AVPixelFormat srcFormat, int dstW, int dstH, libavutil.AVPixelFormat dstFormat, int flags, libswscale.SwsFilter* srcFilter, libswscale.SwsFilter* dstFilter, double* param);

        /// <summary>
        /// Convert an 8-bit paletted frame into a frame with a color depth of 32
        /// bits.
        /// 
        /// The output frame will have the same packed format as the palette.
        /// 
        /// @param src        source frame buffer
        /// @param dst        destination frame buffer
        /// @param num_pixels number of pixels to convert
        /// @param palette    array with [256] entries, which must match color
        /// arrangement (RGB or BGR) of src
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_convertPalette8ToPacked32")]
        public static extern void sws_convertPalette8ToPacked32(byte* src, byte* dst, int num_pixels, byte* palette);

        /// <summary>
        /// Convert an 8-bit paletted frame into a frame with a color depth of 24
        /// bits.
        /// 
        /// With the palette format "ABCD", the destination frame ends up with the
        /// format "ABC".
        /// 
        /// @param src        source frame buffer
        /// @param dst        destination frame buffer
        /// @param num_pixels number of pixels to convert
        /// @param palette    array with [256] entries, which must match color
        /// arrangement (RGB or BGR) of src
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_convertPalette8ToPacked24")]
        public static extern void sws_convertPalette8ToPacked24(byte* src, byte* dst, int num_pixels, byte* palette);

        /// <summary>
        /// Get the AVClass for swsContext. It can be used in combination with
        /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
        /// 
        /// @see av_opt_find().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(SWSCALE_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="sws_get_class")]
        public static extern libavutil.AVClass* sws_get_class();
    }
}
