//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FFmpeg
{
    public unsafe static partial class libavutil
    {
        public const sbyte AV_OPT_FLAG_ENCODING_PARAM = 1;

        public const sbyte AV_OPT_FLAG_DECODING_PARAM = 2;

        public const sbyte AV_OPT_FLAG_METADATA = 4;

        public const sbyte AV_OPT_FLAG_AUDIO_PARAM = 8;

        public const sbyte AV_OPT_FLAG_VIDEO_PARAM = 16;

        public const sbyte AV_OPT_FLAG_SUBTITLE_PARAM = 32;

        public const sbyte AV_OPT_FLAG_EXPORT = 64;

        public const byte AV_OPT_FLAG_READONLY = 128;

        public const sbyte AV_OPT_SEARCH_CHILDREN = 1;

        public const sbyte AV_OPT_SEARCH_FAKE_OBJ = 2;

        /// <summary>
        /// @defgroup avoptions AVOptions
        /// @ingroup lavu_data
        /// @{
        /// AVOptions provide a generic system to declare options on arbitrary
        /// structs
        /// ("objects"). An option can have a help text, a type and a range of
        /// possible
        /// values. Options may then be enumerated, read and written to.
        /// 
        /// @section avoptions_implement Implementing AVOptions
        /// This section describes how to add AVOptions capabilities to a struct.
        /// 
        /// All AVOptions-related information is stored in an AVClass. Therefore
        /// the first member of the struct should be a pointer to an AVClass
        /// describing it.
        /// The option field of the AVClass must be set to a NULL-terminated static
        /// array
        /// of AVOptions. Each AVOption must have a non-empty name, a type, a
        /// default
        /// value and for number-type AVOptions also a range of allowed values. It
        /// must
        /// also declare an offset in bytes from the start of the struct, where the
        /// field
        /// associated with this AVOption is located. Other fields in the AVOption
        /// struct
        /// should also be set when applicable, but are not required.
        /// 
        /// The following example illustrates an AVOptions-enabled struct:
        /// @code
        /// typedef struct test_struct {
        /// AVClass *class;
        /// int      int_opt;
        /// char    *str_opt;
        /// uint8_t *bin_opt;
        /// int      bin_len;
        /// } test_struct;
        /// 
        /// static const AVOption test_options[] = {
        /// { "test_int", "This is a test option of int type.",
        /// offsetof(test_struct, int_opt),
        /// AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },
        /// { "test_str", "This is a test option of string type.",
        /// offsetof(test_struct, str_opt),
        /// AV_OPT_TYPE_STRING },
        /// { "test_bin", "This is a test option of binary type.",
        /// offsetof(test_struct, bin_opt),
        /// AV_OPT_TYPE_BINARY },
        /// { NULL },
        /// };
        /// 
        /// static const AVClass test_class = {
        /// .class_name = "test class",
        /// .item_name  = av_default_item_name,
        /// .option     = test_options,
        /// .version    = LIBAVUTIL_VERSION_INT,
        /// };
        /// @endcode
        /// 
        /// Next, when allocating your struct, you must ensure that the AVClass
        /// pointer
        /// is set to the correct value. Then, av_opt_set_defaults() can be called
        /// to
        /// initialize defaults. After that the struct is ready to be used with the
        /// AVOptions API.
        /// 
        /// When cleaning up, you may use the av_opt_free() function to
        /// automatically
        /// free all the allocated string and binary options.
        /// 
        /// Continuing with the above example:
        /// 
        /// @code
        /// test_struct *alloc_test_struct(void)
        /// {
        /// test_struct *ret = av_malloc(sizeof(*ret));
        /// ret->class = &test_class;
        /// av_opt_set_defaults(ret);
        /// return ret;
        /// }
        /// void free_test_struct(test_struct **foo)
        /// {
        /// av_opt_free(*foo);
        /// av_freep(foo);
        /// }
        /// @endcode
        /// 
        /// @subsection avoptions_implement_nesting Nesting
        /// It may happen that an AVOptions-enabled struct contains another
        /// AVOptions-enabled struct as a member (e.g. AVCodecContext in
        /// libavcodec exports generic options, while its priv_data field exports
        /// codec-specific options). In such a case, it is possible to set up the
        /// parent struct to export a child's options. To do that, simply
        /// implement AVClass.child_next() and AVClass.child_class_next() in the
        /// parent struct's AVClass.
        /// Assuming that the test_struct from above now also contains a
        /// child_struct field:
        /// 
        /// @code
        /// typedef struct child_struct {
        /// AVClass *class;
        /// int flags_opt;
        /// } child_struct;
        /// static const AVOption child_opts[] = {
        /// { "test_flags", "This is a test option of flags type.",
        /// offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 },
        /// INT_MIN, INT_MAX },
        /// { NULL },
        /// };
        /// static const AVClass child_class = {
        /// .class_name = "child class",
        /// .item_name  = av_default_item_name,
        /// .option     = child_opts,
        /// .version    = LIBAVUTIL_VERSION_INT,
        /// };
        /// 
        /// void *child_next(void *obj, void *prev)
        /// {
        /// test_struct *t = obj;
        /// if (!prev && t->child_struct)
        /// return t->child_struct;
        /// return NULL
        /// }
        /// const AVClass child_class_next(const AVClass *prev)
        /// {
        /// return prev ? NULL : &child_class;
        /// }
        /// @endcode
        /// Putting child_next() and child_class_next() as defined above into
        /// test_class will now make child_struct's options accessible through
        /// test_struct (again, proper setup as described above needs to be done on
        /// child_struct right after it is created).
        /// 
        /// From the above example it might not be clear why both child_next()
        /// and child_class_next() are needed. The distinction is that child_next()
        /// iterates over actually existing objects, while child_class_next()
        /// iterates over all possible child classes. E.g. if an AVCodecContext
        /// was initialized to use a codec which has private options, then its
        /// child_next() will return AVCodecContext.priv_data and finish
        /// iterating. OTOH child_class_next() on AVCodecContext.av_class will
        /// iterate over all available codecs with private options.
        /// 
        /// @subsection avoptions_implement_named_constants Named constants
        /// It is possible to create named constants for options. Simply set the
        /// unit
        /// field of the option the constants should apply to a string and
        /// create the constants themselves as options of type AV_OPT_TYPE_CONST
        /// with their unit field set to the same string.
        /// Their default_val field should contain the value of the named
        /// constant.
        /// For example, to add some named constants for the test_flags option
        /// above, put the following into the child_opts array:
        /// @code
        /// { "test_flags", "This is a test option of flags type.",
        /// offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 },
        /// INT_MIN, INT_MAX, "test_unit" },
        /// { "flag1", "This is a flag with value 16", 0, AV_OPT_TYPE_CONST, { .i64
        /// = 16 }, 0, 0, "test_unit" },
        /// @endcode
        /// 
        /// @section avoptions_use Using AVOptions
        /// This section deals with accessing options in an AVOptions-enabled
        /// struct.
        /// Such structs in FFmpeg are e.g. AVCodecContext in libavcodec or
        /// AVFormatContext in libavformat.
        /// 
        /// @subsection avoptions_use_examine Examining AVOptions
        /// The basic functions for examining options are av_opt_next(), which
        /// iterates
        /// over all options defined for one object, and av_opt_find(), which
        /// searches
        /// for an option with the given name.
        /// 
        /// The situation is more complicated with nesting. An AVOptions-enabled
        /// struct
        /// may have AVOptions-enabled children. Passing the AV_OPT_SEARCH_CHILDREN
        /// flag
        /// to av_opt_find() will make the function search children recursively.
        /// 
        /// For enumerating there are basically two cases. The first is when you
        /// want to
        /// get all options that may potentially exist on the struct and its
        /// children
        /// (e.g.  when constructing documentation). In that case you should call
        /// av_opt_child_class_next() recursively on the parent struct's AVClass.
        /// The
        /// second case is when you have an already initialized struct with all its
        /// children and you want to get all options that can be actually written
        /// or read
        /// from it. In that case you should call av_opt_child_next() recursively
        /// (and
        /// av_opt_next() on each result).
        /// 
        /// @subsection avoptions_use_get_set Reading and writing AVOptions
        /// When setting options, you often have a string read directly from the
        /// user. In such a case, simply passing it to av_opt_set() is enough. For
        /// non-string type options, av_opt_set() will parse the string according
        /// to the
        /// option type.
        /// 
        /// Similarly av_opt_get() will read any option type and convert it to a
        /// string
        /// which will be returned. Do not forget that the string is allocated, so
        /// you
        /// have to free it with av_free().
        /// 
        /// In some cases it may be more convenient to put all options into an
        /// AVDictionary and call av_opt_set_dict() on it. A specific case of this
        /// are the format/codec open functions in lavf/lavc which take a
        /// dictionary
        /// filled with option as a parameter. This allows to set some options
        /// that cannot be set otherwise, since e.g. the input file format is not
        /// known
        /// before the file is actually opened.
        /// </summary>
        public enum AVOptionType
        {
            AV_OPT_TYPE_FLAGS = 0,
            AV_OPT_TYPE_INT = 1,
            AV_OPT_TYPE_INT64 = 2,
            AV_OPT_TYPE_DOUBLE = 3,
            AV_OPT_TYPE_FLOAT = 4,
            AV_OPT_TYPE_STRING = 5,
            AV_OPT_TYPE_RATIONAL = 6,
            /// <summary>offset must point to a pointer immediately followed by an int for the length</summary>
            AV_OPT_TYPE_BINARY = 7,
            AV_OPT_TYPE_CONST = 128,
            /// <summary>offset must point to two consecutive integers</summary>
            AV_OPT_TYPE_IMAGE_SIZE = 1397316165,
            AV_OPT_TYPE_PIXEL_FMT = 1346784596,
            AV_OPT_TYPE_SAMPLE_FMT = 1397116244,
            /// <summary>offset must point to AVRational</summary>
            AV_OPT_TYPE_VIDEO_RATE = 1448231252,
            AV_OPT_TYPE_DURATION = 1146442272,
            AV_OPT_TYPE_COLOR = 1129270354,
            AV_OPT_TYPE_CHANNEL_LAYOUT = 1128811585,
            FF_OPT_TYPE_FLAGS = 0,
            FF_OPT_TYPE_INT = 1,
            FF_OPT_TYPE_INT64 = 2,
            FF_OPT_TYPE_DOUBLE = 3,
            FF_OPT_TYPE_FLOAT = 4,
            FF_OPT_TYPE_STRING = 5,
            FF_OPT_TYPE_RATIONAL = 6,
            /// <summary>offset must point to a pointer immediately followed by an int for the length</summary>
            FF_OPT_TYPE_BINARY = 7,
            FF_OPT_TYPE_CONST = 128
        }

        public enum AV_OPT_FLAG_IMPLICIT_KEY
        {
            /// <summary>Accept to parse a value without a key; the key will then be returned as NULL.</summary>
            AV_OPT_FLAG_IMPLICIT_KEY = 1
        }

        /// <summary>
        /// AVOption
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVOption
        {
            public sbyte* name;

            /// <summary>
            /// short English help text
            /// @todo What about other languages?
            /// </summary>
            public sbyte* help;

            /// <summary>
            /// The offset relative to the context structure where the option
            /// value is stored. It should be 0 for named constants.
            /// </summary>
            public int offset;

            public libavutil.AVOptionType type;

            public libavutil.AVOption.AVOption_anon default_val;

            /// <summary>
            /// minimum valid value for the option
            /// </summary>
            public double min;

            /// <summary>
            /// maximum valid value for the option
            /// </summary>
            public double max;

            public int flags;

            /// <summary>
            /// The logical unit to which the option belongs. Non-constant
            /// options and corresponding named constants share the same
            /// unit. May be NULL.
            /// </summary>
            public sbyte* unit;

            /// <summary>
            /// the default value for scalar options
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public unsafe partial struct AVOption_anon
            {
                public long i64;

                public double dbl;

                public sbyte* str;

                public libavutil.AVRational q;
            }
        }

        /// <summary>
        /// A single allowed range of values, or a single allowed value.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVOptionRange
        {
            public sbyte* str;

            /// <summary>
            /// For string ranges this represents the min/max length, for dimensions
            /// this represents the min/max pixel count
            /// </summary>
            public double value_min;

            /// <summary>
            /// For string ranges this represents the min/max length, for dimensions
            /// this represents the min/max pixel count
            /// </summary>
            public double value_max;

            /// <summary>
            /// For string this represents the unicode range for chars, 0-127 limits to
            /// ASCII
            /// </summary>
            public double component_min;

            /// <summary>
            /// For string this represents the unicode range for chars, 0-127 limits to
            /// ASCII
            /// </summary>
            public double component_max;

            /// <summary>
            /// if set to 1 the struct encodes a range, if set to 0 a single value
            /// </summary>
            public int is_range;
        }

        /// <summary>
        /// List of AVOptionRange structs
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVOptionRanges
        {
            public libavutil.AVOptionRange** range;

            public int nb_ranges;
        }

        /// <summary>
        /// Look for an option in obj. Look only for the options which
        /// have the flags set as specified in mask and flags (that is,
        /// for which it is the case that (opt->flags & mask) == flags).
        /// 
        /// @param[in] obj a pointer to a struct whose first element is a
        /// pointer to an AVClass
        /// @param[in] name the name of the option to look for
        /// @param[in] unit the unit of the option to look for, or any if NULL
        /// @return a pointer to the option found, or NULL if no option
        /// has been found
        /// 
        /// @deprecated use av_opt_find.
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_find_opt")]
        public static extern libavutil.AVOption* av_find_opt(void* obj, string name, string unit, int mask, int flags);

        /// <summary>
        /// Set the field of obj with the given name to value.
        /// 
        /// @param[in] obj A struct whose first element is a pointer to an
        /// AVClass.
        /// @param[in] name the name of the field to set
        /// @param[in] val The value to set. If the field is not of a string
        /// type, then the given string is parsed.
        /// SI postfixes and some named scalars are supported.
        /// If the field is of a numeric type, it has to be a numeric or named
        /// scalar. Behavior with more than one scalar and +- infix operators
        /// is undefined.
        /// If the field is of a flags type, it has to be a sequence of numeric
        /// scalars or named flags separated by '+' or '-'. Prefixing a flag
        /// with '+' causes it to be set without affecting the other flags;
        /// similarly, '-' unsets a flag.
        /// @param[out] o_out if non-NULL put here a pointer to the AVOption
        /// found
        /// @param alloc this parameter is currently ignored
        /// @return 0 if the value has been set, or an AVERROR code in case of
        /// error:
        /// AVERROR_OPTION_NOT_FOUND if no matching option exists
        /// AVERROR(ERANGE) if the value is out of range
        /// AVERROR(EINVAL) if the value is not valid
        /// @deprecated use av_opt_set()
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_set_string3")]
        public static extern int av_set_string3(void* obj, string name, string val, int alloc, libavutil.AVOption** o_out);

        /// <summary>
        /// Set the field of obj with the given name to value.
        /// 
        /// @param[in] obj A struct whose first element is a pointer to an
        /// AVClass.
        /// @param[in] name the name of the field to set
        /// @param[in] val The value to set. If the field is not of a string
        /// type, then the given string is parsed.
        /// SI postfixes and some named scalars are supported.
        /// If the field is of a numeric type, it has to be a numeric or named
        /// scalar. Behavior with more than one scalar and +- infix operators
        /// is undefined.
        /// If the field is of a flags type, it has to be a sequence of numeric
        /// scalars or named flags separated by '+' or '-'. Prefixing a flag
        /// with '+' causes it to be set without affecting the other flags;
        /// similarly, '-' unsets a flag.
        /// @param[out] o_out if non-NULL put here a pointer to the AVOption
        /// found
        /// @param alloc this parameter is currently ignored
        /// @return 0 if the value has been set, or an AVERROR code in case of
        /// error:
        /// AVERROR_OPTION_NOT_FOUND if no matching option exists
        /// AVERROR(ERANGE) if the value is out of range
        /// AVERROR(EINVAL) if the value is not valid
        /// @deprecated use av_opt_set()
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_set_string3")]
        public static extern int av_set_string3(void* obj, string name, string val, int alloc, ref libavutil.AVOption* o_out);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_set_double")]
        public static extern libavutil.AVOption* av_set_double(void* obj, string name, double n);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_set_q")]
        public static extern libavutil.AVOption* av_set_q(void* obj, string name, libavutil.AVRational n);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_set_int")]
        public static extern libavutil.AVOption* av_set_int(void* obj, string name, long n);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_double")]
        public static extern double av_get_double(void* obj, string name, libavutil.AVOption** o_out);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_double")]
        public static extern double av_get_double(void* obj, string name, ref libavutil.AVOption* o_out);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_q")]
        public static extern libavutil.AVRational av_get_q(void* obj, string name, libavutil.AVOption** o_out);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_q")]
        public static extern libavutil.AVRational av_get_q(void* obj, string name, ref libavutil.AVOption* o_out);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_int")]
        public static extern long av_get_int(void* obj, string name, libavutil.AVOption** o_out);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_int")]
        public static extern long av_get_int(void* obj, string name, ref libavutil.AVOption* o_out);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_string")]
        public static extern sbyte* av_get_string(void* obj, string name, libavutil.AVOption** o_out, System.Text.StringBuilder buf, int buf_len);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_string")]
        public static extern sbyte* av_get_string(void* obj, string name, ref libavutil.AVOption* o_out, System.Text.StringBuilder buf, int buf_len);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_next_option")]
        public static extern libavutil.AVOption* av_next_option(void* obj, libavutil.AVOption* last);

        /// <summary>
        /// Show the obj options.
        /// 
        /// @param req_flags requested flags for the options to show. Show only the
        /// options for which it is opt->flags & req_flags.
        /// @param rej_flags rejected flags for the options to show. Show only the
        /// options for which it is !(opt->flags & req_flags).
        /// @param av_log_obj log context to use for showing the options
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_show2")]
        public static extern int av_opt_show2(void* obj, void* av_log_obj, int req_flags, int rej_flags);

        /// <summary>
        /// Set the values of all AVOption fields to their default values.
        /// 
        /// @param s an AVOption-enabled struct (its first member must be a pointer
        /// to AVClass)
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_defaults")]
        public static extern void av_opt_set_defaults(void* s);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_defaults2")]
        public static extern void av_opt_set_defaults2(void* s, int mask, int flags);

        /// <summary>
        /// Parse the key/value pairs list in opts. For each key/value pair
        /// found, stores the value in the field in ctx that is named like the
        /// key. ctx must be an AVClass context, storing is done using
        /// AVOptions.
        /// 
        /// @param opts options string to parse, may be NULL
        /// @param key_val_sep a 0-terminated list of characters used to
        /// separate key from value
        /// @param pairs_sep a 0-terminated list of characters used to separate
        /// two pairs from each other
        /// @return the number of successfully set key/value pairs, or a negative
        /// value corresponding to an AVERROR code in case of error:
        /// AVERROR(EINVAL) if opts cannot be parsed,
        /// the error code issued by av_set_string3() if a key/value pair
        /// cannot be set
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_set_options_string")]
        public static extern int av_set_options_string(void* ctx, string opts, string key_val_sep, string pairs_sep);

        /// <summary>
        /// Parse the key-value pairs list in opts. For each key=value pair found,
        /// set the value of the corresponding option in ctx.
        /// 
        /// @param ctx          the AVClass object to set options on
        /// @param opts         the options string, key-value pairs separated by a
        /// delimiter
        /// @param shorthand    a NULL-terminated array of options names for
        /// shorthand
        /// notation: if the first field in opts has no key part,
        /// the key is taken from the first element of shorthand;
        /// then again for the second, etc., until either opts is
        /// finished, shorthand is finished or a named option is
        /// found; after that, all options must be named
        /// @param key_val_sep  a 0-terminated list of characters used to separate
        /// key from value, for example '='
        /// @param pairs_sep    a 0-terminated list of characters used to separate
        /// two pairs from each other, for example ':' or ','
        /// @return  the number of successfully set key=value pairs, or a negative
        /// value corresponding to an AVERROR code in case of error:
        /// AVERROR(EINVAL) if opts cannot be parsed,
        /// the error code issued by av_set_string3() if a key/value pair
        /// cannot be set
        /// 
        /// Options names must use only the following characters: a-z A-Z 0-9 - . /
        /// _
        /// Separators must use characters distinct from option names and from each
        /// other.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_from_string")]
        public static extern int av_opt_set_from_string(void* ctx, string opts, sbyte** shorthand, string key_val_sep, string pairs_sep);

        /// <summary>
        /// Parse the key-value pairs list in opts. For each key=value pair found,
        /// set the value of the corresponding option in ctx.
        /// 
        /// @param ctx          the AVClass object to set options on
        /// @param opts         the options string, key-value pairs separated by a
        /// delimiter
        /// @param shorthand    a NULL-terminated array of options names for
        /// shorthand
        /// notation: if the first field in opts has no key part,
        /// the key is taken from the first element of shorthand;
        /// then again for the second, etc., until either opts is
        /// finished, shorthand is finished or a named option is
        /// found; after that, all options must be named
        /// @param key_val_sep  a 0-terminated list of characters used to separate
        /// key from value, for example '='
        /// @param pairs_sep    a 0-terminated list of characters used to separate
        /// two pairs from each other, for example ':' or ','
        /// @return  the number of successfully set key=value pairs, or a negative
        /// value corresponding to an AVERROR code in case of error:
        /// AVERROR(EINVAL) if opts cannot be parsed,
        /// the error code issued by av_set_string3() if a key/value pair
        /// cannot be set
        /// 
        /// Options names must use only the following characters: a-z A-Z 0-9 - . /
        /// _
        /// Separators must use characters distinct from option names and from each
        /// other.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_from_string")]
        public static extern int av_opt_set_from_string(void* ctx, string opts, ref string shorthand, string key_val_sep, string pairs_sep);

        /// <summary>
        /// Free all string and binary options in obj.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_free")]
        public static extern void av_opt_free(void* obj);

        /// <summary>
        /// Check whether a particular flag is set in a flags field.
        /// 
        /// @param field_name the name of the flag field option
        /// @param flag_name the name of the flag to check
        /// @return non-zero if the flag is set, zero if the flag isn't set,
        /// isn't of the right type, or the flags field doesn't exist.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_flag_is_set")]
        public static extern int av_opt_flag_is_set(void* obj, string field_name, string flag_name);

        /// <summary>
        /// Set all the options from a given dictionary on an object.
        /// 
        /// @param obj a struct whose first element is a pointer to AVClass
        /// @param options options to process. This dictionary will be freed and
        /// replaced
        /// by a new one containing all options not found in obj.
        /// Of course this new dictionary needs to be freed by caller
        /// with av_dict_free().
        /// 
        /// @return 0 on success, a negative AVERROR if some option was found in
        /// obj,
        /// but could not be set.
        /// 
        /// @see av_dict_copy()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_dict")]
        public static extern int av_opt_set_dict(void* obj, libavutil.AVDictionary** options);

        /// <summary>
        /// Set all the options from a given dictionary on an object.
        /// 
        /// @param obj a struct whose first element is a pointer to AVClass
        /// @param options options to process. This dictionary will be freed and
        /// replaced
        /// by a new one containing all options not found in obj.
        /// Of course this new dictionary needs to be freed by caller
        /// with av_dict_free().
        /// 
        /// @return 0 on success, a negative AVERROR if some option was found in
        /// obj,
        /// but could not be set.
        /// 
        /// @see av_dict_copy()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_dict")]
        public static extern int av_opt_set_dict(void* obj, ref libavutil.AVDictionary* options);

        /// <summary>
        /// Extract a key-value pair from the beginning of a string.
        /// 
        /// @param ropts        pointer to the options string, will be updated to
        /// point to the rest of the string (one of the pairs_sep
        /// or the final NUL)
        /// @param key_val_sep  a 0-terminated list of characters used to separate
        /// key from value, for example '='
        /// @param pairs_sep    a 0-terminated list of characters used to separate
        /// two pairs from each other, for example ':' or ','
        /// @param flags        flags; see the AV_OPT_FLAG_* values below
        /// @param rkey         parsed key; must be freed using av_free()
        /// @param rval         parsed value; must be freed using av_free()
        /// 
        /// @return  >=0 for success, or a negative value corresponding to an
        /// AVERROR code in case of error; in particular:
        /// AVERROR(EINVAL) if no key is present
        /// 
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get_key_value")]
        public static extern int av_opt_get_key_value(sbyte** ropts, string key_val_sep, string pairs_sep, uint flags, sbyte** rkey, sbyte** rval);

        /// <summary>
        /// Extract a key-value pair from the beginning of a string.
        /// 
        /// @param ropts        pointer to the options string, will be updated to
        /// point to the rest of the string (one of the pairs_sep
        /// or the final NUL)
        /// @param key_val_sep  a 0-terminated list of characters used to separate
        /// key from value, for example '='
        /// @param pairs_sep    a 0-terminated list of characters used to separate
        /// two pairs from each other, for example ':' or ','
        /// @param flags        flags; see the AV_OPT_FLAG_* values below
        /// @param rkey         parsed key; must be freed using av_free()
        /// @param rval         parsed value; must be freed using av_free()
        /// 
        /// @return  >=0 for success, or a negative value corresponding to an
        /// AVERROR code in case of error; in particular:
        /// AVERROR(EINVAL) if no key is present
        /// 
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get_key_value")]
        public static extern int av_opt_get_key_value(ref string ropts, string key_val_sep, string pairs_sep, uint flags, ref System.Text.StringBuilder rkey, ref System.Text.StringBuilder rval);

        /// <summary>
        /// @defgroup opt_eval_funcs Evaluating option strings
        /// @{
        /// This group of functions can be used to evaluate option strings
        /// and get numbers out of them. They do the same thing as av_opt_set(),
        /// except the result is written into the caller-supplied pointer.
        /// 
        /// @param obj a struct whose first element is a pointer to AVClass.
        /// @param o an option for which the string is to be evaluated.
        /// @param val string to be evaluated.
        /// @param *_out value of the string will be written here.
        /// 
        /// @return 0 on success, a negative number on failure.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_eval_flags")]
        public static extern int av_opt_eval_flags(void* obj, libavutil.AVOption* o, string val, int* flags_out);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_eval_int")]
        public static extern int av_opt_eval_int(void* obj, libavutil.AVOption* o, string val, int* int_out);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_eval_int64")]
        public static extern int av_opt_eval_int64(void* obj, libavutil.AVOption* o, string val, long* int64_out);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_eval_float")]
        public static extern int av_opt_eval_float(void* obj, libavutil.AVOption* o, string val, float* float_out);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_eval_double")]
        public static extern int av_opt_eval_double(void* obj, libavutil.AVOption* o, string val, double* double_out);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_eval_q")]
        public static extern int av_opt_eval_q(void* obj, libavutil.AVOption* o, string val, libavutil.AVRational* q_out);

        /// <summary>
        /// Look for an option in an object. Consider only options which
        /// have all the specified flags set.
        /// 
        /// @param[in] obj A pointer to a struct whose first element is a
        /// pointer to an AVClass.
        /// Alternatively a double pointer to an AVClass, if
        /// AV_OPT_SEARCH_FAKE_OBJ search flag is set.
        /// @param[in] name The name of the option to look for.
        /// @param[in] unit When searching for named constants, name of the unit
        /// it belongs to.
        /// @param opt_flags Find only options with all the specified flags set
        /// (AV_OPT_FLAG).
        /// @param search_flags A combination of AV_OPT_SEARCH_*.
        /// 
        /// @return A pointer to the option found, or NULL if no option
        /// was found.
        /// 
        /// @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be
        /// settable
        /// directly with av_set_string3(). Use special calls which take an options
        /// AVDictionary (e.g. avformat_open_input()) to set options found with
        /// this
        /// flag.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_find")]
        public static extern libavutil.AVOption* av_opt_find(void* obj, string name, string unit, int opt_flags, int search_flags);

        /// <summary>
        /// Look for an option in an object. Consider only options which
        /// have all the specified flags set.
        /// 
        /// @param[in] obj A pointer to a struct whose first element is a
        /// pointer to an AVClass.
        /// Alternatively a double pointer to an AVClass, if
        /// AV_OPT_SEARCH_FAKE_OBJ search flag is set.
        /// @param[in] name The name of the option to look for.
        /// @param[in] unit When searching for named constants, name of the unit
        /// it belongs to.
        /// @param opt_flags Find only options with all the specified flags set
        /// (AV_OPT_FLAG).
        /// @param search_flags A combination of AV_OPT_SEARCH_*.
        /// @param[out] target_obj if non-NULL, an object to which the option
        /// belongs will be
        /// written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is
        /// present
        /// in search_flags. This parameter is ignored if search_flags contain
        /// AV_OPT_SEARCH_FAKE_OBJ.
        /// 
        /// @return A pointer to the option found, or NULL if no option
        /// was found.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_find2")]
        public static extern libavutil.AVOption* av_opt_find2(void* obj, string name, string unit, int opt_flags, int search_flags, void** target_obj);

        /// <summary>
        /// Look for an option in an object. Consider only options which
        /// have all the specified flags set.
        /// 
        /// @param[in] obj A pointer to a struct whose first element is a
        /// pointer to an AVClass.
        /// Alternatively a double pointer to an AVClass, if
        /// AV_OPT_SEARCH_FAKE_OBJ search flag is set.
        /// @param[in] name The name of the option to look for.
        /// @param[in] unit When searching for named constants, name of the unit
        /// it belongs to.
        /// @param opt_flags Find only options with all the specified flags set
        /// (AV_OPT_FLAG).
        /// @param search_flags A combination of AV_OPT_SEARCH_*.
        /// @param[out] target_obj if non-NULL, an object to which the option
        /// belongs will be
        /// written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is
        /// present
        /// in search_flags. This parameter is ignored if search_flags contain
        /// AV_OPT_SEARCH_FAKE_OBJ.
        /// 
        /// @return A pointer to the option found, or NULL if no option
        /// was found.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_find2")]
        public static extern libavutil.AVOption* av_opt_find2(void* obj, string name, string unit, int opt_flags, int search_flags, ref void* target_obj);

        /// <summary>
        /// Iterate over all AVOptions belonging to obj.
        /// 
        /// @param obj an AVOptions-enabled struct or a double pointer to an
        /// AVClass describing it.
        /// @param prev result of the previous call to av_opt_next() on this object
        /// or NULL
        /// @return next AVOption or NULL
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_next")]
        public static extern libavutil.AVOption* av_opt_next(void* obj, libavutil.AVOption* prev);

        /// <summary>
        /// Iterate over AVOptions-enabled children of obj.
        /// 
        /// @param prev result of a previous call to this function or NULL
        /// @return next AVOptions-enabled child or NULL
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_child_next")]
        public static extern void* av_opt_child_next(void* obj, void* prev);

        /// <summary>
        /// Iterate over potential AVOptions-enabled children of parent.
        /// 
        /// @param prev result of a previous call to this function or NULL
        /// @return AVClass corresponding to next potential child or NULL
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_child_class_next")]
        public static extern libavutil.AVClass* av_opt_child_class_next(libavutil.AVClass* parent, libavutil.AVClass* prev);

        /// <summary>
        /// @defgroup opt_set_funcs Option setting functions
        /// @{
        /// Those functions set the field of obj with the given name to value.
        /// 
        /// @param[in] obj A struct whose first element is a pointer to an AVClass.
        /// @param[in] name the name of the field to set
        /// @param[in] val The value to set. In case of av_opt_set() if the field
        /// is not
        /// of a string type, then the given string is parsed.
        /// SI postfixes and some named scalars are supported.
        /// If the field is of a numeric type, it has to be a numeric or named
        /// scalar. Behavior with more than one scalar and +- infix operators
        /// is undefined.
        /// If the field is of a flags type, it has to be a sequence of numeric
        /// scalars or named flags separated by '+' or '-'. Prefixing a flag
        /// with '+' causes it to be set without affecting the other flags;
        /// similarly, '-' unsets a flag.
        /// @param search_flags flags passed to av_opt_find2. I.e. if
        /// AV_OPT_SEARCH_CHILDREN
        /// is passed here, then the option may be set on a child of obj.
        /// 
        /// @return 0 if the value has been set, or an AVERROR code in case of
        /// error:
        /// AVERROR_OPTION_NOT_FOUND if no matching option exists
        /// AVERROR(ERANGE) if the value is out of range
        /// AVERROR(EINVAL) if the value is not valid
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set")]
        public static extern int av_opt_set(void* obj, string name, string val, int search_flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_int")]
        public static extern int av_opt_set_int(void* obj, string name, long val, int search_flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_double")]
        public static extern int av_opt_set_double(void* obj, string name, double val, int search_flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_q")]
        public static extern int av_opt_set_q(void* obj, string name, libavutil.AVRational val, int search_flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_bin")]
        public static extern int av_opt_set_bin(void* obj, string name, byte* val, int size, int search_flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_image_size")]
        public static extern int av_opt_set_image_size(void* obj, string name, int w, int h, int search_flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_pixel_fmt")]
        public static extern int av_opt_set_pixel_fmt(void* obj, string name, libavutil.AVPixelFormat fmt, int search_flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_sample_fmt")]
        public static extern int av_opt_set_sample_fmt(void* obj, string name, libavutil.AVSampleFormat fmt, int search_flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_video_rate")]
        public static extern int av_opt_set_video_rate(void* obj, string name, libavutil.AVRational val, int search_flags);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_set_channel_layout")]
        public static extern int av_opt_set_channel_layout(void* obj, string name, long ch_layout, int search_flags);

        /// <summary>
        /// @defgroup opt_get_funcs Option getting functions
        /// @{
        /// Those functions get a value of the option with the given name from an
        /// object.
        /// 
        /// @param[in] obj a struct whose first element is a pointer to an AVClass.
        /// @param[in] name name of the option to get.
        /// @param[in] search_flags flags passed to av_opt_find2. I.e. if
        /// AV_OPT_SEARCH_CHILDREN
        /// is passed here, then the option may be found in a child of obj.
        /// @param[out] out_val value of the option will be written here
        /// @return >=0 on success, a negative error code otherwise
        /// 
        /// 
        /// @note the returned string will be av_malloc()ed and must be av_free()ed
        /// by the caller
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get")]
        public static extern int av_opt_get(void* obj, string name, int search_flags, byte** out_val);

        /// <summary>
        /// @defgroup opt_get_funcs Option getting functions
        /// @{
        /// Those functions get a value of the option with the given name from an
        /// object.
        /// 
        /// @param[in] obj a struct whose first element is a pointer to an AVClass.
        /// @param[in] name name of the option to get.
        /// @param[in] search_flags flags passed to av_opt_find2. I.e. if
        /// AV_OPT_SEARCH_CHILDREN
        /// is passed here, then the option may be found in a child of obj.
        /// @param[out] out_val value of the option will be written here
        /// @return >=0 on success, a negative error code otherwise
        /// 
        /// 
        /// @note the returned string will be av_malloc()ed and must be av_free()ed
        /// by the caller
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get")]
        public static extern int av_opt_get(void* obj, string name, int search_flags, ref byte* out_val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get_int")]
        public static extern int av_opt_get_int(void* obj, string name, int search_flags, long* out_val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get_double")]
        public static extern int av_opt_get_double(void* obj, string name, int search_flags, double* out_val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get_q")]
        public static extern int av_opt_get_q(void* obj, string name, int search_flags, libavutil.AVRational* out_val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get_image_size")]
        public static extern int av_opt_get_image_size(void* obj, string name, int search_flags, int* w_out, int* h_out);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get_pixel_fmt")]
        public static extern int av_opt_get_pixel_fmt(void* obj, string name, int search_flags, libavutil.AVPixelFormat* out_fmt);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get_sample_fmt")]
        public static extern int av_opt_get_sample_fmt(void* obj, string name, int search_flags, libavutil.AVSampleFormat* out_fmt);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get_video_rate")]
        public static extern int av_opt_get_video_rate(void* obj, string name, int search_flags, libavutil.AVRational* out_val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_get_channel_layout")]
        public static extern int av_opt_get_channel_layout(void* obj, string name, int search_flags, long* ch_layout);

        /// <summary>
        /// @}
        /// 
        /// 
        /// Gets a pointer to the requested field in a struct.
        /// This function allows accessing a struct even when its fields are moved
        /// or
        /// renamed since the application making the access has been compiled,
        /// 
        /// @returns a pointer to the field, it can be cast to the correct type and
        /// read
        /// or written to.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_ptr")]
        public static extern void* av_opt_ptr(libavutil.AVClass* avclass, void* obj, string name);

        /// <summary>
        /// Free an AVOptionRanges struct and set it to NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_freep_ranges")]
        public static extern void av_opt_freep_ranges(libavutil.AVOptionRanges** ranges);

        /// <summary>
        /// Free an AVOptionRanges struct and set it to NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_freep_ranges")]
        public static extern void av_opt_freep_ranges(ref libavutil.AVOptionRanges* ranges);

        /// <summary>
        /// Get a list of allowed ranges for the given option.
        /// 
        /// The returned list may depend on other fields in obj like for example
        /// profile.
        /// 
        /// @param flags is a bitmask of flags, undefined flags should not be set
        /// and should be ignored
        /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a
        /// AVClass instead of a full instance
        /// 
        /// The result must be freed with av_opt_freep_ranges.
        /// 
        /// @return >= 0 on success, a negative errro code otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_query_ranges")]
        public static extern int av_opt_query_ranges(libavutil.AVOptionRanges** _0, void* obj, string key, int flags);

        /// <summary>
        /// Get a list of allowed ranges for the given option.
        /// 
        /// The returned list may depend on other fields in obj like for example
        /// profile.
        /// 
        /// @param flags is a bitmask of flags, undefined flags should not be set
        /// and should be ignored
        /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a
        /// AVClass instead of a full instance
        /// 
        /// The result must be freed with av_opt_freep_ranges.
        /// 
        /// @return >= 0 on success, a negative errro code otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_query_ranges")]
        public static extern int av_opt_query_ranges(ref libavutil.AVOptionRanges* _0, void* obj, string key, int flags);

        /// <summary>
        /// Get a default list of allowed ranges for the given option.
        /// 
        /// This list is constructed without using the AVClass.query_ranges()
        /// callback
        /// and can be used as fallback from within the callback.
        /// 
        /// @param flags is a bitmask of flags, undefined flags should not be set
        /// and should be ignored
        /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a
        /// AVClass instead of a full instance
        /// 
        /// The result must be freed with av_opt_free_ranges.
        /// 
        /// @return >= 0 on success, a negative errro code otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_query_ranges_default")]
        public static extern int av_opt_query_ranges_default(libavutil.AVOptionRanges** _0, void* obj, string key, int flags);

        /// <summary>
        /// Get a default list of allowed ranges for the given option.
        /// 
        /// This list is constructed without using the AVClass.query_ranges()
        /// callback
        /// and can be used as fallback from within the callback.
        /// 
        /// @param flags is a bitmask of flags, undefined flags should not be set
        /// and should be ignored
        /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a
        /// AVClass instead of a full instance
        /// 
        /// The result must be freed with av_opt_free_ranges.
        /// 
        /// @return >= 0 on success, a negative errro code otherwise
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_opt_query_ranges_default")]
        public static extern int av_opt_query_ranges_default(ref libavutil.AVOptionRanges* _0, void* obj, string key, int flags);
    }
}
