//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FFmpeg
{
    public unsafe static partial class libavutil
    {
        public const double M_E = 2.71828182845905D;

        public const double M_LN2 = 0.693147180559945D;

        public const double M_LN10 = 2.30258509299405D;

        public const double M_LOG2_10 = 3.32192809488736D;

        public const double M_PHI = 1.61803398874989D;

        public const double M_PI = 3.14159265358979D;

        public const double M_PI_2 = 1.5707963267949D;

        public const double M_SQRT1_2 = 0.707106781186548D;

        public const double M_SQRT2 = 1.4142135623731D;

        /// <summary>
        /// @addtogroup lavu_math
        /// @{
        /// </summary>
        public enum AVRounding
        {
            /// <summary>Round toward zero.</summary>
            AV_ROUND_ZERO = 0,
            /// <summary>Round away from zero.</summary>
            AV_ROUND_INF = 1,
            /// <summary>Round toward -infinity.</summary>
            AV_ROUND_DOWN = 2,
            /// <summary>Round toward +infinity.</summary>
            AV_ROUND_UP = 3,
            /// <summary>Round to nearest and halfway cases away from zero.</summary>
            AV_ROUND_NEAR_INF = 5,
            /// <summary>Flag to pass INT64_MIN/MAX through instead of rescaling, this avoids special cases for AV_NOPTS_VALUE</summary>
            AV_ROUND_PASS_MINMAX = 8192
        }

        /// <summary>
        /// Return the greatest common divisor of a and b.
        /// If both a and b are 0 or either or both are <0 then behavior is
        /// undefined.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_gcd")]
        public static extern long av_gcd(long a, long b);

        /// <summary>
        /// Rescale a 64-bit integer with rounding to nearest.
        /// A simple a*b/c isn't possible as it can overflow.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_rescale")]
        public static extern long av_rescale(long a, long b, long c);

        /// <summary>
        /// Rescale a 64-bit integer with specified rounding.
        /// A simple a*b/c isn't possible as it can overflow.
        /// </summary>
        /// <returns>
        /// rescaled value a, or if AV_ROUND_PASS_MINMAX is set and a is
        /// INT64_MIN or INT64_MAX then a is passed through unchanged.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_rescale_rnd")]
        public static extern long av_rescale_rnd(long a, long b, long c, libavutil.AVRounding _0);

        /// <summary>
        /// Rescale a 64-bit integer by 2 rational numbers.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_rescale_q")]
        public static extern long av_rescale_q(long a, libavutil.AVRational bq, libavutil.AVRational cq);

        /// <summary>
        /// Rescale a 64-bit integer by 2 rational numbers with specified rounding.
        /// </summary>
        /// <returns>
        /// rescaled value a, or if AV_ROUND_PASS_MINMAX is set and a is
        /// INT64_MIN or INT64_MAX then a is passed through unchanged.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_rescale_q_rnd")]
        public static extern long av_rescale_q_rnd(long a, libavutil.AVRational bq, libavutil.AVRational cq, libavutil.AVRounding _0);

        /// <summary>
        /// Compare 2 timestamps each in its own timebases.
        /// The result of the function is undefined if one of the timestamps
        /// is outside the int64_t range when represented in the others timebase.
        /// </summary>
        /// <returns>
        /// -1 if ts_a is before ts_b, 1 if ts_a is after ts_b or 0 if they
        /// represent the same position
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_compare_ts")]
        public static extern int av_compare_ts(long ts_a, libavutil.AVRational tb_a, long ts_b, libavutil.AVRational tb_b);

        /// <summary>
        /// Compare 2 integers modulo mod.
        /// That is we compare integers a and b for which only the least
        /// significant log2(mod) bits are known.
        /// </summary>
        /// <param name="mod">
        /// must be a power of 2
        /// </param>
        /// <returns>
        /// a negative value if a is smaller than b
        /// a positive value if a is greater than b
        /// 0                if a equals          b
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_compare_mod")]
        public static extern long av_compare_mod(ulong a, ulong b, ulong mod);

        /// <summary>
        /// Rescale a timestamp while preserving known durations.
        /// </summary>
        /// <param name="in_ts">
        /// Input timestamp
        /// </param>
        /// <param name="in_tb">
        /// Input timebase
        /// </param>
        /// <param name="fs_tb">
        /// Duration and *last timebase
        /// </param>
        /// <param name="duration">
        /// duration till the next call
        /// </param>
        /// <param name="out_tb">
        /// Output timebase
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_rescale_delta")]
        public static extern long av_rescale_delta(libavutil.AVRational in_tb, long in_ts, libavutil.AVRational fs_tb, int duration, long* last, libavutil.AVRational out_tb);

        /// <summary>
        /// Add a value to a timestamp.
        /// 
        /// This function gurantees that when the same value is repeatly added that
        /// no accumulation of rounding errors occurs.
        /// </summary>
        /// <param name="ts">
        /// Input timestamp
        /// </param>
        /// <param name="ts_tb">
        /// Input timestamp timebase
        /// </param>
        /// <param name="inc">
        /// value to add to ts
        /// </param>
        /// <param name="inc_tb">
        /// inc timebase
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_add_stable")]
        public static extern long av_add_stable(libavutil.AVRational ts_tb, long ts, libavutil.AVRational inc_tb, long inc);
    }
}
