//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using FFmpeg;

namespace FFmpeg
{
    public unsafe static partial class libavcodec
    {
        public const sbyte FF_INPUT_BUFFER_PADDING_SIZE = 16;

        public const short FF_MIN_BUFFER_SIZE = 16384;

        public const sbyte FF_MAX_B_FRAMES = 16;

        public const sbyte CODEC_FLAG_UNALIGNED = 1;

        public const sbyte CODEC_FLAG_QSCALE = 2;

        public const sbyte CODEC_FLAG_4MV = 4;

        public const sbyte CODEC_FLAG_OUTPUT_CORRUPT = 8;

        public const sbyte CODEC_FLAG_QPEL = 10;

        public const sbyte CODEC_FLAG_GMC = 20;

        public const sbyte CODEC_FLAG_MV0 = 40;

        public const short CODEC_FLAG_INPUT_PRESERVED = 100;

        public const short CODEC_FLAG_PASS1 = 200;

        public const short CODEC_FLAG_PASS2 = 400;

        public const short CODEC_FLAG_GRAY = 2000;

        public const short CODEC_FLAG_EMU_EDGE = 4000;

        public const ushort CODEC_FLAG_PSNR = 8000;

        public const int CODEC_FLAG_TRUNCATED = 10000;

        public const int CODEC_FLAG_NORMALIZE_AQP = 20000;

        public const int CODEC_FLAG_INTERLACED_DCT = 40000;

        public const int CODEC_FLAG_LOW_DELAY = 80000;

        public const int CODEC_FLAG_GLOBAL_HEADER = 400000;

        public const int CODEC_FLAG_BITEXACT = 800000;

        public const int CODEC_FLAG_AC_PRED = 1000000;

        public const short CODEC_FLAG_LOOP_FILTER = 800;

        public const int CODEC_FLAG_INTERLACED_ME = 20000000;

        public const uint CODEC_FLAG_CLOSED_GOP = 80000000;

        public const sbyte CODEC_FLAG2_FAST = 1;

        public const sbyte CODEC_FLAG2_NO_OUTPUT = 4;

        public const sbyte CODEC_FLAG2_LOCAL_HEADER = 8;

        public const short CODEC_FLAG2_DROP_FRAME_TIMECODE = 2000;

        public const int CODEC_FLAG2_IGNORE_CROP = 10000;

        public const ushort CODEC_FLAG2_CHUNKS = 8000;

        public const int CODEC_FLAG2_SHOW_ALL = 400000;

        public const sbyte CODEC_CAP_DRAW_HORIZ_BAND = 1;

        public const sbyte CODEC_CAP_DR1 = 2;

        public const sbyte CODEC_CAP_TRUNCATED = 8;

        public const sbyte CODEC_CAP_HWACCEL = 10;

        public const sbyte CODEC_CAP_DELAY = 20;

        public const sbyte CODEC_CAP_SMALL_LAST_FRAME = 40;

        public const byte CODEC_CAP_HWACCEL_VDPAU = 80;

        public const short CODEC_CAP_SUBFRAMES = 100;

        public const short CODEC_CAP_EXPERIMENTAL = 200;

        public const short CODEC_CAP_CHANNEL_CONF = 400;

        public const short CODEC_CAP_NEG_LINESIZES = 800;

        public const short CODEC_CAP_FRAME_THREADS = 1000;

        public const short CODEC_CAP_SLICE_THREADS = 2000;

        public const short CODEC_CAP_PARAM_CHANGE = 4000;

        public const ushort CODEC_CAP_AUTO_THREADS = 8000;

        public const int CODEC_CAP_VARIABLE_FRAME_SIZE = 10000;

        public const int CODEC_CAP_INTRA_ONLY = 40000000;

        public const uint CODEC_CAP_LOSSLESS = 80000000;

        public const sbyte MB_TYPE_INTRA4x4 = 1;

        public const sbyte MB_TYPE_INTRA16x16 = 2;

        public const sbyte MB_TYPE_INTRA_PCM = 4;

        public const sbyte MB_TYPE_16x16 = 8;

        public const sbyte MB_TYPE_16x8 = 10;

        public const sbyte MB_TYPE_8x16 = 20;

        public const sbyte MB_TYPE_8x8 = 40;

        public const byte MB_TYPE_INTERLACED = 80;

        public const short MB_TYPE_DIRECT2 = 100;

        public const short MB_TYPE_ACPRED = 200;

        public const short MB_TYPE_GMC = 400;

        public const short MB_TYPE_SKIP = 800;

        public const short MB_TYPE_P0L0 = 1000;

        public const short MB_TYPE_P1L0 = 2000;

        public const short MB_TYPE_P0L1 = 4000;

        public const ushort MB_TYPE_P1L1 = 8000;

        public const int MB_TYPE_QUANT = 10000;

        public const int MB_TYPE_CBP = 20000;

        public const sbyte FF_QSCALE_TYPE_MPEG1 = 0;

        public const sbyte FF_QSCALE_TYPE_MPEG2 = 1;

        public const sbyte FF_QSCALE_TYPE_H264 = 2;

        public const sbyte FF_QSCALE_TYPE_VP56 = 3;

        public const sbyte FF_BUFFER_TYPE_INTERNAL = 1;

        public const sbyte FF_BUFFER_TYPE_USER = 2;

        public const sbyte FF_BUFFER_TYPE_SHARED = 4;

        public const sbyte FF_BUFFER_TYPE_COPY = 8;

        public const sbyte FF_BUFFER_HINTS_VALID = 1;

        public const sbyte FF_BUFFER_HINTS_READABLE = 2;

        public const sbyte FF_BUFFER_HINTS_PRESERVE = 4;

        public const sbyte FF_BUFFER_HINTS_REUSABLE = 8;

        public const sbyte AV_PKT_FLAG_KEY = 1;

        public const sbyte AV_PKT_FLAG_CORRUPT = 2;

        public const sbyte FF_COMPRESSION_DEFAULT = -1;

        public const sbyte FF_ASPECT_EXTENDED = 15;

        public const sbyte FF_RC_STRATEGY_XVID = 1;

        public const sbyte FF_PRED_LEFT = 0;

        public const sbyte FF_PRED_PLANE = 1;

        public const sbyte FF_PRED_MEDIAN = 2;

        public const sbyte FF_CMP_SAD = 0;

        public const sbyte FF_CMP_SSE = 1;

        public const sbyte FF_CMP_SATD = 2;

        public const sbyte FF_CMP_DCT = 3;

        public const sbyte FF_CMP_PSNR = 4;

        public const sbyte FF_CMP_BIT = 5;

        public const sbyte FF_CMP_RD = 6;

        public const sbyte FF_CMP_ZERO = 7;

        public const sbyte FF_CMP_VSAD = 8;

        public const sbyte FF_CMP_VSSE = 9;

        public const sbyte FF_CMP_NSSE = 10;

        public const sbyte FF_CMP_W53 = 11;

        public const sbyte FF_CMP_W97 = 12;

        public const sbyte FF_CMP_DCTMAX = 13;

        public const sbyte FF_CMP_DCT264 = 14;

        public const short FF_CMP_CHROMA = 256;

        public const sbyte FF_DTG_AFD_SAME = 8;

        public const sbyte FF_DTG_AFD_4_3 = 9;

        public const sbyte FF_DTG_AFD_16_9 = 10;

        public const sbyte FF_DTG_AFD_14_9 = 11;

        public const sbyte FF_DTG_AFD_4_3_SP_14_9 = 13;

        public const sbyte FF_DTG_AFD_16_9_SP_14_9 = 14;

        public const sbyte FF_DTG_AFD_SP_4_3 = 15;

        public const int FF_DEFAULT_QUANT_BIAS = 999999;

        public const sbyte SLICE_FLAG_CODED_ORDER = 1;

        public const sbyte SLICE_FLAG_ALLOW_FIELD = 2;

        public const sbyte SLICE_FLAG_ALLOW_PLANE = 4;

        public const sbyte FF_MB_DECISION_SIMPLE = 0;

        public const sbyte FF_MB_DECISION_BITS = 1;

        public const sbyte FF_MB_DECISION_RD = 2;

        public const sbyte FF_CODER_TYPE_VLC = 0;

        public const sbyte FF_CODER_TYPE_AC = 1;

        public const sbyte FF_CODER_TYPE_RAW = 2;

        public const sbyte FF_CODER_TYPE_RLE = 3;

        public const sbyte FF_CODER_TYPE_DEFLATE = 4;

        public const sbyte FF_BUG_AUTODETECT = 1;

        public const sbyte FF_BUG_OLD_MSMPEG4 = 2;

        public const sbyte FF_BUG_XVID_ILACE = 4;

        public const sbyte FF_BUG_UMP4 = 8;

        public const sbyte FF_BUG_NO_PADDING = 16;

        public const sbyte FF_BUG_AMV = 32;

        public const sbyte FF_BUG_AC_VLC = 0;

        public const sbyte FF_BUG_QPEL_CHROMA = 64;

        public const byte FF_BUG_STD_QPEL = 128;

        public const short FF_BUG_QPEL_CHROMA2 = 256;

        public const short FF_BUG_DIRECT_BLOCKSIZE = 512;

        public const short FF_BUG_EDGE = 1024;

        public const short FF_BUG_HPEL_CHROMA = 2048;

        public const short FF_BUG_DC_CLIP = 4096;

        public const short FF_BUG_MS = 8192;

        public const short FF_BUG_TRUNCATED = 16384;

        public const sbyte FF_COMPLIANCE_VERY_STRICT = 2;

        public const sbyte FF_COMPLIANCE_STRICT = 1;

        public const sbyte FF_COMPLIANCE_NORMAL = 0;

        public const sbyte FF_COMPLIANCE_UNOFFICIAL = -1;

        public const sbyte FF_COMPLIANCE_EXPERIMENTAL = -2;

        public const sbyte FF_EC_GUESS_MVS = 1;

        public const sbyte FF_EC_DEBLOCK = 2;

        public const sbyte FF_DEBUG_PICT_INFO = 1;

        public const sbyte FF_DEBUG_RC = 2;

        public const sbyte FF_DEBUG_BITSTREAM = 4;

        public const sbyte FF_DEBUG_MB_TYPE = 8;

        public const sbyte FF_DEBUG_QP = 16;

        public const sbyte FF_DEBUG_MV = 32;

        public const sbyte FF_DEBUG_DCT_COEFF = 40;

        public const byte FF_DEBUG_SKIP = 80;

        public const short FF_DEBUG_STARTCODE = 100;

        public const short FF_DEBUG_PTS = 200;

        public const short FF_DEBUG_ER = 400;

        public const short FF_DEBUG_MMCO = 800;

        public const short FF_DEBUG_BUGS = 1000;

        public const short FF_DEBUG_VIS_QP = 2000;

        public const short FF_DEBUG_VIS_MB_TYPE = 4000;

        public const ushort FF_DEBUG_BUFFERS = 8000;

        public const int FF_DEBUG_THREADS = 10000;

        public const sbyte FF_DEBUG_VIS_MV_P_FOR = 1;

        public const sbyte FF_DEBUG_VIS_MV_B_FOR = 2;

        public const sbyte FF_DEBUG_VIS_MV_B_BACK = 4;

        public const sbyte FF_DCT_AUTO = 0;

        public const sbyte FF_DCT_FASTINT = 1;

        public const sbyte FF_DCT_INT = 2;

        public const sbyte FF_DCT_MMX = 3;

        public const sbyte FF_DCT_ALTIVEC = 5;

        public const sbyte FF_DCT_FAAN = 6;

        public const sbyte FF_IDCT_AUTO = 0;

        public const sbyte FF_IDCT_INT = 1;

        public const sbyte FF_IDCT_SIMPLE = 2;

        public const sbyte FF_IDCT_SIMPLEMMX = 3;

        public const sbyte FF_IDCT_ARM = 7;

        public const sbyte FF_IDCT_ALTIVEC = 8;

        public const sbyte FF_IDCT_SH4 = 9;

        public const sbyte FF_IDCT_SIMPLEARM = 10;

        public const sbyte FF_IDCT_IPP = 13;

        public const sbyte FF_IDCT_XVIDMMX = 14;

        public const sbyte FF_IDCT_SIMPLEARMV5TE = 16;

        public const sbyte FF_IDCT_SIMPLEARMV6 = 17;

        public const sbyte FF_IDCT_SIMPLEVIS = 18;

        public const sbyte FF_IDCT_FAAN = 20;

        public const sbyte FF_IDCT_SIMPLENEON = 22;

        public const sbyte FF_IDCT_SIMPLEALPHA = 23;

        public const sbyte FF_THREAD_FRAME = 1;

        public const sbyte FF_THREAD_SLICE = 2;

        public const sbyte FF_PROFILE_UNKNOWN = -99;

        public const sbyte FF_PROFILE_RESERVED = -100;

        public const sbyte FF_PROFILE_AAC_MAIN = 0;

        public const sbyte FF_PROFILE_AAC_LOW = 1;

        public const sbyte FF_PROFILE_AAC_SSR = 2;

        public const sbyte FF_PROFILE_AAC_LTP = 3;

        public const sbyte FF_PROFILE_AAC_HE = 4;

        public const sbyte FF_PROFILE_AAC_HE_V2 = 28;

        public const sbyte FF_PROFILE_AAC_LD = 22;

        public const sbyte FF_PROFILE_AAC_ELD = 38;

        public const byte FF_PROFILE_MPEG2_AAC_LOW = 128;

        public const byte FF_PROFILE_MPEG2_AAC_HE = 131;

        public const sbyte FF_PROFILE_DTS = 20;

        public const sbyte FF_PROFILE_DTS_ES = 30;

        public const sbyte FF_PROFILE_DTS_96_24 = 40;

        public const sbyte FF_PROFILE_DTS_HD_HRA = 50;

        public const sbyte FF_PROFILE_DTS_HD_MA = 60;

        public const sbyte FF_PROFILE_MPEG2_422 = 0;

        public const sbyte FF_PROFILE_MPEG2_HIGH = 1;

        public const sbyte FF_PROFILE_MPEG2_SS = 2;

        public const sbyte FF_PROFILE_MPEG2_SNR_SCALABLE = 3;

        public const sbyte FF_PROFILE_MPEG2_MAIN = 4;

        public const sbyte FF_PROFILE_MPEG2_SIMPLE = 5;

        public const sbyte FF_PROFILE_H264_BASELINE = 66;

        public const sbyte FF_PROFILE_H264_MAIN = 77;

        public const sbyte FF_PROFILE_H264_EXTENDED = 88;

        public const sbyte FF_PROFILE_H264_HIGH = 100;

        public const sbyte FF_PROFILE_H264_HIGH_10 = 110;

        public const sbyte FF_PROFILE_H264_HIGH_422 = 122;

        public const byte FF_PROFILE_H264_HIGH_444 = 144;

        public const byte FF_PROFILE_H264_HIGH_444_PREDICTIVE = 244;

        public const sbyte FF_PROFILE_H264_CAVLC_444 = 44;

        public const sbyte FF_PROFILE_VC1_SIMPLE = 0;

        public const sbyte FF_PROFILE_VC1_MAIN = 1;

        public const sbyte FF_PROFILE_VC1_COMPLEX = 2;

        public const sbyte FF_PROFILE_VC1_ADVANCED = 3;

        public const sbyte FF_PROFILE_MPEG4_SIMPLE = 0;

        public const sbyte FF_PROFILE_MPEG4_SIMPLE_SCALABLE = 1;

        public const sbyte FF_PROFILE_MPEG4_CORE = 2;

        public const sbyte FF_PROFILE_MPEG4_MAIN = 3;

        public const sbyte FF_PROFILE_MPEG4_N_BIT = 4;

        public const sbyte FF_PROFILE_MPEG4_SCALABLE_TEXTURE = 5;

        public const sbyte FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = 6;

        public const sbyte FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = 7;

        public const sbyte FF_PROFILE_MPEG4_HYBRID = 8;

        public const sbyte FF_PROFILE_MPEG4_ADVANCED_REAL_TIME = 9;

        public const sbyte FF_PROFILE_MPEG4_CORE_SCALABLE = 10;

        public const sbyte FF_PROFILE_MPEG4_ADVANCED_CODING = 11;

        public const sbyte FF_PROFILE_MPEG4_ADVANCED_CORE = 12;

        public const sbyte FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = 13;

        public const sbyte FF_PROFILE_MPEG4_SIMPLE_STUDIO = 14;

        public const sbyte FF_PROFILE_MPEG4_ADVANCED_SIMPLE = 15;

        public const sbyte FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = 0;

        public const sbyte FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = 1;

        public const sbyte FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = 2;

        public const sbyte FF_PROFILE_JPEG2000_DCINEMA_2K = 3;

        public const sbyte FF_PROFILE_JPEG2000_DCINEMA_4K = 4;

        public const sbyte FF_PROFILE_HEVC_MAIN = 1;

        public const sbyte FF_PROFILE_HEVC_MAIN_10 = 2;

        public const sbyte FF_PROFILE_HEVC_MAIN_STILL_PICTURE = 3;

        public const sbyte FF_LEVEL_UNKNOWN = -99;

        public const sbyte FF_SUB_CHARENC_MODE_DO_NOTHING = -1;

        public const sbyte FF_SUB_CHARENC_MODE_AUTOMATIC = 0;

        public const sbyte FF_SUB_CHARENC_MODE_PRE_DECODER = 1;

        public const sbyte AV_SUBTITLE_FLAG_FORCED = 1;

        public const sbyte AV_PARSER_PTS_NB = 4;

        public const sbyte PARSER_FLAG_COMPLETE_FRAMES = 1;

        public const sbyte PARSER_FLAG_ONCE = 2;

        public const sbyte PARSER_FLAG_FETCHED_OFFSET = 4;

        public const short PARSER_FLAG_USE_CODEC_TS = 1000;

        public const sbyte FF_LOSS_RESOLUTION = 1;

        public const sbyte FF_LOSS_DEPTH = 2;

        public const sbyte FF_LOSS_COLORSPACE = 4;

        public const sbyte FF_LOSS_ALPHA = 8;

        public const sbyte FF_LOSS_COLORQUANT = 10;

        public const sbyte FF_LOSS_CHROMA = 20;

        /// <summary>
        /// Identify the syntax and semantics of the bitstream.
        /// The principle is roughly:
        /// Two decoders with the same ID can decode the same streams.
        /// Two encoders with the same ID can encode compatible streams.
        /// There may be slight deviations from the principle due to implementation
        /// details.
        /// 
        /// If you add a codec ID to this list, add it so that
        /// 1. no value of a existing codec ID changes (that would break ABI),
        /// 2. Give it a value which when taken as ASCII is recognized uniquely by
        /// a human as this specific codec.
        /// This ensures that 2 forks can independently add AVCodecIDs without
        /// producing conflicts.
        /// 
        /// After adding new codec IDs, do not forget to add an entry to the codec
        /// descriptor list and bump libavcodec minor version.
        /// </summary>
        public enum AVCodecID
        {
            AV_CODEC_ID_NONE = 0,
            AV_CODEC_ID_MPEG1VIDEO = 1,
            /// <summary>preferred ID for MPEG-1/2 video decoding</summary>
            AV_CODEC_ID_MPEG2VIDEO = 2,
            AV_CODEC_ID_MPEG2VIDEO_XVMC = 3,
            AV_CODEC_ID_H261 = 4,
            AV_CODEC_ID_H263 = 5,
            AV_CODEC_ID_RV10 = 6,
            AV_CODEC_ID_RV20 = 7,
            AV_CODEC_ID_MJPEG = 8,
            AV_CODEC_ID_MJPEGB = 9,
            AV_CODEC_ID_LJPEG = 10,
            AV_CODEC_ID_SP5X = 11,
            AV_CODEC_ID_JPEGLS = 12,
            AV_CODEC_ID_MPEG4 = 13,
            AV_CODEC_ID_RAWVIDEO = 14,
            AV_CODEC_ID_MSMPEG4V1 = 15,
            AV_CODEC_ID_MSMPEG4V2 = 16,
            AV_CODEC_ID_MSMPEG4V3 = 17,
            AV_CODEC_ID_WMV1 = 18,
            AV_CODEC_ID_WMV2 = 19,
            AV_CODEC_ID_H263P = 20,
            AV_CODEC_ID_H263I = 21,
            AV_CODEC_ID_FLV1 = 22,
            AV_CODEC_ID_SVQ1 = 23,
            AV_CODEC_ID_SVQ3 = 24,
            AV_CODEC_ID_DVVIDEO = 25,
            AV_CODEC_ID_HUFFYUV = 26,
            AV_CODEC_ID_CYUV = 27,
            AV_CODEC_ID_H264 = 28,
            AV_CODEC_ID_INDEO3 = 29,
            AV_CODEC_ID_VP3 = 30,
            AV_CODEC_ID_THEORA = 31,
            AV_CODEC_ID_ASV1 = 32,
            AV_CODEC_ID_ASV2 = 33,
            AV_CODEC_ID_FFV1 = 34,
            AV_CODEC_ID_4XM = 35,
            AV_CODEC_ID_VCR1 = 36,
            AV_CODEC_ID_CLJR = 37,
            AV_CODEC_ID_MDEC = 38,
            AV_CODEC_ID_ROQ = 39,
            AV_CODEC_ID_INTERPLAY_VIDEO = 40,
            AV_CODEC_ID_XAN_WC3 = 41,
            AV_CODEC_ID_XAN_WC4 = 42,
            AV_CODEC_ID_RPZA = 43,
            AV_CODEC_ID_CINEPAK = 44,
            AV_CODEC_ID_WS_VQA = 45,
            AV_CODEC_ID_MSRLE = 46,
            AV_CODEC_ID_MSVIDEO1 = 47,
            AV_CODEC_ID_IDCIN = 48,
            AV_CODEC_ID_8BPS = 49,
            AV_CODEC_ID_SMC = 50,
            AV_CODEC_ID_FLIC = 51,
            AV_CODEC_ID_TRUEMOTION1 = 52,
            AV_CODEC_ID_VMDVIDEO = 53,
            AV_CODEC_ID_MSZH = 54,
            AV_CODEC_ID_ZLIB = 55,
            AV_CODEC_ID_QTRLE = 56,
            AV_CODEC_ID_TSCC = 57,
            AV_CODEC_ID_ULTI = 58,
            AV_CODEC_ID_QDRAW = 59,
            AV_CODEC_ID_VIXL = 60,
            AV_CODEC_ID_QPEG = 61,
            AV_CODEC_ID_PNG = 62,
            AV_CODEC_ID_PPM = 63,
            AV_CODEC_ID_PBM = 64,
            AV_CODEC_ID_PGM = 65,
            AV_CODEC_ID_PGMYUV = 66,
            AV_CODEC_ID_PAM = 67,
            AV_CODEC_ID_FFVHUFF = 68,
            AV_CODEC_ID_RV30 = 69,
            AV_CODEC_ID_RV40 = 70,
            AV_CODEC_ID_VC1 = 71,
            AV_CODEC_ID_WMV3 = 72,
            AV_CODEC_ID_LOCO = 73,
            AV_CODEC_ID_WNV1 = 74,
            AV_CODEC_ID_AASC = 75,
            AV_CODEC_ID_INDEO2 = 76,
            AV_CODEC_ID_FRAPS = 77,
            AV_CODEC_ID_TRUEMOTION2 = 78,
            AV_CODEC_ID_BMP = 79,
            AV_CODEC_ID_CSCD = 80,
            AV_CODEC_ID_MMVIDEO = 81,
            AV_CODEC_ID_ZMBV = 82,
            AV_CODEC_ID_AVS = 83,
            AV_CODEC_ID_SMACKVIDEO = 84,
            AV_CODEC_ID_NUV = 85,
            AV_CODEC_ID_KMVC = 86,
            AV_CODEC_ID_FLASHSV = 87,
            AV_CODEC_ID_CAVS = 88,
            AV_CODEC_ID_JPEG2000 = 89,
            AV_CODEC_ID_VMNC = 90,
            AV_CODEC_ID_VP5 = 91,
            AV_CODEC_ID_VP6 = 92,
            AV_CODEC_ID_VP6F = 93,
            AV_CODEC_ID_TARGA = 94,
            AV_CODEC_ID_DSICINVIDEO = 95,
            AV_CODEC_ID_TIERTEXSEQVIDEO = 96,
            AV_CODEC_ID_TIFF = 97,
            AV_CODEC_ID_GIF = 98,
            AV_CODEC_ID_DXA = 99,
            AV_CODEC_ID_DNXHD = 100,
            AV_CODEC_ID_THP = 101,
            AV_CODEC_ID_SGI = 102,
            AV_CODEC_ID_C93 = 103,
            AV_CODEC_ID_BETHSOFTVID = 104,
            AV_CODEC_ID_PTX = 105,
            AV_CODEC_ID_TXD = 106,
            AV_CODEC_ID_VP6A = 107,
            AV_CODEC_ID_AMV = 108,
            AV_CODEC_ID_VB = 109,
            AV_CODEC_ID_PCX = 110,
            AV_CODEC_ID_SUNRAST = 111,
            AV_CODEC_ID_INDEO4 = 112,
            AV_CODEC_ID_INDEO5 = 113,
            AV_CODEC_ID_MIMIC = 114,
            AV_CODEC_ID_RL2 = 115,
            AV_CODEC_ID_ESCAPE124 = 116,
            AV_CODEC_ID_DIRAC = 117,
            AV_CODEC_ID_BFI = 118,
            AV_CODEC_ID_CMV = 119,
            AV_CODEC_ID_MOTIONPIXELS = 120,
            AV_CODEC_ID_TGV = 121,
            AV_CODEC_ID_TGQ = 122,
            AV_CODEC_ID_TQI = 123,
            AV_CODEC_ID_AURA = 124,
            AV_CODEC_ID_AURA2 = 125,
            AV_CODEC_ID_V210X = 126,
            AV_CODEC_ID_TMV = 127,
            AV_CODEC_ID_V210 = 128,
            AV_CODEC_ID_DPX = 129,
            AV_CODEC_ID_MAD = 130,
            AV_CODEC_ID_FRWU = 131,
            AV_CODEC_ID_FLASHSV2 = 132,
            AV_CODEC_ID_CDGRAPHICS = 133,
            AV_CODEC_ID_R210 = 134,
            AV_CODEC_ID_ANM = 135,
            AV_CODEC_ID_BINKVIDEO = 136,
            AV_CODEC_ID_IFF_ILBM = 137,
            AV_CODEC_ID_IFF_BYTERUN1 = 138,
            AV_CODEC_ID_KGV1 = 139,
            AV_CODEC_ID_YOP = 140,
            AV_CODEC_ID_VP8 = 141,
            AV_CODEC_ID_PICTOR = 142,
            AV_CODEC_ID_ANSI = 143,
            AV_CODEC_ID_A64_MULTI = 144,
            AV_CODEC_ID_A64_MULTI5 = 145,
            AV_CODEC_ID_R10K = 146,
            AV_CODEC_ID_MXPEG = 147,
            AV_CODEC_ID_LAGARITH = 148,
            AV_CODEC_ID_PRORES = 149,
            AV_CODEC_ID_JV = 150,
            AV_CODEC_ID_DFA = 151,
            AV_CODEC_ID_WMV3IMAGE = 152,
            AV_CODEC_ID_VC1IMAGE = 153,
            AV_CODEC_ID_UTVIDEO = 154,
            AV_CODEC_ID_BMV_VIDEO = 155,
            AV_CODEC_ID_VBLE = 156,
            AV_CODEC_ID_DXTORY = 157,
            AV_CODEC_ID_V410 = 158,
            AV_CODEC_ID_XWD = 159,
            AV_CODEC_ID_CDXL = 160,
            AV_CODEC_ID_XBM = 161,
            AV_CODEC_ID_ZEROCODEC = 162,
            AV_CODEC_ID_MSS1 = 163,
            AV_CODEC_ID_MSA1 = 164,
            AV_CODEC_ID_TSCC2 = 165,
            AV_CODEC_ID_MTS2 = 166,
            AV_CODEC_ID_CLLC = 167,
            AV_CODEC_ID_MSS2 = 168,
            AV_CODEC_ID_VP9 = 169,
            AV_CODEC_ID_AIC = 170,
            AV_CODEC_ID_ESCAPE130_DEPRECATED = 171,
            AV_CODEC_ID_G2M_DEPRECATED = 172,
            AV_CODEC_ID_WEBP_DEPRECATED = 173,
            AV_CODEC_ID_HNM4_VIDEO = 174,
            AV_CODEC_ID_HEVC_DEPRECATED = 175,
            AV_CODEC_ID_FIC = 176,
            AV_CODEC_ID_BRENDER_PIX = 1112557912,
            AV_CODEC_ID_Y41P = 1496592720,
            AV_CODEC_ID_ESCAPE130 = 1160852272,
            AV_CODEC_ID_EXR = 809850962,
            AV_CODEC_ID_AVRP = 1096176208,
            AV_CODEC_ID_012V = 808530518,
            AV_CODEC_ID_G2M = 4665933,
            AV_CODEC_ID_AVUI = 1096176969,
            AV_CODEC_ID_AYUV = 1096373590,
            AV_CODEC_ID_TARGA_Y216 = 1412575542,
            AV_CODEC_ID_V308 = 1446195256,
            AV_CODEC_ID_V408 = 1446260792,
            AV_CODEC_ID_YUV4 = 1498764852,
            AV_CODEC_ID_SANM = 1396788813,
            AV_CODEC_ID_PAF_VIDEO = 1346455126,
            AV_CODEC_ID_AVRN = 1096176238,
            AV_CODEC_ID_CPIA = 1129335105,
            AV_CODEC_ID_XFACE = 1480999235,
            AV_CODEC_ID_SGIRLE = 1397180754,
            AV_CODEC_ID_MVC1 = 1297498929,
            AV_CODEC_ID_MVC2 = 1297498930,
            AV_CODEC_ID_SNOW = 1397641047,
            AV_CODEC_ID_WEBP = 1464156752,
            AV_CODEC_ID_SMVJPEG = 1397577290,
            AV_CODEC_ID_HEVC = 1211250229,
            /// <summary>A dummy id pointing at the start of audio codecs</summary>
            AV_CODEC_ID_FIRST_AUDIO = 65536,
            AV_CODEC_ID_PCM_S16LE = 65536,
            AV_CODEC_ID_PCM_S16BE = 65537,
            AV_CODEC_ID_PCM_U16LE = 65538,
            AV_CODEC_ID_PCM_U16BE = 65539,
            AV_CODEC_ID_PCM_S8 = 65540,
            AV_CODEC_ID_PCM_U8 = 65541,
            AV_CODEC_ID_PCM_MULAW = 65542,
            AV_CODEC_ID_PCM_ALAW = 65543,
            AV_CODEC_ID_PCM_S32LE = 65544,
            AV_CODEC_ID_PCM_S32BE = 65545,
            AV_CODEC_ID_PCM_U32LE = 65546,
            AV_CODEC_ID_PCM_U32BE = 65547,
            AV_CODEC_ID_PCM_S24LE = 65548,
            AV_CODEC_ID_PCM_S24BE = 65549,
            AV_CODEC_ID_PCM_U24LE = 65550,
            AV_CODEC_ID_PCM_U24BE = 65551,
            AV_CODEC_ID_PCM_S24DAUD = 65552,
            AV_CODEC_ID_PCM_ZORK = 65553,
            AV_CODEC_ID_PCM_S16LE_PLANAR = 65554,
            AV_CODEC_ID_PCM_DVD = 65555,
            AV_CODEC_ID_PCM_F32BE = 65556,
            AV_CODEC_ID_PCM_F32LE = 65557,
            AV_CODEC_ID_PCM_F64BE = 65558,
            AV_CODEC_ID_PCM_F64LE = 65559,
            AV_CODEC_ID_PCM_BLURAY = 65560,
            AV_CODEC_ID_PCM_LXF = 65561,
            AV_CODEC_ID_S302M = 65562,
            AV_CODEC_ID_PCM_S8_PLANAR = 65563,
            AV_CODEC_ID_PCM_S24LE_PLANAR_DEPRECATED = 65564,
            AV_CODEC_ID_PCM_S32LE_PLANAR_DEPRECATED = 65565,
            AV_CODEC_ID_PCM_S24LE_PLANAR = 407917392,
            AV_CODEC_ID_PCM_S32LE_PLANAR = 542135120,
            AV_CODEC_ID_PCM_S16BE_PLANAR = 1347637264,
            AV_CODEC_ID_ADPCM_IMA_QT = 69632,
            AV_CODEC_ID_ADPCM_IMA_WAV = 69633,
            AV_CODEC_ID_ADPCM_IMA_DK3 = 69634,
            AV_CODEC_ID_ADPCM_IMA_DK4 = 69635,
            AV_CODEC_ID_ADPCM_IMA_WS = 69636,
            AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637,
            AV_CODEC_ID_ADPCM_MS = 69638,
            AV_CODEC_ID_ADPCM_4XM = 69639,
            AV_CODEC_ID_ADPCM_XA = 69640,
            AV_CODEC_ID_ADPCM_ADX = 69641,
            AV_CODEC_ID_ADPCM_EA = 69642,
            AV_CODEC_ID_ADPCM_G726 = 69643,
            AV_CODEC_ID_ADPCM_CT = 69644,
            AV_CODEC_ID_ADPCM_SWF = 69645,
            AV_CODEC_ID_ADPCM_YAMAHA = 69646,
            AV_CODEC_ID_ADPCM_SBPRO_4 = 69647,
            AV_CODEC_ID_ADPCM_SBPRO_3 = 69648,
            AV_CODEC_ID_ADPCM_SBPRO_2 = 69649,
            AV_CODEC_ID_ADPCM_THP = 69650,
            AV_CODEC_ID_ADPCM_IMA_AMV = 69651,
            AV_CODEC_ID_ADPCM_EA_R1 = 69652,
            AV_CODEC_ID_ADPCM_EA_R3 = 69653,
            AV_CODEC_ID_ADPCM_EA_R2 = 69654,
            AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655,
            AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656,
            AV_CODEC_ID_ADPCM_EA_XAS = 69657,
            AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658,
            AV_CODEC_ID_ADPCM_IMA_ISS = 69659,
            AV_CODEC_ID_ADPCM_G722 = 69660,
            AV_CODEC_ID_ADPCM_IMA_APC = 69661,
            AV_CODEC_ID_VIMA = 1447644481,
            AV_CODEC_ID_ADPCM_AFC = 1095123744,
            AV_CODEC_ID_ADPCM_IMA_OKI = 1330333984,
            AV_CODEC_ID_ADPCM_DTK = 1146374944,
            AV_CODEC_ID_ADPCM_IMA_RAD = 1380008992,
            AV_CODEC_ID_ADPCM_G726LE = 909260615,
            AV_CODEC_ID_AMR_NB = 73728,
            AV_CODEC_ID_AMR_WB = 73729,
            AV_CODEC_ID_RA_144 = 77824,
            AV_CODEC_ID_RA_288 = 77825,
            AV_CODEC_ID_ROQ_DPCM = 81920,
            AV_CODEC_ID_INTERPLAY_DPCM = 81921,
            AV_CODEC_ID_XAN_DPCM = 81922,
            AV_CODEC_ID_SOL_DPCM = 81923,
            AV_CODEC_ID_MP2 = 86016,
            /// <summary>preferred ID for decoding MPEG audio layer 1, 2 or 3</summary>
            AV_CODEC_ID_MP3 = 86017,
            AV_CODEC_ID_AAC = 86018,
            AV_CODEC_ID_AC3 = 86019,
            AV_CODEC_ID_DTS = 86020,
            AV_CODEC_ID_VORBIS = 86021,
            AV_CODEC_ID_DVAUDIO = 86022,
            AV_CODEC_ID_WMAV1 = 86023,
            AV_CODEC_ID_WMAV2 = 86024,
            AV_CODEC_ID_MACE3 = 86025,
            AV_CODEC_ID_MACE6 = 86026,
            AV_CODEC_ID_VMDAUDIO = 86027,
            AV_CODEC_ID_FLAC = 86028,
            AV_CODEC_ID_MP3ADU = 86029,
            AV_CODEC_ID_MP3ON4 = 86030,
            AV_CODEC_ID_SHORTEN = 86031,
            AV_CODEC_ID_ALAC = 86032,
            AV_CODEC_ID_WESTWOOD_SND1 = 86033,
            /// <summary>as in Berlin toast format</summary>
            AV_CODEC_ID_GSM = 86034,
            AV_CODEC_ID_QDM2 = 86035,
            AV_CODEC_ID_COOK = 86036,
            AV_CODEC_ID_TRUESPEECH = 86037,
            AV_CODEC_ID_TTA = 86038,
            AV_CODEC_ID_SMACKAUDIO = 86039,
            AV_CODEC_ID_QCELP = 86040,
            AV_CODEC_ID_WAVPACK = 86041,
            AV_CODEC_ID_DSICINAUDIO = 86042,
            AV_CODEC_ID_IMC = 86043,
            AV_CODEC_ID_MUSEPACK7 = 86044,
            AV_CODEC_ID_MLP = 86045,
            AV_CODEC_ID_GSM_MS = 86046,
            AV_CODEC_ID_ATRAC3 = 86047,
            AV_CODEC_ID_VOXWARE = 86048,
            AV_CODEC_ID_APE = 86049,
            AV_CODEC_ID_NELLYMOSER = 86050,
            AV_CODEC_ID_MUSEPACK8 = 86051,
            AV_CODEC_ID_SPEEX = 86052,
            AV_CODEC_ID_WMAVOICE = 86053,
            AV_CODEC_ID_WMAPRO = 86054,
            AV_CODEC_ID_WMALOSSLESS = 86055,
            AV_CODEC_ID_ATRAC3P = 86056,
            AV_CODEC_ID_EAC3 = 86057,
            AV_CODEC_ID_SIPR = 86058,
            AV_CODEC_ID_MP1 = 86059,
            AV_CODEC_ID_TWINVQ = 86060,
            AV_CODEC_ID_TRUEHD = 86061,
            AV_CODEC_ID_MP4ALS = 86062,
            AV_CODEC_ID_ATRAC1 = 86063,
            AV_CODEC_ID_BINKAUDIO_RDFT = 86064,
            AV_CODEC_ID_BINKAUDIO_DCT = 86065,
            AV_CODEC_ID_AAC_LATM = 86066,
            AV_CODEC_ID_QDMC = 86067,
            AV_CODEC_ID_CELT = 86068,
            AV_CODEC_ID_G723_1 = 86069,
            AV_CODEC_ID_G729 = 86070,
            AV_CODEC_ID_8SVX_EXP = 86071,
            AV_CODEC_ID_8SVX_FIB = 86072,
            AV_CODEC_ID_BMV_AUDIO = 86073,
            AV_CODEC_ID_RALF = 86074,
            AV_CODEC_ID_IAC = 86075,
            AV_CODEC_ID_ILBC = 86076,
            AV_CODEC_ID_OPUS_DEPRECATED = 86077,
            AV_CODEC_ID_COMFORT_NOISE = 86078,
            AV_CODEC_ID_TAK_DEPRECATED = 86079,
            AV_CODEC_ID_METASOUND = 86080,
            AV_CODEC_ID_FFWAVESYNTH = 1179014995,
            AV_CODEC_ID_SONIC = 1397706307,
            AV_CODEC_ID_SONIC_LS = 1397706316,
            AV_CODEC_ID_PAF_AUDIO = 1346455105,
            AV_CODEC_ID_OPUS = 1330664787,
            AV_CODEC_ID_TAK = 1950507339,
            AV_CODEC_ID_EVRC = 1936029283,
            AV_CODEC_ID_SMV = 1936944502,
            /// <summary>A dummy ID pointing at the start of subtitle codecs.</summary>
            AV_CODEC_ID_FIRST_SUBTITLE = 94208,
            AV_CODEC_ID_DVD_SUBTITLE = 94208,
            AV_CODEC_ID_DVB_SUBTITLE = 94209,
            /// <summary>raw UTF-8 text</summary>
            AV_CODEC_ID_TEXT = 94210,
            AV_CODEC_ID_XSUB = 94211,
            AV_CODEC_ID_SSA = 94212,
            AV_CODEC_ID_MOV_TEXT = 94213,
            AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214,
            AV_CODEC_ID_DVB_TELETEXT = 94215,
            AV_CODEC_ID_SRT = 94216,
            AV_CODEC_ID_MICRODVD = 1833195076,
            AV_CODEC_ID_EIA_608 = 1664495672,
            AV_CODEC_ID_JACOSUB = 1246975298,
            AV_CODEC_ID_SAMI = 1396788553,
            AV_CODEC_ID_REALTEXT = 1381259348,
            AV_CODEC_ID_SUBVIEWER1 = 1398953521,
            AV_CODEC_ID_SUBVIEWER = 1400201814,
            AV_CODEC_ID_SUBRIP = 1397909872,
            AV_CODEC_ID_WEBVTT = 1465275476,
            AV_CODEC_ID_MPL2 = 1297108018,
            AV_CODEC_ID_VPLAYER = 1448111218,
            AV_CODEC_ID_PJS = 1349012051,
            /// <summary>ASS as defined in Matroska</summary>
            AV_CODEC_ID_ASS = 1095979808,
            /// <summary>A dummy ID pointing at the start of various fake codecs.</summary>
            AV_CODEC_ID_FIRST_UNKNOWN = 98304,
            AV_CODEC_ID_TTF = 98304,
            AV_CODEC_ID_BINTEXT = 1112823892,
            AV_CODEC_ID_XBIN = 1480739150,
            AV_CODEC_ID_IDF = 4801606,
            AV_CODEC_ID_OTF = 5198918,
            AV_CODEC_ID_SMPTE_KLV = 1263294017,
            AV_CODEC_ID_DVD_NAV = 1145979222,
            AV_CODEC_ID_TIMED_ID3 = 1414087731,
            /// <summary>codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it</summary>
            AV_CODEC_ID_PROBE = 102400,
            /// <summary>_FAKE_ codec to indicate a raw MPEG-2 TS stream (only used by libavformat)</summary>
            AV_CODEC_ID_MPEG2TS = 131072,
            /// <summary>_FAKE_ codec to indicate a MPEG-4 Systems stream (only used by libavformat)</summary>
            AV_CODEC_ID_MPEG4SYSTEMS = 131073,
            /// <summary>Dummy codec for streams containing only metadata information.</summary>
            AV_CODEC_ID_FFMETADATA = 135168,
            CODEC_ID_NONE = 0,
            CODEC_ID_MPEG1VIDEO = 1,
            /// <summary>preferred ID for MPEG-1/2 video decoding</summary>
            CODEC_ID_MPEG2VIDEO = 2,
            CODEC_ID_MPEG2VIDEO_XVMC = 3,
            CODEC_ID_H261 = 4,
            CODEC_ID_H263 = 5,
            CODEC_ID_RV10 = 6,
            CODEC_ID_RV20 = 7,
            CODEC_ID_MJPEG = 8,
            CODEC_ID_MJPEGB = 9,
            CODEC_ID_LJPEG = 10,
            CODEC_ID_SP5X = 11,
            CODEC_ID_JPEGLS = 12,
            CODEC_ID_MPEG4 = 13,
            CODEC_ID_RAWVIDEO = 14,
            CODEC_ID_MSMPEG4V1 = 15,
            CODEC_ID_MSMPEG4V2 = 16,
            CODEC_ID_MSMPEG4V3 = 17,
            CODEC_ID_WMV1 = 18,
            CODEC_ID_WMV2 = 19,
            CODEC_ID_H263P = 20,
            CODEC_ID_H263I = 21,
            CODEC_ID_FLV1 = 22,
            CODEC_ID_SVQ1 = 23,
            CODEC_ID_SVQ3 = 24,
            CODEC_ID_DVVIDEO = 25,
            CODEC_ID_HUFFYUV = 26,
            CODEC_ID_CYUV = 27,
            CODEC_ID_H264 = 28,
            CODEC_ID_INDEO3 = 29,
            CODEC_ID_VP3 = 30,
            CODEC_ID_THEORA = 31,
            CODEC_ID_ASV1 = 32,
            CODEC_ID_ASV2 = 33,
            CODEC_ID_FFV1 = 34,
            CODEC_ID_4XM = 35,
            CODEC_ID_VCR1 = 36,
            CODEC_ID_CLJR = 37,
            CODEC_ID_MDEC = 38,
            CODEC_ID_ROQ = 39,
            CODEC_ID_INTERPLAY_VIDEO = 40,
            CODEC_ID_XAN_WC3 = 41,
            CODEC_ID_XAN_WC4 = 42,
            CODEC_ID_RPZA = 43,
            CODEC_ID_CINEPAK = 44,
            CODEC_ID_WS_VQA = 45,
            CODEC_ID_MSRLE = 46,
            CODEC_ID_MSVIDEO1 = 47,
            CODEC_ID_IDCIN = 48,
            CODEC_ID_8BPS = 49,
            CODEC_ID_SMC = 50,
            CODEC_ID_FLIC = 51,
            CODEC_ID_TRUEMOTION1 = 52,
            CODEC_ID_VMDVIDEO = 53,
            CODEC_ID_MSZH = 54,
            CODEC_ID_ZLIB = 55,
            CODEC_ID_QTRLE = 56,
            CODEC_ID_TSCC = 57,
            CODEC_ID_ULTI = 58,
            CODEC_ID_QDRAW = 59,
            CODEC_ID_VIXL = 60,
            CODEC_ID_QPEG = 61,
            CODEC_ID_PNG = 62,
            CODEC_ID_PPM = 63,
            CODEC_ID_PBM = 64,
            CODEC_ID_PGM = 65,
            CODEC_ID_PGMYUV = 66,
            CODEC_ID_PAM = 67,
            CODEC_ID_FFVHUFF = 68,
            CODEC_ID_RV30 = 69,
            CODEC_ID_RV40 = 70,
            CODEC_ID_VC1 = 71,
            CODEC_ID_WMV3 = 72,
            CODEC_ID_LOCO = 73,
            CODEC_ID_WNV1 = 74,
            CODEC_ID_AASC = 75,
            CODEC_ID_INDEO2 = 76,
            CODEC_ID_FRAPS = 77,
            CODEC_ID_TRUEMOTION2 = 78,
            CODEC_ID_BMP = 79,
            CODEC_ID_CSCD = 80,
            CODEC_ID_MMVIDEO = 81,
            CODEC_ID_ZMBV = 82,
            CODEC_ID_AVS = 83,
            CODEC_ID_SMACKVIDEO = 84,
            CODEC_ID_NUV = 85,
            CODEC_ID_KMVC = 86,
            CODEC_ID_FLASHSV = 87,
            CODEC_ID_CAVS = 88,
            CODEC_ID_JPEG2000 = 89,
            CODEC_ID_VMNC = 90,
            CODEC_ID_VP5 = 91,
            CODEC_ID_VP6 = 92,
            CODEC_ID_VP6F = 93,
            CODEC_ID_TARGA = 94,
            CODEC_ID_DSICINVIDEO = 95,
            CODEC_ID_TIERTEXSEQVIDEO = 96,
            CODEC_ID_TIFF = 97,
            CODEC_ID_GIF = 98,
            CODEC_ID_DXA = 99,
            CODEC_ID_DNXHD = 100,
            CODEC_ID_THP = 101,
            CODEC_ID_SGI = 102,
            CODEC_ID_C93 = 103,
            CODEC_ID_BETHSOFTVID = 104,
            CODEC_ID_PTX = 105,
            CODEC_ID_TXD = 106,
            CODEC_ID_VP6A = 107,
            CODEC_ID_AMV = 108,
            CODEC_ID_VB = 109,
            CODEC_ID_PCX = 110,
            CODEC_ID_SUNRAST = 111,
            CODEC_ID_INDEO4 = 112,
            CODEC_ID_INDEO5 = 113,
            CODEC_ID_MIMIC = 114,
            CODEC_ID_RL2 = 115,
            CODEC_ID_ESCAPE124 = 116,
            CODEC_ID_DIRAC = 117,
            CODEC_ID_BFI = 118,
            CODEC_ID_CMV = 119,
            CODEC_ID_MOTIONPIXELS = 120,
            CODEC_ID_TGV = 121,
            CODEC_ID_TGQ = 122,
            CODEC_ID_TQI = 123,
            CODEC_ID_AURA = 124,
            CODEC_ID_AURA2 = 125,
            CODEC_ID_V210X = 126,
            CODEC_ID_TMV = 127,
            CODEC_ID_V210 = 128,
            CODEC_ID_DPX = 129,
            CODEC_ID_MAD = 130,
            CODEC_ID_FRWU = 131,
            CODEC_ID_FLASHSV2 = 132,
            CODEC_ID_CDGRAPHICS = 133,
            CODEC_ID_R210 = 134,
            CODEC_ID_ANM = 135,
            CODEC_ID_BINKVIDEO = 136,
            CODEC_ID_IFF_ILBM = 137,
            CODEC_ID_IFF_BYTERUN1 = 138,
            CODEC_ID_KGV1 = 139,
            CODEC_ID_YOP = 140,
            CODEC_ID_VP8 = 141,
            CODEC_ID_PICTOR = 142,
            CODEC_ID_ANSI = 143,
            CODEC_ID_A64_MULTI = 144,
            CODEC_ID_A64_MULTI5 = 145,
            CODEC_ID_R10K = 146,
            CODEC_ID_MXPEG = 147,
            CODEC_ID_LAGARITH = 148,
            CODEC_ID_PRORES = 149,
            CODEC_ID_JV = 150,
            CODEC_ID_DFA = 151,
            CODEC_ID_WMV3IMAGE = 152,
            CODEC_ID_VC1IMAGE = 153,
            CODEC_ID_UTVIDEO = 154,
            CODEC_ID_BMV_VIDEO = 155,
            CODEC_ID_VBLE = 156,
            CODEC_ID_DXTORY = 157,
            CODEC_ID_V410 = 158,
            CODEC_ID_XWD = 159,
            CODEC_ID_CDXL = 160,
            CODEC_ID_XBM = 161,
            CODEC_ID_ZEROCODEC = 162,
            CODEC_ID_MSS1 = 163,
            CODEC_ID_MSA1 = 164,
            CODEC_ID_TSCC2 = 165,
            CODEC_ID_MTS2 = 166,
            CODEC_ID_CLLC = 167,
            CODEC_ID_Y41P = 1496592720,
            CODEC_ID_ESCAPE130 = 1160852272,
            CODEC_ID_EXR = 809850962,
            CODEC_ID_AVRP = 1096176208,
            CODEC_ID_G2M = 4665933,
            CODEC_ID_AVUI = 1096176969,
            CODEC_ID_AYUV = 1096373590,
            CODEC_ID_V308 = 1446195256,
            CODEC_ID_V408 = 1446260792,
            CODEC_ID_YUV4 = 1498764852,
            CODEC_ID_SANM = 1396788813,
            CODEC_ID_PAF_VIDEO = 1346455126,
            CODEC_ID_SNOW = 1397641047,
            /// <summary>A dummy id pointing at the start of audio codecs</summary>
            CODEC_ID_FIRST_AUDIO = 65536,
            CODEC_ID_PCM_S16LE = 65536,
            CODEC_ID_PCM_S16BE = 65537,
            CODEC_ID_PCM_U16LE = 65538,
            CODEC_ID_PCM_U16BE = 65539,
            CODEC_ID_PCM_S8 = 65540,
            CODEC_ID_PCM_U8 = 65541,
            CODEC_ID_PCM_MULAW = 65542,
            CODEC_ID_PCM_ALAW = 65543,
            CODEC_ID_PCM_S32LE = 65544,
            CODEC_ID_PCM_S32BE = 65545,
            CODEC_ID_PCM_U32LE = 65546,
            CODEC_ID_PCM_U32BE = 65547,
            CODEC_ID_PCM_S24LE = 65548,
            CODEC_ID_PCM_S24BE = 65549,
            CODEC_ID_PCM_U24LE = 65550,
            CODEC_ID_PCM_U24BE = 65551,
            CODEC_ID_PCM_S24DAUD = 65552,
            CODEC_ID_PCM_ZORK = 65553,
            CODEC_ID_PCM_S16LE_PLANAR = 65554,
            CODEC_ID_PCM_DVD = 65555,
            CODEC_ID_PCM_F32BE = 65556,
            CODEC_ID_PCM_F32LE = 65557,
            CODEC_ID_PCM_F64BE = 65558,
            CODEC_ID_PCM_F64LE = 65559,
            CODEC_ID_PCM_BLURAY = 65560,
            CODEC_ID_PCM_LXF = 65561,
            CODEC_ID_S302M = 65562,
            CODEC_ID_PCM_S8_PLANAR = 65563,
            CODEC_ID_ADPCM_IMA_QT = 69632,
            CODEC_ID_ADPCM_IMA_WAV = 69633,
            CODEC_ID_ADPCM_IMA_DK3 = 69634,
            CODEC_ID_ADPCM_IMA_DK4 = 69635,
            CODEC_ID_ADPCM_IMA_WS = 69636,
            CODEC_ID_ADPCM_IMA_SMJPEG = 69637,
            CODEC_ID_ADPCM_MS = 69638,
            CODEC_ID_ADPCM_4XM = 69639,
            CODEC_ID_ADPCM_XA = 69640,
            CODEC_ID_ADPCM_ADX = 69641,
            CODEC_ID_ADPCM_EA = 69642,
            CODEC_ID_ADPCM_G726 = 69643,
            CODEC_ID_ADPCM_CT = 69644,
            CODEC_ID_ADPCM_SWF = 69645,
            CODEC_ID_ADPCM_YAMAHA = 69646,
            CODEC_ID_ADPCM_SBPRO_4 = 69647,
            CODEC_ID_ADPCM_SBPRO_3 = 69648,
            CODEC_ID_ADPCM_SBPRO_2 = 69649,
            CODEC_ID_ADPCM_THP = 69650,
            CODEC_ID_ADPCM_IMA_AMV = 69651,
            CODEC_ID_ADPCM_EA_R1 = 69652,
            CODEC_ID_ADPCM_EA_R3 = 69653,
            CODEC_ID_ADPCM_EA_R2 = 69654,
            CODEC_ID_ADPCM_IMA_EA_SEAD = 69655,
            CODEC_ID_ADPCM_IMA_EA_EACS = 69656,
            CODEC_ID_ADPCM_EA_XAS = 69657,
            CODEC_ID_ADPCM_EA_MAXIS_XA = 69658,
            CODEC_ID_ADPCM_IMA_ISS = 69659,
            CODEC_ID_ADPCM_G722 = 69660,
            CODEC_ID_ADPCM_IMA_APC = 69661,
            CODEC_ID_VIMA = 1447644481,
            CODEC_ID_AMR_NB = 73728,
            CODEC_ID_AMR_WB = 73729,
            CODEC_ID_RA_144 = 77824,
            CODEC_ID_RA_288 = 77825,
            CODEC_ID_ROQ_DPCM = 81920,
            CODEC_ID_INTERPLAY_DPCM = 81921,
            CODEC_ID_XAN_DPCM = 81922,
            CODEC_ID_SOL_DPCM = 81923,
            CODEC_ID_MP2 = 86016,
            /// <summary>preferred ID for decoding MPEG audio layer 1, 2 or 3</summary>
            CODEC_ID_MP3 = 86017,
            CODEC_ID_AAC = 86018,
            CODEC_ID_AC3 = 86019,
            CODEC_ID_DTS = 86020,
            CODEC_ID_VORBIS = 86021,
            CODEC_ID_DVAUDIO = 86022,
            CODEC_ID_WMAV1 = 86023,
            CODEC_ID_WMAV2 = 86024,
            CODEC_ID_MACE3 = 86025,
            CODEC_ID_MACE6 = 86026,
            CODEC_ID_VMDAUDIO = 86027,
            CODEC_ID_FLAC = 86028,
            CODEC_ID_MP3ADU = 86029,
            CODEC_ID_MP3ON4 = 86030,
            CODEC_ID_SHORTEN = 86031,
            CODEC_ID_ALAC = 86032,
            CODEC_ID_WESTWOOD_SND1 = 86033,
            /// <summary>as in Berlin toast format</summary>
            CODEC_ID_GSM = 86034,
            CODEC_ID_QDM2 = 86035,
            CODEC_ID_COOK = 86036,
            CODEC_ID_TRUESPEECH = 86037,
            CODEC_ID_TTA = 86038,
            CODEC_ID_SMACKAUDIO = 86039,
            CODEC_ID_QCELP = 86040,
            CODEC_ID_WAVPACK = 86041,
            CODEC_ID_DSICINAUDIO = 86042,
            CODEC_ID_IMC = 86043,
            CODEC_ID_MUSEPACK7 = 86044,
            CODEC_ID_MLP = 86045,
            CODEC_ID_GSM_MS = 86046,
            CODEC_ID_ATRAC3 = 86047,
            CODEC_ID_VOXWARE = 86048,
            CODEC_ID_APE = 86049,
            CODEC_ID_NELLYMOSER = 86050,
            CODEC_ID_MUSEPACK8 = 86051,
            CODEC_ID_SPEEX = 86052,
            CODEC_ID_WMAVOICE = 86053,
            CODEC_ID_WMAPRO = 86054,
            CODEC_ID_WMALOSSLESS = 86055,
            CODEC_ID_ATRAC3P = 86056,
            CODEC_ID_EAC3 = 86057,
            CODEC_ID_SIPR = 86058,
            CODEC_ID_MP1 = 86059,
            CODEC_ID_TWINVQ = 86060,
            CODEC_ID_TRUEHD = 86061,
            CODEC_ID_MP4ALS = 86062,
            CODEC_ID_ATRAC1 = 86063,
            CODEC_ID_BINKAUDIO_RDFT = 86064,
            CODEC_ID_BINKAUDIO_DCT = 86065,
            CODEC_ID_AAC_LATM = 86066,
            CODEC_ID_QDMC = 86067,
            CODEC_ID_CELT = 86068,
            CODEC_ID_G723_1 = 86069,
            CODEC_ID_G729 = 86070,
            CODEC_ID_8SVX_EXP = 86071,
            CODEC_ID_8SVX_FIB = 86072,
            CODEC_ID_BMV_AUDIO = 86073,
            CODEC_ID_RALF = 86074,
            CODEC_ID_IAC = 86075,
            CODEC_ID_ILBC = 86076,
            CODEC_ID_FFWAVESYNTH = 1179014995,
            CODEC_ID_SONIC = 1397706307,
            CODEC_ID_SONIC_LS = 1397706316,
            CODEC_ID_PAF_AUDIO = 1346455105,
            CODEC_ID_OPUS = 1330664787,
            /// <summary>A dummy ID pointing at the start of subtitle codecs.</summary>
            CODEC_ID_FIRST_SUBTITLE = 94208,
            CODEC_ID_DVD_SUBTITLE = 94208,
            CODEC_ID_DVB_SUBTITLE = 94209,
            /// <summary>raw UTF-8 text</summary>
            CODEC_ID_TEXT = 94210,
            CODEC_ID_XSUB = 94211,
            CODEC_ID_SSA = 94212,
            CODEC_ID_MOV_TEXT = 94213,
            CODEC_ID_HDMV_PGS_SUBTITLE = 94214,
            CODEC_ID_DVB_TELETEXT = 94215,
            CODEC_ID_SRT = 94216,
            CODEC_ID_MICRODVD = 1833195076,
            CODEC_ID_EIA_608 = 1664495672,
            CODEC_ID_JACOSUB = 1246975298,
            CODEC_ID_SAMI = 1396788553,
            CODEC_ID_REALTEXT = 1381259348,
            CODEC_ID_SUBVIEWER = 1400201814,
            /// <summary>A dummy ID pointing at the start of various fake codecs.</summary>
            CODEC_ID_FIRST_UNKNOWN = 98304,
            CODEC_ID_TTF = 98304,
            CODEC_ID_BINTEXT = 1112823892,
            CODEC_ID_XBIN = 1480739150,
            CODEC_ID_IDF = 4801606,
            CODEC_ID_OTF = 5198918,
            /// <summary>codec_id is not known (like CODEC_ID_NONE) but lavf should attempt to identify it</summary>
            CODEC_ID_PROBE = 102400,
            /// <summary>_FAKE_ codec to indicate a raw MPEG-2 TS stream (only used by libavformat)</summary>
            CODEC_ID_MPEG2TS = 131072,
            /// <summary>_FAKE_ codec to indicate a MPEG-4 Systems stream (only used by libavformat)</summary>
            CODEC_ID_MPEG4SYSTEMS = 131073,
            /// <summary>Dummy codec for streams containing only metadata information.</summary>
            CODEC_ID_FFMETADATA = 135168
        }

        /// <summary>
        /// @ingroup lavc_encoding
        /// motion estimation type.
        /// </summary>
        public enum Motion_Est_ID
        {
            /// <summary>no search, that is use 0,0 vector whenever one is needed</summary>
            ME_ZERO = 1,
            ME_FULL = 2,
            ME_LOG = 3,
            ME_PHODS = 4,
            /// <summary>enhanced predictive zonal search</summary>
            ME_EPZS = 5,
            /// <summary>reserved for experiments</summary>
            ME_X1 = 6,
            /// <summary>hexagon based search</summary>
            ME_HEX = 7,
            /// <summary>uneven multi-hexagon search</summary>
            ME_UMH = 8,
            /// <summary>transformed exhaustive search algorithm</summary>
            ME_TESA = 9,
            /// <summary>iterative search</summary>
            ME_ITER = 50
        }

        public enum AVDiscard
        {
            /// <summary>discard nothing</summary>
            AVDISCARD_NONE = -16,
            /// <summary>discard useless packets like 0 size packets in avi</summary>
            AVDISCARD_DEFAULT = 0,
            /// <summary>discard all non reference</summary>
            AVDISCARD_NONREF = 8,
            /// <summary>discard all bidirectional frames</summary>
            AVDISCARD_BIDIR = 16,
            /// <summary>discard all frames except keyframes</summary>
            AVDISCARD_NONKEY = 32,
            /// <summary>discard all</summary>
            AVDISCARD_ALL = 48
        }

        public enum AVColorPrimaries
        {
            /// <summary>also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B</summary>
            AVCOL_PRI_BT709 = 1,
            AVCOL_PRI_UNSPECIFIED = 2,
            AVCOL_PRI_BT470M = 4,
            /// <summary>also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM</summary>
            AVCOL_PRI_BT470BG = 5,
            /// <summary>also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC</summary>
            AVCOL_PRI_SMPTE170M = 6,
            /// <summary>functionally identical to above</summary>
            AVCOL_PRI_SMPTE240M = 7,
            AVCOL_PRI_FILM = 8,
            /// <summary>ITU-R BT2020</summary>
            AVCOL_PRI_BT2020 = 9,
            /// <summary>Not part of ABI</summary>
            AVCOL_PRI_NB = 10
        }

        public enum AVColorTransferCharacteristic
        {
            /// <summary>also ITU-R BT1361</summary>
            AVCOL_TRC_BT709 = 1,
            AVCOL_TRC_UNSPECIFIED = 2,
            /// <summary>also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM</summary>
            AVCOL_TRC_GAMMA22 = 4,
            /// <summary>also ITU-R BT470BG</summary>
            AVCOL_TRC_GAMMA28 = 5,
            /// <summary>also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC</summary>
            AVCOL_TRC_SMPTE170M = 6,
            AVCOL_TRC_SMPTE240M = 7,
            /// <summary>"Linear transfer characteristics"</summary>
            AVCOL_TRC_LINEAR = 8,
            /// <summary>"Logarithmic transfer characteristic (100:1 range)"</summary>
            AVCOL_TRC_LOG = 9,
            /// <summary>"Logarithmic transfer characteristic (100 * Sqrt( 10 ) : 1 range)"</summary>
            AVCOL_TRC_LOG_SQRT = 10,
            /// <summary>IEC 61966-2-4</summary>
            AVCOL_TRC_IEC61966_2_4 = 11,
            /// <summary>ITU-R BT1361 Extended Colour Gamut</summary>
            AVCOL_TRC_BT1361_ECG = 12,
            /// <summary>IEC 61966-2-1 (sRGB or sYCC)</summary>
            AVCOL_TRC_IEC61966_2_1 = 13,
            /// <summary>ITU-R BT2020 for 10 bit system</summary>
            AVCOL_TRC_BT2020_10 = 14,
            /// <summary>ITU-R BT2020 for 12 bit system</summary>
            AVCOL_TRC_BT2020_12 = 15,
            /// <summary>Not part of ABI</summary>
            AVCOL_TRC_NB = 16
        }

        /// <summary>
        /// X   X      3 4 X      X are luma samples,
        /// 1 2        1-6 are possible chroma positions
        /// X   X      5 6 X      0 is undefined/unknown position
        /// </summary>
        public enum AVChromaLocation
        {
            AVCHROMA_LOC_UNSPECIFIED = 0,
            /// <summary>mpeg2/4, h264 default</summary>
            AVCHROMA_LOC_LEFT = 1,
            /// <summary>mpeg1, jpeg, h263</summary>
            AVCHROMA_LOC_CENTER = 2,
            /// <summary>DV</summary>
            AVCHROMA_LOC_TOPLEFT = 3,
            AVCHROMA_LOC_TOP = 4,
            AVCHROMA_LOC_BOTTOMLEFT = 5,
            AVCHROMA_LOC_BOTTOM = 6,
            /// <summary>Not part of ABI</summary>
            AVCHROMA_LOC_NB = 7
        }

        public enum AVAudioServiceType
        {
            AV_AUDIO_SERVICE_TYPE_MAIN = 0,
            AV_AUDIO_SERVICE_TYPE_EFFECTS = 1,
            AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
            AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3,
            AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4,
            AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5,
            AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6,
            AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7,
            AV_AUDIO_SERVICE_TYPE_KARAOKE = 8,
            /// <summary>Not part of ABI</summary>
            AV_AUDIO_SERVICE_TYPE_NB = 9
        }

        /// <summary>
        /// @defgroup lavc_packet AVPacket
        /// 
        /// Types and functions for working with AVPacket.
        /// @{
        /// </summary>
        public enum AVPacketSideDataType
        {
            AV_PKT_DATA_PALETTE = 0,
            AV_PKT_DATA_NEW_EXTRADATA = 1,
            /// <summary>An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:</summary>
            AV_PKT_DATA_PARAM_CHANGE = 2,
            /// <summary>An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of structures with info about macroblocks relevant to splitting the packet into smaller packets on macroblock edges (e.g. as for RFC 2190). That is, it does not necessarily contain info about all macroblocks, as long as the distance between macroblocks in the info is smaller than the target payload size. Each MB info structure is 12 bytes, and is laid out as follows:</summary>
            AV_PKT_DATA_H263_MB_INFO = 3,
            /// <summary>Recommmends skipping the specified number of samples</summary>
            AV_PKT_DATA_SKIP_SAMPLES = 70,
            /// <summary>An AV_PKT_DATA_JP_DUALMONO side data packet indicates that the packet may contain "dual mono" audio specific to Japanese DTV and if it is true, recommends only the selected channel to be used.</summary>
            AV_PKT_DATA_JP_DUALMONO = 71,
            /// <summary>A list of zero terminated key/value strings. There is no end marker for the list, so it is required to rely on the side data size to stop.</summary>
            AV_PKT_DATA_STRINGS_METADATA = 72,
            /// <summary>Subtitle event position</summary>
            AV_PKT_DATA_SUBTITLE_POSITION = 73,
            /// <summary>Data found in BlockAdditional element of matroska container. There is no end marker for the data, so it is required to rely on the side data size to recognize the end. 8 byte id (as found in BlockAddId) followed by data.</summary>
            AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 74,
            /// <summary>The optional first identifier line of a WebVTT cue.</summary>
            AV_PKT_DATA_WEBVTT_IDENTIFIER = 75,
            /// <summary>The optional settings (rendering instructions) that immediately follow the timestamp specifier of a WebVTT cue.</summary>
            AV_PKT_DATA_WEBVTT_SETTINGS = 76,
            /// <summary>A list of zero terminated key/value strings. There is no end marker for the list, so it is required to rely on the side data size to stop. This side data includes updated metadata which appeared in the stream.</summary>
            AV_PKT_DATA_METADATA_UPDATE = 77
        }

        [Flags]
        public enum AVSideDataParamChangeFlags
        {
            AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 1,
            AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 2,
            AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 4,
            AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 8
        }

        public enum AVFieldOrder
        {
            AV_FIELD_UNKNOWN = 0,
            AV_FIELD_PROGRESSIVE = 1,
            AV_FIELD_TT = 2,
            AV_FIELD_BB = 3,
            AV_FIELD_TB = 4,
            AV_FIELD_BT = 5
        }

        /// <summary>
        /// @}
        /// </summary>
        public enum AVSubtitleType
        {
            SUBTITLE_NONE = 0,
            /// <summary>A bitmap, pict will be set</summary>
            SUBTITLE_BITMAP = 1,
            /// <summary>Plain text, the text field must be set by the decoder and is authoritative. ass and pict fields may contain approximations.</summary>
            SUBTITLE_TEXT = 2,
            /// <summary>Formatted text, the ass field must be set by the decoder and is authoritative. pict and text fields may contain approximations.</summary>
            SUBTITLE_ASS = 3
        }

        /// <summary>
        /// @defgroup lavc_parsing Frame parsing
        /// @{
        /// </summary>
        public enum AVPictureStructure
        {
            AV_PICTURE_STRUCTURE_UNKNOWN = 0,
            AV_PICTURE_STRUCTURE_TOP_FIELD = 1,
            AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2,
            AV_PICTURE_STRUCTURE_FRAME = 3
        }

        /// <summary>
        /// Lock operation used by lockmgr
        /// </summary>
        public enum AVLockOp
        {
            /// <summary>Create a mutex</summary>
            AV_LOCK_CREATE = 0,
            /// <summary>Lock the mutex</summary>
            AV_LOCK_OBTAIN = 1,
            /// <summary>Unlock the mutex</summary>
            AV_LOCK_RELEASE = 2,
            /// <summary>Free mutex resources</summary>
            AV_LOCK_DESTROY = 3
        }

        /// <summary>
        /// This struct describes the properties of a single codec described by an
        /// AVCodecID.
        /// @see avcodec_get_descriptor()
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVCodecDescriptor
        {
            public libavcodec.AVCodecID id;

            public libavutil.AVMediaType type;

            /// <summary>
            /// Name of the codec described by this descriptor. It is non-empty and
            /// unique for each codec descriptor. It should contain alphanumeric
            /// characters and '_' only.
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// A more descriptive name for this codec. May be NULL.
            /// </summary>
            public sbyte* long_name;

            /// <summary>
            /// Codec properties, a combination of AV_CODEC_PROP_* flags.
            /// </summary>
            public int props;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct RcOverride
        {
            public int start_frame;

            public int end_frame;

            public int qscale;

            public float quality_factor;
        }

        /// <summary>
        /// Pan Scan area.
        /// This specifies the area which should be displayed.
        /// Note there may be multiple such areas for one frame.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVPanScan
        {
            /// <summary>
            /// id
            /// - encoding: Set by user.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public int id;

            /// <summary>
            /// width and height in 1/16 pel
            /// - encoding: Set by user.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public int width;

            public int height;

            /// <summary>
            /// position of the top left corner in 1/16 pel for up to 3 fields/frames
            /// - encoding: Set by user.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public libavutil.ArrayWrapper_Short__3 position;
        }

        /// <summary>
        /// This structure stores compressed data. It is typically exported by
        /// demuxers
        /// and then passed as input to decoders, or received as output from
        /// encoders and
        /// then passed to muxers.
        /// 
        /// For video, it should typically contain one compressed frame. For audio
        /// it may
        /// contain several compressed frames.
        /// 
        /// AVPacket is one of the few structs in FFmpeg, whose size is a part of
        /// public
        /// ABI. Thus it may be allocated on stack and no new fields can be added
        /// to it
        /// without libavcodec and libavformat major bump.
        /// 
        /// The semantics of data ownership depends on the buf or destruct
        /// (deprecated)
        /// fields. If either is set, the packet data is dynamically allocated and
        /// is
        /// valid indefinitely until av_free_packet() is called (which in turn
        /// calls
        /// av_buffer_unref()/the destruct callback to free the data). If neither
        /// is set,
        /// the packet data is typically backed by some static buffer somewhere and
        /// is
        /// only valid for a limited time (e.g. until the next read call when
        /// demuxing).
        /// 
        /// The side data is always allocated with av_malloc() and is freed in
        /// av_free_packet().
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVPacket
        {
            /// <summary>
            /// A reference to the reference-counted buffer where the packet data is
            /// stored.
            /// May be NULL, then the packet data is not reference-counted.
            /// </summary>
            public libavutil.AVBufferRef* buf;

            /// <summary>
            /// Presentation timestamp in AVStream->time_base units; the time at which
            /// the decompressed packet will be presented to the user.
            /// Can be AV_NOPTS_VALUE if it is not stored in the file.
            /// pts MUST be larger or equal to dts as presentation cannot happen before
            /// decompression, unless one wants to view hex dumps. Some formats misuse
            /// the terms dts and pts/cts to mean something different. Such timestamps
            /// must be converted to true pts/dts before they are stored in AVPacket.
            /// </summary>
            public long pts;

            /// <summary>
            /// Decompression timestamp in AVStream->time_base units; the time at which
            /// the packet is decompressed.
            /// Can be AV_NOPTS_VALUE if it is not stored in the file.
            /// </summary>
            public long dts;

            public byte* data;

            public int size;

            public int stream_index;

            /// <summary>
            /// A combination of AV_PKT_FLAG values
            /// </summary>
            public int flags;

            public libavcodec.AVPacket.AVPacket_anon* side_data;

            public int side_data_elems;

            /// <summary>
            /// Duration of this packet in AVStream->time_base units, 0 if unknown.
            /// Equals next_pts - this_pts in presentation order.
            /// </summary>
            public int duration;

            [System.ObsoleteAttribute()]
            public global::System.IntPtr destruct;

            [System.ObsoleteAttribute()]
            public void* priv;

            /// <summary>
            /// byte position in stream, -1 if unknown
            /// </summary>
            public long pos;

            /// <summary>
            /// Time difference in AVStream->time_base units from the pts of this
            /// packet to the point at which the output from the decoder has converged
            /// independent from the availability of previous frames. That is, the
            /// frames are virtually identical no matter if decoding started from
            /// the very first frame or from this keyframe.
            /// Is AV_NOPTS_VALUE if unknown.
            /// This field is not the display duration of the current packet.
            /// This field has no meaning if the packet does not have AV_PKT_FLAG_KEY
            /// set.
            /// 
            /// The purpose of this field is to allow seeking in streams that have no
            /// keyframes in the conventional sense. It corresponds to the
            /// recovery point SEI in H.264 and match_time_delta in NUT. It is also
            /// essential for some types of subtitle streams to ensure that all
            /// subtitles are correctly displayed after seeking.
            /// </summary>
            public long convergence_duration;

            /// <summary>
            /// Additional packet data that can be provided by the container.
            /// Packet can contain several types of side information.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public unsafe partial struct AVPacket_anon
            {
                public byte* data;

                public int size;

                public libavcodec.AVPacketSideDataType type;
            }
        }

        /// <summary>
        /// @}
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVCodecInternal
        {
        }

        /// <summary>
        /// main external API structure.
        /// New fields can be added to the end with minor version bumps.
        /// Removal, reordering and changes to existing fields require a major
        /// version bump.
        /// Please use AVOptions (av_opt* / av_set/get*()) to access these fields
        /// from user
        /// applications.
        /// sizeof(AVCodecContext) must not be used outside libav*.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVCodecContext
        {
            /// <summary>
            /// information on struct for av_log
            /// - set by avcodec_alloc_context3
            /// </summary>
            public libavutil.AVClass* av_class;

            public int log_level_offset;

            public libavutil.AVMediaType codec_type;

            public libavcodec.AVCodec* codec;

            public fixed sbyte codec_name[32];

            public libavcodec.AVCodecID codec_id;

            /// <summary>
            /// fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) +
            /// 'A').
            /// This is used to work around some encoder bugs.
            /// A demuxer should set this to what is stored in the field used to
            /// identify the codec.
            /// If there are multiple such fields in a container then the demuxer
            /// should choose the one
            /// which maximizes the information about the used codec.
            /// If the codec tag field in a container is larger than 32 bits then the
            /// demuxer should
            /// remap the longer ID to 32 bits with a table or other structure.
            /// Alternatively a new
            /// extra_codec_tag + size could be added but for this a clear advantage
            /// must be demonstrated
            /// first.
            /// - encoding: Set by user, if not then the default based on codec_id will
            /// be used.
            /// - decoding: Set by user, will be converted to uppercase by libavcodec
            /// during init.
            /// </summary>
            public uint codec_tag;

            /// <summary>
            /// fourcc from the AVI stream header (LSB first, so "ABCD" -> ('D'<<24) +
            /// ('C'<<16) + ('B'<<8) + 'A').
            /// This is used to work around some encoder bugs.
            /// - encoding: unused
            /// - decoding: Set by user, will be converted to uppercase by libavcodec
            /// during init.
            /// </summary>
            public uint stream_codec_tag;

            public void* priv_data;

            /// <summary>
            /// Private context used for internal data.
            /// 
            /// Unlike priv_data, this is not codec-specific. It is used in general
            /// libavcodec functions.
            /// </summary>
            public libavcodec.AVCodecInternal* @internal;

            /// <summary>
            /// Private data of the user, can be used to carry app specific stuff.
            /// - encoding: Set by user.
            /// - decoding: Set by user.
            /// </summary>
            public void* opaque;

            /// <summary>
            /// the average bitrate
            /// - encoding: Set by user; unused for constant quantizer encoding.
            /// - decoding: Set by libavcodec. 0 or some bitrate if this info is
            /// available in the stream.
            /// </summary>
            public int bit_rate;

            /// <summary>
            /// number of bits the bitstream is allowed to diverge from the reference.
            /// the reference can be CBR (for CBR pass1) or VBR (for pass2)
            /// - encoding: Set by user; unused for constant quantizer encoding.
            /// - decoding: unused
            /// </summary>
            public int bit_rate_tolerance;

            /// <summary>
            /// Global quality for codecs which cannot change it per frame.
            /// This should be proportional to MPEG-1/2/4 qscale.
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int global_quality;

            /// <summary>
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int compression_level;

            /// <summary>
            /// CODEC_FLAG_*.
            /// - encoding: Set by user.
            /// - decoding: Set by user.
            /// </summary>
            public int flags;

            /// <summary>
            /// CODEC_FLAG2_
            /// - encoding: Set by user.
            /// - decoding: Set by user.
            /// </summary>
            public int flags2;

            /// <summary>
            /// some codecs need / can use extradata like Huffman tables.
            /// mjpeg: Huffman tables
            /// rv10: additional flags
            /// mpeg4: global headers (they can be in the bitstream or here)
            /// The allocated memory should be FF_INPUT_BUFFER_PADDING_SIZE bytes
            /// larger
            /// than extradata_size to avoid problems if it is read with the bitstream
            /// reader.
            /// The bytewise contents of extradata must not depend on the architecture
            /// or CPU endianness.
            /// - encoding: Set/allocated/freed by libavcodec.
            /// - decoding: Set/allocated/freed by user.
            /// </summary>
            public byte* extradata;

            public int extradata_size;

            /// <summary>
            /// This is the fundamental unit of time (in seconds) in terms
            /// of which frame timestamps are represented. For fixed-fps content,
            /// timebase should be 1/framerate and timestamp increments should be
            /// identically 1.
            /// - encoding: MUST be set by user.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public libavutil.AVRational time_base;

            /// <summary>
            /// For some codecs, the time base is closer to the field rate than the
            /// frame rate.
            /// Most notably, H.264 and MPEG-2 specify time_base as half of frame
            /// duration
            /// if no telecine is used ...
            /// 
            /// Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it
            /// to 2.
            /// </summary>
            public int ticks_per_frame;

            /// <summary>
            /// Codec delay.
            /// 
            /// Encoding: Number of frames delay there will be from the encoder input
            /// to
            /// the decoder output. (we assume the decoder matches the spec)
            /// Decoding: Number of frames delay in addition to what a standard decoder
            /// as specified in the spec would produce.
            /// 
            /// Video:
            /// Number of frames the decoded output will be delayed relative to the
            /// encoded input.
            /// 
            /// Audio:
            /// For encoding, this is the number of "priming" samples added to the
            /// beginning of the stream. The decoded output will be delayed by this
            /// many samples relative to the input to the encoder. Note that this
            /// field is purely informational and does not directly affect the pts
            /// output by the encoder, which should always be based on the actual
            /// presentation time, including any delay.
            /// For decoding, this is the number of samples the decoder needs to
            /// output before the decoder's output is valid. When seeking, you should
            /// start decoding this many samples prior to your desired seek point.
            /// 
            /// - encoding: Set by libavcodec.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public int delay;

            /// <summary>
            /// picture width / height.
            /// - encoding: MUST be set by user.
            /// - decoding: May be set by the user before opening the decoder if known
            /// e.g.
            /// from the container. Some decoders will require the dimensions
            /// to be set by the caller. During decoding, the decoder may
            /// overwrite those values as required.
            /// </summary>
            public int width;

            /// <summary>
            /// picture width / height.
            /// - encoding: MUST be set by user.
            /// - decoding: May be set by the user before opening the decoder if known
            /// e.g.
            /// from the container. Some decoders will require the dimensions
            /// to be set by the caller. During decoding, the decoder may
            /// overwrite those values as required.
            /// </summary>
            public int height;

            /// <summary>
            /// Bitstream width / height, may be different from width/height e.g. when
            /// the decoded frame is cropped before being output or lowres is enabled.
            /// - encoding: unused
            /// - decoding: May be set by the user before opening the decoder if known
            /// e.g. from the container. During decoding, the decoder may
            /// overwrite those values as required.
            /// </summary>
            public int coded_width;

            /// <summary>
            /// Bitstream width / height, may be different from width/height e.g. when
            /// the decoded frame is cropped before being output or lowres is enabled.
            /// - encoding: unused
            /// - decoding: May be set by the user before opening the decoder if known
            /// e.g. from the container. During decoding, the decoder may
            /// overwrite those values as required.
            /// </summary>
            public int coded_height;

            /// <summary>
            /// the number of pictures in a group of pictures, or 0 for intra_only
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int gop_size;

            /// <summary>
            /// Pixel format, see AV_PIX_FMT_xxx.
            /// May be set by the demuxer if known from headers.
            /// May be overridden by the decoder if it knows better.
            /// - encoding: Set by user.
            /// - decoding: Set by user if known, overridden by libavcodec if known
            /// </summary>
            public libavutil.AVPixelFormat pix_fmt;

            /// <summary>
            /// Motion estimation algorithm used for video coding.
            /// 1 (zero), 2 (full), 3 (log), 4 (phods), 5 (epzs), 6 (x1), 7 (hex),
            /// 8 (umh), 9 (iter), 10 (tesa) [7, 8, 10 are x264 specific, 9 is snow
            /// specific]
            /// - encoding: MUST be set by user.
            /// - decoding: unused
            /// </summary>
            public int me_method;

            /// <summary>
            /// If non NULL, 'draw_horiz_band' is called by the libavcodec
            /// decoder to draw a horizontal band. It improves cache usage. Not
            /// all codecs can do that. You must check the codec capabilities
            /// beforehand.
            /// When multithreading is used, it may be called from multiple threads
            /// at the same time; threads might draw different parts of the same
            /// AVFrame,
            /// or multiple AVFrames, and there is no guarantee that slices will be
            /// drawn
            /// in order.
            /// The function is also used by hardware acceleration APIs.
            /// It is called at least once during frame decoding to pass
            /// the data needed for hardware render.
            /// In that mode instead of pixel data, AVFrame points to
            /// a structure specific to the acceleration API. The application
            /// reads the structure and can change some fields to indicate progress
            /// or mark state.
            /// - encoding: unused
            /// - decoding: Set by user.
            /// </summary>
            /// <param name="height">
            /// the height of the slice
            /// </param>
            /// <param name="y">
            /// the y position of the slice
            /// </param>
            /// <param name="type">
            /// 1->top field, 2->bottom field, 3->frame
            /// </param>
            /// <param name="offset">
            /// offset into the AVFrame.data from which the slice should be read
            /// </param>
            public global::System.IntPtr draw_horiz_band;

            /// <summary>
            /// callback to negotiate the pixelFormat
            /// </summary>
            /// <param name="fmt">
            /// is the list of formats which are supported by the codec,
            /// it is terminated by -1 as 0 is a valid format, the formats are ordered
            /// by quality.
            /// The first is always the native one.
            /// </param>
            /// <returns>
            /// the chosen format
            /// - encoding: unused
            /// - decoding: Set by user, if not set the native format will be chosen.
            /// </returns>
            public global::System.IntPtr get_format;

            /// <summary>
            /// maximum number of B-frames between non-B-frames
            /// Note: The output will be delayed by max_b_frames+1 relative to the
            /// input.
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int max_b_frames;

            /// <summary>
            /// qscale factor between IP and B-frames
            /// If > 0 then the last P-frame quantizer will be used (q=
            /// lastp_q*factor+offset).
            /// If < 0 then normal ratecontrol will be done (q=
            /// -normal_q*factor+offset).
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float b_quant_factor;

            /// <summary>
            /// obsolete FIXME remove
            /// </summary>
            public int rc_strategy;

            public int b_frame_strategy;

            /// <summary>
            /// qscale offset between IP and B-frames
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float b_quant_offset;

            /// <summary>
            /// Size of the frame reordering buffer in the decoder.
            /// For MPEG-2 it is 1 IPB or 0 low delay IP.
            /// - encoding: Set by libavcodec.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public int has_b_frames;

            /// <summary>
            /// 0-> h263 quant 1-> mpeg quant
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int mpeg_quant;

            /// <summary>
            /// qscale factor between P and I-frames
            /// If > 0 then the last p frame quantizer will be used (q=
            /// lastp_q*factor+offset).
            /// If < 0 then normal ratecontrol will be done (q=
            /// -normal_q*factor+offset).
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float i_quant_factor;

            /// <summary>
            /// qscale offset between P and I-frames
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float i_quant_offset;

            /// <summary>
            /// luminance masking (0-> disabled)
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float lumi_masking;

            /// <summary>
            /// temporary complexity masking (0-> disabled)
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float temporal_cplx_masking;

            /// <summary>
            /// spatial complexity masking (0-> disabled)
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float spatial_cplx_masking;

            /// <summary>
            /// p block masking (0-> disabled)
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float p_masking;

            /// <summary>
            /// darkness masking (0-> disabled)
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float dark_masking;

            /// <summary>
            /// slice count
            /// - encoding: Set by libavcodec.
            /// - decoding: Set by user (or 0).
            /// </summary>
            public int slice_count;

            /// <summary>
            /// prediction method (needed for huffyuv)
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int prediction_method;

            /// <summary>
            /// slice offsets in the frame in bytes
            /// - encoding: Set/allocated by libavcodec.
            /// - decoding: Set/allocated by user (or NULL).
            /// </summary>
            public int* slice_offset;

            /// <summary>
            /// sample aspect ratio (0 if unknown)
            /// That is the width of a pixel divided by the height of the pixel.
            /// Numerator and denominator must be relatively prime and smaller than 256
            /// for some video standards.
            /// - encoding: Set by user.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public libavutil.AVRational sample_aspect_ratio;

            /// <summary>
            /// motion estimation comparison function
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int me_cmp;

            /// <summary>
            /// subpixel motion estimation comparison function
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int me_sub_cmp;

            /// <summary>
            /// macroblock comparison function (not supported yet)
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int mb_cmp;

            /// <summary>
            /// interlaced DCT comparison function
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int ildct_cmp;

            /// <summary>
            /// ME diamond size & shape
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int dia_size;

            /// <summary>
            /// amount of previous MV predictors (2a+1 x 2a+1 square)
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int last_predictor_count;

            /// <summary>
            /// prepass for motion estimation
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int pre_me;

            /// <summary>
            /// motion estimation prepass comparison function
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int me_pre_cmp;

            /// <summary>
            /// ME prepass diamond size & shape
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int pre_dia_size;

            /// <summary>
            /// subpel ME quality
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int me_subpel_quality;

            /// <summary>
            /// DTG active format information (additional aspect ratio
            /// information only used in DVB MPEG-2 transport streams)
            /// 0 if not set.
            /// 
            /// - encoding: unused
            /// - decoding: Set by decoder.
            /// </summary>
            public int dtg_active_format;

            /// <summary>
            /// maximum motion estimation search range in subpel units
            /// If 0 then no limit.
            /// 
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int me_range;

            /// <summary>
            /// intra quantizer bias
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int intra_quant_bias;

            /// <summary>
            /// inter quantizer bias
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int inter_quant_bias;

            /// <summary>
            /// slice flags
            /// - encoding: unused
            /// - decoding: Set by user.
            /// </summary>
            public int slice_flags;

            /// <summary>
            /// XVideo Motion Acceleration
            /// - encoding: forbidden
            /// - decoding: set by decoder
            /// @deprecated XvMC doesn't need it anymore.
            /// </summary>
            [System.ObsoleteAttribute()]
            public int xvmc_acceleration;

            /// <summary>
            /// macroblock decision mode
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int mb_decision;

            /// <summary>
            /// custom intra quantization matrix
            /// - encoding: Set by user, can be NULL.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public ushort* intra_matrix;

            /// <summary>
            /// custom inter quantization matrix
            /// - encoding: Set by user, can be NULL.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public ushort* inter_matrix;

            /// <summary>
            /// scene change detection threshold
            /// 0 is default, larger means fewer detected scene changes.
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int scenechange_threshold;

            /// <summary>
            /// noise reduction strength
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int noise_reduction;

            /// <summary>
            /// Motion estimation threshold below which no motion estimation is
            /// performed, but instead the user specified motion vectors are used.
            /// 
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int me_threshold;

            /// <summary>
            /// Macroblock threshold below which the user specified macroblock types
            /// will be used.
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int mb_threshold;

            /// <summary>
            /// precision of the intra DC coefficient - 8
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int intra_dc_precision;

            /// <summary>
            /// Number of macroblock rows at the top which are skipped.
            /// - encoding: unused
            /// - decoding: Set by user.
            /// </summary>
            public int skip_top;

            /// <summary>
            /// Number of macroblock rows at the bottom which are skipped.
            /// - encoding: unused
            /// - decoding: Set by user.
            /// </summary>
            public int skip_bottom;

            /// <summary>
            /// Border processing masking, raises the quantizer for mbs on the borders
            /// of the picture.
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float border_masking;

            /// <summary>
            /// minimum MB lagrange multipler
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int mb_lmin;

            /// <summary>
            /// maximum MB lagrange multipler
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int mb_lmax;

            /// <summary>
            /// 
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int me_penalty_compensation;

            /// <summary>
            /// 
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int bidir_refine;

            /// <summary>
            /// 
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int brd_scale;

            /// <summary>
            /// minimum GOP size
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int keyint_min;

            /// <summary>
            /// number of reference frames
            /// - encoding: Set by user.
            /// - decoding: Set by lavc.
            /// </summary>
            public int refs;

            /// <summary>
            /// chroma qp offset from luma
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int chromaoffset;

            /// <summary>
            /// Multiplied by qscale for each frame and added to scene_change_score.
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int scenechange_factor;

            /// <summary>
            /// 
            /// Note: Value depends upon the compare function used for fullpel ME.
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int mv0_threshold;

            /// <summary>
            /// Adjust sensitivity of b_frame_strategy 1.
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int b_sensitivity;

            /// <summary>
            /// Chromaticity coordinates of the source primaries.
            /// - encoding: Set by user
            /// - decoding: Set by libavcodec
            /// </summary>
            public libavcodec.AVColorPrimaries color_primaries;

            /// <summary>
            /// Color Transfer Characteristic.
            /// - encoding: Set by user
            /// - decoding: Set by libavcodec
            /// </summary>
            public libavcodec.AVColorTransferCharacteristic color_trc;

            /// <summary>
            /// YUV colorspace type.
            /// - encoding: Set by user
            /// - decoding: Set by libavcodec
            /// </summary>
            public libavutil.AVColorSpace colorspace;

            /// <summary>
            /// MPEG vs JPEG YUV range.
            /// - encoding: Set by user
            /// - decoding: Set by libavcodec
            /// </summary>
            public libavutil.AVColorRange color_range;

            /// <summary>
            /// This defines the location of chroma samples.
            /// - encoding: Set by user
            /// - decoding: Set by libavcodec
            /// </summary>
            public libavcodec.AVChromaLocation chroma_sample_location;

            /// <summary>
            /// Number of slices.
            /// Indicates number of picture subdivisions. Used for parallelized
            /// decoding.
            /// - encoding: Set by user
            /// - decoding: unused
            /// </summary>
            public int slices;

            /// <summary>
            /// Field order
            /// - encoding: set by libavcodec
            /// - decoding: Set by user.
            /// </summary>
            public libavcodec.AVFieldOrder field_order;

            /// <summary>
            /// samples per second
            /// </summary>
            public int sample_rate;

            /// <summary>
            /// number of audio channels
            /// </summary>
            public int channels;

            /// <summary>
            /// sample format
            /// </summary>
            public libavutil.AVSampleFormat sample_fmt;

            /// <summary>
            /// Number of samples per channel in an audio frame.
            /// 
            /// - encoding: set by libavcodec in avcodec_open2(). Each submitted frame
            /// except the last must contain exactly frame_size samples per channel.
            /// May be 0 when the codec has CODEC_CAP_VARIABLE_FRAME_SIZE set, then the
            /// frame size is not restricted.
            /// - decoding: may be set by some decoders to indicate constant frame size
            /// </summary>
            public int frame_size;

            /// <summary>
            /// Frame counter, set by libavcodec.
            /// 
            /// - decoding: total number of frames returned from the decoder so far.
            /// - encoding: total number of frames passed to the encoder so far.
            /// </summary>
            /// <remark>
            /// the counter is not incremented if encoding/decoding resulted in
            /// an error.
            /// </remark>
            public int frame_number;

            /// <summary>
            /// number of bytes per packet if constant and known or 0
            /// Used by some WAV based audio codecs.
            /// </summary>
            public int block_align;

            /// <summary>
            /// Audio cutoff bandwidth (0 means "automatic")
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int cutoff;

            /// <summary>
            /// Decoder should decode to this many channels if it can (0 for default)
            /// - encoding: unused
            /// - decoding: Set by user.
            /// @deprecated Deprecated in favor of request_channel_layout.
            /// </summary>
            [System.ObsoleteAttribute()]
            public int request_channels;

            /// <summary>
            /// Audio channel layout.
            /// - encoding: set by user.
            /// - decoding: set by user, may be overwritten by libavcodec.
            /// </summary>
            public ulong channel_layout;

            /// <summary>
            /// Request decoder to use this channel layout if it can (0 for default)
            /// - encoding: unused
            /// - decoding: Set by user.
            /// </summary>
            public ulong request_channel_layout;

            /// <summary>
            /// Type of service that the audio stream conveys.
            /// - encoding: Set by user.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public libavcodec.AVAudioServiceType audio_service_type;

            /// <summary>
            /// desired sample format
            /// - encoding: Not used.
            /// - decoding: Set by user.
            /// Decoder will decode to this format if it can.
            /// </summary>
            public libavutil.AVSampleFormat request_sample_fmt;

            /// <summary>
            /// Called at the beginning of each frame to get a buffer for it.
            /// 
            /// The function will set AVFrame.data[], AVFrame.linesize[].
            /// AVFrame.extended_data[] must also be set, but it should be the same as
            /// AVFrame.data[] except for planar audio with more channels than can fit
            /// in AVFrame.data[]. In that case, AVFrame.data[] shall still contain as
            /// many data pointers as it can hold.
            /// 
            /// if CODEC_CAP_DR1 is not set then get_buffer() must call
            /// avcodec_default_get_buffer() instead of providing buffers allocated by
            /// some other means.
            /// 
            /// AVFrame.data[] should be 32- or 16-byte-aligned unless the CPU doesn't
            /// need it. avcodec_default_get_buffer() aligns the output buffer
            /// properly,
            /// but if get_buffer() is overridden then alignment considerations should
            /// be taken into account.
            /// 
            /// @see avcodec_default_get_buffer()
            /// 
            /// Video:
            /// 
            /// If pic.reference is set then the frame will be read later by
            /// libavcodec.
            /// avcodec_align_dimensions2() should be used to find the required width
            /// and
            /// height, as they normally need to be rounded up to the next multiple of
            /// 16.
            /// 
            /// If frame multithreading is used and thread_safe_callbacks is set,
            /// it may be called from a different thread, but not from more than one at
            /// once. Does not need to be reentrant.
            /// 
            /// @see release_buffer(), reget_buffer()
            /// @see avcodec_align_dimensions2()
            /// 
            /// Audio:
            /// 
            /// Decoders request a buffer of a particular size by setting
            /// AVFrame.nb_samples prior to calling get_buffer(). The decoder may,
            /// however, utilize only part of the buffer by setting AVFrame.nb_samples
            /// to a smaller value in the output frame.
            /// 
            /// Decoders cannot use the buffer after returning from
            /// avcodec_decode_audio4(), so they will not call release_buffer(), as it
            /// is assumed to be released immediately upon return. In some rare cases,
            /// a decoder may need to call get_buffer() more than once in a single
            /// call to avcodec_decode_audio4(). In that case, when get_buffer() is
            /// called again after it has already been called once, the previously
            /// acquired buffer is assumed to be released at that time and may not be
            /// reused by the decoder.
            /// 
            /// As a convenience, av_samples_get_buffer_size() and
            /// av_samples_fill_arrays() in libavutil may be used by custom
            /// get_buffer()
            /// functions to find the required data size and to fill data pointers and
            /// linesize. In AVFrame.linesize, only linesize[0] may be set for audio
            /// since all planes must be the same size.
            /// 
            /// @see av_samples_get_buffer_size(), av_samples_fill_arrays()
            /// 
            /// - encoding: unused
            /// - decoding: Set by libavcodec, user can override.
            /// 
            /// @deprecated use get_buffer2()
            /// </summary>
            [System.ObsoleteAttribute()]
            public global::System.IntPtr get_buffer;

            /// <summary>
            /// Called to release buffers which were allocated with get_buffer.
            /// A released buffer can be reused in get_buffer().
            /// pic.data[*] must be set to NULL.
            /// May be called from a different thread if frame multithreading is used,
            /// but not by more than one thread at once, so does not need to be
            /// reentrant.
            /// - encoding: unused
            /// - decoding: Set by libavcodec, user can override.
            /// 
            /// @deprecated custom freeing callbacks should be set from get_buffer2()
            /// </summary>
            [System.ObsoleteAttribute()]
            public global::System.IntPtr release_buffer;

            /// <summary>
            /// Called at the beginning of a frame to get cr buffer for it.
            /// Buffer type (size, hints) must be the same. libavcodec won't check it.
            /// libavcodec will pass previous buffer in pic, function should return
            /// same buffer or new buffer with old frame "painted" into it.
            /// If pic.data[0] == NULL must behave like get_buffer().
            /// if CODEC_CAP_DR1 is not set then reget_buffer() must call
            /// avcodec_default_reget_buffer() instead of providing buffers allocated
            /// by
            /// some other means.
            /// - encoding: unused
            /// - decoding: Set by libavcodec, user can override.
            /// </summary>
            [System.ObsoleteAttribute()]
            public global::System.IntPtr reget_buffer;

            /// <summary>
            /// This callback is called at the beginning of each frame to get data
            /// buffer(s) for it. There may be one contiguous buffer for all the data
            /// or
            /// there may be a buffer per each data plane or anything in between. What
            /// this means is, you may set however many entries in buf[] you feel
            /// necessary.
            /// Each buffer must be reference-counted using the AVBuffer API (see
            /// description
            /// of buf[] below).
            /// 
            /// The following fields will be set in the frame before this callback is
            /// called:
            /// - format
            /// - width, height (video only)
            /// - sample_rate, channel_layout, nb_samples (audio only)
            /// Their values may differ from the corresponding values in
            /// AVCodecContext. This callback must use the frame values, not the codec
            /// context values, to calculate the required buffer size.
            /// 
            /// This callback must fill the following fields in the frame:
            /// - data[]
            /// - linesize[]
            /// - extended_data:
            /// if the data is planar audio with more than 8 channels, then this
            /// callback must allocate and fill extended_data to contain all pointers
            /// to all data planes. data[] must hold as many pointers as it can.
            /// extended_data must be allocated with av_malloc() and will be freed in
            /// av_frame_unref().
            /// otherwise exended_data must point to data
            /// - buf[] must contain one or more pointers to AVBufferRef structures.
            /// Each of
            /// the frame's data and extended_data pointers must be contained in these.
            /// That
            /// is, one AVBufferRef for each allocated chunk of memory, not necessarily
            /// one
            /// AVBufferRef per data[] entry. See: av_buffer_create(),
            /// av_buffer_alloc(),
            /// and av_buffer_ref().
            /// - extended_buf and nb_extended_buf must be allocated with av_malloc()
            /// by
            /// this callback and filled with the extra buffers if there are more
            /// buffers than buf[] can hold. extended_buf will be freed in
            /// av_frame_unref().
            /// 
            /// If CODEC_CAP_DR1 is not set then get_buffer2() must call
            /// avcodec_default_get_buffer2() instead of providing buffers allocated by
            /// some other means.
            /// 
            /// Each data plane must be aligned to the maximum required by the target
            /// CPU.
            /// 
            /// @see avcodec_default_get_buffer2()
            /// 
            /// Video:
            /// 
            /// If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused
            /// (read and/or written to if it is writable) later by libavcodec.
            /// 
            /// avcodec_align_dimensions2() should be used to find the required width
            /// and
            /// height, as they normally need to be rounded up to the next multiple of
            /// 16.
            /// 
            /// Some decoders do not support linesizes changing between frames.
            /// 
            /// If frame multithreading is used and thread_safe_callbacks is set,
            /// this callback may be called from a different thread, but not from more
            /// than one at once. Does not need to be reentrant.
            /// 
            /// @see avcodec_align_dimensions2()
            /// 
            /// Audio:
            /// 
            /// Decoders request a buffer of a particular size by setting
            /// AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
            /// however, utilize only part of the buffer by setting AVFrame.nb_samples
            /// to a smaller value in the output frame.
            /// 
            /// As a convenience, av_samples_get_buffer_size() and
            /// av_samples_fill_arrays() in libavutil may be used by custom
            /// get_buffer2()
            /// functions to find the required data size and to fill data pointers and
            /// linesize. In AVFrame.linesize, only linesize[0] may be set for audio
            /// since all planes must be the same size.
            /// 
            /// @see av_samples_get_buffer_size(), av_samples_fill_arrays()
            /// 
            /// - encoding: unused
            /// - decoding: Set by libavcodec, user can override.
            /// </summary>
            public global::System.IntPtr get_buffer2;

            /// <summary>
            /// If non-zero, the decoded audio and video frames returned from
            /// avcodec_decode_video2() and avcodec_decode_audio4() are
            /// reference-counted
            /// and are valid indefinitely. The caller must free them with
            /// av_frame_unref() when they are not needed anymore.
            /// Otherwise, the decoded frames must not be freed by the caller and are
            /// only valid until the next decode call.
            /// 
            /// - encoding: unused
            /// - decoding: set by the caller before avcodec_open2().
            /// </summary>
            public int refcounted_frames;

            /// <summary>
            /// amount of qscale change between easy & hard scenes (0.0-1.0)
            /// </summary>
            public float qcompress;

            /// <summary>
            /// amount of qscale smoothing over time (0.0-1.0)
            /// </summary>
            public float qblur;

            /// <summary>
            /// minimum quantizer
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int qmin;

            /// <summary>
            /// maximum quantizer
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int qmax;

            /// <summary>
            /// maximum quantizer difference between frames
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int max_qdiff;

            /// <summary>
            /// ratecontrol qmin qmax limiting method
            /// 0-> clipping, 1-> use a nice continuous function to limit qscale wthin
            /// qmin/qmax.
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float rc_qsquish;

            public float rc_qmod_amp;

            public int rc_qmod_freq;

            /// <summary>
            /// decoder bitstream buffer size
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int rc_buffer_size;

            /// <summary>
            /// ratecontrol override, see RcOverride
            /// - encoding: Allocated/set/freed by user.
            /// - decoding: unused
            /// </summary>
            public int rc_override_count;

            public libavcodec.RcOverride* rc_override;

            /// <summary>
            /// rate control equation
            /// - encoding: Set by user
            /// - decoding: unused
            /// </summary>
            public sbyte* rc_eq;

            /// <summary>
            /// maximum bitrate
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int rc_max_rate;

            /// <summary>
            /// minimum bitrate
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int rc_min_rate;

            public float rc_buffer_aggressivity;

            /// <summary>
            /// initial complexity for pass1 ratecontrol
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public float rc_initial_cplx;

            /// <summary>
            /// Ratecontrol attempt to use, at maximum, <value> of what can be used
            /// without an underflow.
            /// - encoding: Set by user.
            /// - decoding: unused.
            /// </summary>
            public float rc_max_available_vbv_use;

            /// <summary>
            /// Ratecontrol attempt to use, at least, <value> times the amount needed
            /// to prevent a vbv overflow.
            /// - encoding: Set by user.
            /// - decoding: unused.
            /// </summary>
            public float rc_min_vbv_overflow_use;

            /// <summary>
            /// Number of bits which should be loaded into the rc buffer before
            /// decoding starts.
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int rc_initial_buffer_occupancy;

            /// <summary>
            /// coder type
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int coder_type;

            /// <summary>
            /// context model
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int context_model;

            /// <summary>
            /// minimum Lagrange multipler
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int lmin;

            /// <summary>
            /// maximum Lagrange multipler
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int lmax;

            /// <summary>
            /// frame skip threshold
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int frame_skip_threshold;

            /// <summary>
            /// frame skip factor
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int frame_skip_factor;

            /// <summary>
            /// frame skip exponent
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int frame_skip_exp;

            /// <summary>
            /// frame skip comparison function
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int frame_skip_cmp;

            /// <summary>
            /// trellis RD quantization
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int trellis;

            /// <summary>
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int min_prediction_order;

            /// <summary>
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int max_prediction_order;

            /// <summary>
            /// GOP timecode frame start number
            /// - encoding: Set by user, in non drop frame format
            /// - decoding: Set by libavcodec (timecode in the 25 bits format, -1 if
            /// unset)
            /// </summary>
            public long timecode_frame_start;

            public global::System.IntPtr rtp_callback;

            public int rtp_payload_size;

            public int mv_bits;

            public int header_bits;

            public int i_tex_bits;

            public int p_tex_bits;

            public int i_count;

            public int p_count;

            public int skip_count;

            public int misc_bits;

            /// <summary>
            /// number of bits used for the previously encoded frame
            /// - encoding: Set by libavcodec.
            /// - decoding: unused
            /// </summary>
            public int frame_bits;

            /// <summary>
            /// pass1 encoding statistics output buffer
            /// - encoding: Set by libavcodec.
            /// - decoding: unused
            /// </summary>
            public sbyte* stats_out;

            /// <summary>
            /// pass2 encoding statistics input buffer
            /// Concatenated stuff from stats_out of pass1 should be placed here.
            /// - encoding: Allocated/set/freed by user.
            /// - decoding: unused
            /// </summary>
            public sbyte* stats_in;

            /// <summary>
            /// Work around bugs in encoders which sometimes cannot be detected
            /// automatically.
            /// - encoding: Set by user
            /// - decoding: Set by user
            /// </summary>
            public int workaround_bugs;

            /// <summary>
            /// strictly follow the standard (MPEG4, ...).
            /// - encoding: Set by user.
            /// - decoding: Set by user.
            /// Setting this to STRICT or higher means the encoder and decoder will
            /// generally do stupid things, whereas setting it to unofficial or lower
            /// will mean the encoder might produce output that is not supported by all
            /// spec-compliant decoders. Decoders don't differentiate between normal,
            /// unofficial and experimental (that is, they always try to decode things
            /// when they can) unless they are explicitly asked to behave stupidly
            /// (=strictly conform to the specs)
            /// </summary>
            public int strict_std_compliance;

            /// <summary>
            /// error concealment flags
            /// - encoding: unused
            /// - decoding: Set by user.
            /// </summary>
            public int error_concealment;

            /// <summary>
            /// debug
            /// - encoding: Set by user.
            /// - decoding: Set by user.
            /// </summary>
            public int debug;

            /// <summary>
            /// debug
            /// Code outside libavcodec should access this field using AVOptions
            /// - encoding: Set by user.
            /// - decoding: Set by user.
            /// </summary>
            public int debug_mv;

            /// <summary>
            /// Error recognition; may misdetect some more or less valid parts as
            /// errors.
            /// - encoding: unused
            /// - decoding: Set by user.
            /// </summary>
            public int err_recognition;

            /// <summary>
            /// opaque 64bit number (generally a PTS) that will be reordered and
            /// output in AVFrame.reordered_opaque
            /// @deprecated in favor of pkt_pts
            /// - encoding: unused
            /// - decoding: Set by user.
            /// </summary>
            public long reordered_opaque;

            /// <summary>
            /// Hardware accelerator in use
            /// - encoding: unused.
            /// - decoding: Set by libavcodec
            /// </summary>
            public libavcodec.AVHWAccel* hwaccel;

            /// <summary>
            /// Hardware accelerator context.
            /// For some hardware accelerators, a global context needs to be
            /// provided by the user. In that case, this holds display-dependent
            /// data FFmpeg cannot instantiate itself. Please refer to the
            /// FFmpeg HW accelerator documentation to know how to fill this
            /// is. e.g. for VA API, this is a struct vaapi_context.
            /// - encoding: unused
            /// - decoding: Set by user
            /// </summary>
            public void* hwaccel_context;

            /// <summary>
            /// error
            /// - encoding: Set by libavcodec if flags&CODEC_FLAG_PSNR.
            /// - decoding: unused
            /// </summary>
            public fixed ulong error[8];

            /// <summary>
            /// DCT algorithm, see FF_DCT_* below
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int dct_algo;

            /// <summary>
            /// IDCT algorithm, see FF_IDCT_* below.
            /// - encoding: Set by user.
            /// - decoding: Set by user.
            /// </summary>
            public int idct_algo;

            /// <summary>
            /// bits per sample/pixel from the demuxer (needed for huffyuv).
            /// - encoding: Set by libavcodec.
            /// - decoding: Set by user.
            /// </summary>
            public int bits_per_coded_sample;

            /// <summary>
            /// Bits per sample/pixel of internal libavcodec pixel/sample format.
            /// - encoding: set by user.
            /// - decoding: set by libavcodec.
            /// </summary>
            public int bits_per_raw_sample;

            /// <summary>
            /// low resolution decoding, 1-> 1/2 size, 2->1/4 size
            /// - encoding: unused
            /// - decoding: Set by user.
            /// Code outside libavcodec should access this field using:
            /// av_codec_{get,set}_lowres(avctx)
            /// </summary>
            public int lowres;

            /// <summary>
            /// the picture in the bitstream
            /// - encoding: Set by libavcodec.
            /// - decoding: unused
            /// </summary>
            public libavutil.AVFrame* coded_frame;

            /// <summary>
            /// thread count
            /// is used to decide how many independent tasks should be passed to
            /// execute()
            /// - encoding: Set by user.
            /// - decoding: Set by user.
            /// </summary>
            public int thread_count;

            /// <summary>
            /// Which multithreading methods to use.
            /// Use of FF_THREAD_FRAME will increase decoding delay by one frame per
            /// thread,
            /// so clients which cannot provide future frames should not use it.
            /// 
            /// - encoding: Set by user, otherwise the default is used.
            /// - decoding: Set by user, otherwise the default is used.
            /// </summary>
            public int thread_type;

            /// <summary>
            /// Which multithreading methods are in use by the codec.
            /// - encoding: Set by libavcodec.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public int active_thread_type;

            /// <summary>
            /// Set by the client if its custom get_buffer() callback can be called
            /// synchronously from another thread, which allows faster multithreaded
            /// decoding.
            /// draw_horiz_band() will be called from other threads regardless of this
            /// setting.
            /// Ignored if the default get_buffer() is used.
            /// - encoding: Set by user.
            /// - decoding: Set by user.
            /// </summary>
            public int thread_safe_callbacks;

            /// <summary>
            /// The codec may call this to execute several independent things.
            /// It will return only after finishing all tasks.
            /// The user may replace this with some multithreaded implementation,
            /// the default implementation will execute the parts serially.
            /// </summary>
            /// <param name="count">
            /// the number of things to execute
            /// - encoding: Set by libavcodec, user can override.
            /// - decoding: Set by libavcodec, user can override.
            /// </param>
            public global::System.IntPtr execute;

            /// <summary>
            /// The codec may call this to execute several independent things.
            /// It will return only after finishing all tasks.
            /// The user may replace this with some multithreaded implementation,
            /// the default implementation will execute the parts serially.
            /// Also see avcodec_thread_init and e.g. the --enable-pthread configure
            /// option.
            /// </summary>
            /// <param name="c">
            /// context passed also to func
            /// </param>
            /// <param name="count">
            /// the number of things to execute
            /// </param>
            /// <param name="arg2">
            /// argument passed unchanged to func
            /// </param>
            /// <param name="ret">
            /// return values of executed functions, must have space for "count"
            /// values. May be NULL.
            /// </param>
            /// <param name="func">
            /// function that will be called count times, with jobnr from 0 to count-1.
            /// threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and
            /// so that no
            /// two instances of func executing at the same time will have the same
            /// threadnr.
            /// </param>
            /// <returns>
            /// always 0 currently, but code should handle a future improvement where
            /// when any call to func
            /// returns < 0 no further calls to func may be done and < 0 is returned.
            /// - encoding: Set by libavcodec, user can override.
            /// - decoding: Set by libavcodec, user can override.
            /// </returns>
            public global::System.IntPtr execute2;

            [System.ObsoleteAttribute()]
            public void* thread_opaque;

            /// <summary>
            /// noise vs. sse weight for the nsse comparsion function
            /// - encoding: Set by user.
            /// - decoding: unused
            /// </summary>
            public int nsse_weight;

            /// <summary>
            /// profile
            /// - encoding: Set by user.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public int profile;

            /// <summary>
            /// level
            /// - encoding: Set by user.
            /// - decoding: Set by libavcodec.
            /// </summary>
            public int level;

            /// <summary>
            /// Skip loop filtering for selected frames.
            /// - encoding: unused
            /// - decoding: Set by user.
            /// </summary>
            public libavcodec.AVDiscard skip_loop_filter;

            /// <summary>
            /// Skip IDCT/dequantization for selected frames.
            /// - encoding: unused
            /// - decoding: Set by user.
            /// </summary>
            public libavcodec.AVDiscard skip_idct;

            /// <summary>
            /// Skip decoding for selected frames.
            /// - encoding: unused
            /// - decoding: Set by user.
            /// </summary>
            public libavcodec.AVDiscard skip_frame;

            /// <summary>
            /// Header containing style information for text subtitles.
            /// For SUBTITLE_ASS subtitle type, it should contain the whole ASS
            /// [Script Info] and [V4+ Styles] section, plus the [Events] line and
            /// the Format line following. It shouldn't include any Dialogue line.
            /// - encoding: Set/allocated/freed by user (before avcodec_open2())
            /// - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
            /// </summary>
            public byte* subtitle_header;

            public int subtitle_header_size;

            [System.ObsoleteAttribute()]
            public int error_rate;

            [System.ObsoleteAttribute()]
            public libavcodec.AVPacket* pkt;

            /// <summary>
            /// VBV delay coded in the last frame (in periods of a 27 MHz clock).
            /// Used for compliant TS muxing.
            /// - encoding: Set by libavcodec.
            /// - decoding: unused.
            /// </summary>
            public ulong vbv_delay;

            /// <summary>
            /// Timebase in which pkt_dts/pts and AVPacket.dts/pts are.
            /// Code outside libavcodec should access this field using:
            /// av_codec_{get,set}_pkt_timebase(avctx)
            /// - encoding unused.
            /// - decoding set by user.
            /// </summary>
            public libavutil.AVRational pkt_timebase;

            /// <summary>
            /// AVCodecDescriptor
            /// Code outside libavcodec should access this field using:
            /// av_codec_{get,set}_codec_descriptor(avctx)
            /// - encoding: unused.
            /// - decoding: set by libavcodec.
            /// </summary>
            public libavcodec.AVCodecDescriptor* codec_descriptor;

            /// <summary>
            /// Current statistics for PTS correction.
            /// - decoding: maintained and used by libavcodec, not intended to be used
            /// by user apps
            /// - encoding: unused
            /// </summary>
            public long pts_correction_num_faulty_pts;

            /// <summary>
            /// Number of incorrect PTS values so far
            /// </summary>
            public long pts_correction_num_faulty_dts;

            /// <summary>
            /// Number of incorrect DTS values so far
            /// </summary>
            public long pts_correction_last_pts;

            /// <summary>
            /// PTS of the last frame
            /// </summary>
            public long pts_correction_last_dts;

            /// <summary>
            /// Character encoding of the input subtitles file.
            /// - decoding: set by user
            /// - encoding: unused
            /// </summary>
            public sbyte* sub_charenc;

            /// <summary>
            /// Subtitles character encoding mode. Formats or codecs might be adjusting
            /// this setting (if they are doing the conversion themselves for
            /// instance).
            /// - decoding: set by libavcodec
            /// - encoding: unused
            /// </summary>
            public int sub_charenc_mode;

            /// <summary>
            /// Skip processing alpha if supported by codec.
            /// Note that if the format uses pre-multiplied alpha (common with VP6,
            /// and recommended due to better video quality/compression)
            /// the image will look as if alpha-blended onto a black background.
            /// However for formats that do not use pre-multiplied alpha
            /// there might be serious artefacts (though e.g. libswscale currently
            /// assumes pre-multiplied alpha anyway).
            /// Code outside libavcodec should access this field using AVOptions
            /// 
            /// - decoding: set by user
            /// - encoding: unused
            /// </summary>
            public int skip_alpha;

            /// <summary>
            /// Number of samples to skip after a discontinuity
            /// - decoding: unused
            /// - encoding: set by libavcodec
            /// </summary>
            public int seek_preroll;

            /// <summary>
            /// custom intra quantization matrix
            /// Code outside libavcodec should access this field using
            /// av_codec_g/set_chroma_intra_matrix()
            /// - encoding: Set by user, can be NULL.
            /// - decoding: unused.
            /// </summary>
            public ushort* chroma_intra_matrix;
        }

        /// <summary>
        /// AVProfile.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVProfile
        {
            public int profile;

            /// <summary>
            /// short name for the profile
            /// </summary>
            public sbyte* name;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVCodecDefault
        {
        }

        /// <summary>
        /// AVCodec.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVCodec
        {
            /// <summary>
            /// Name of the codec implementation.
            /// The name is globally unique among encoders and among decoders (but an
            /// encoder and a decoder can share the same name).
            /// This is the primary way to find a codec from the user perspective.
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// Descriptive name for the codec, meant to be more human readable than
            /// name.
            /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
            /// </summary>
            public sbyte* long_name;

            public libavutil.AVMediaType type;

            public libavcodec.AVCodecID id;

            /// <summary>
            /// Codec capabilities.
            /// see CODEC_CAP_
            /// </summary>
            public int capabilities;

            /// <summary>
            /// array of supported framerates, or NULL if any, array is terminated by
            /// {0,0}
            /// </summary>
            public libavutil.AVRational* supported_framerates;

            /// <summary>
            /// array of supported pixel formats, or NULL if unknown, array is
            /// terminated by -1
            /// </summary>
            public libavutil.AVPixelFormat* pix_fmts;

            /// <summary>
            /// array of supported audio samplerates, or NULL if unknown, array is
            /// terminated by 0
            /// </summary>
            public int* supported_samplerates;

            /// <summary>
            /// array of supported sample formats, or NULL if unknown, array is
            /// terminated by -1
            /// </summary>
            public libavutil.AVSampleFormat* sample_fmts;

            /// <summary>
            /// array of support channel layouts, or NULL if unknown. array is
            /// terminated by 0
            /// </summary>
            public ulong* channel_layouts;

            /// <summary>
            /// maximum value for lowres supported by the decoder, no direct access,
            /// use av_codec_get_max_lowres()
            /// </summary>
            public byte max_lowres;

            /// <summary>
            /// AVClass for the private context
            /// </summary>
            public libavutil.AVClass* priv_class;

            /// <summary>
            /// array of recognized profiles, or NULL if unknown, array is terminated
            /// by {FF_PROFILE_UNKNOWN}
            /// </summary>
            public libavcodec.AVProfile* profiles;

            /// <summary>
            /// 
            /// No fields below this line are part of the public API. They
            /// may not be used outside of libavcodec and can be changed and
            /// removed at will.
            /// New public fields should be added right above.
            /// </summary>
            public int priv_data_size;

            public libavcodec.AVCodec* next;

            /// <summary>
            /// @name Frame-level threading support functions
            /// @{
            /// 
            /// 
            /// If defined, called on thread contexts when they are created.
            /// If the codec allocates writable tables in init(), re-allocate them
            /// here.
            /// priv_data will be set to a copy of the original.
            /// </summary>
            public global::System.IntPtr init_thread_copy;

            /// <summary>
            /// Copy necessary context variables from a previous thread context to the
            /// current one.
            /// If not defined, the next thread will start automatically; otherwise,
            /// the codec
            /// must call ff_thread_finish_setup().
            /// 
            /// dst and src will (rarely) point to the same context, in which case
            /// memcpy should be skipped.
            /// </summary>
            public global::System.IntPtr update_thread_context;

            /// <summary>
            /// Private codec-specific defaults.
            /// </summary>
            public libavcodec.AVCodecDefault* defaults;

            /// <summary>
            /// Initialize codec static data, called from avcodec_register().
            /// </summary>
            public global::System.IntPtr init_static_data;

            public global::System.IntPtr init;

            public global::System.IntPtr encode_sub;

            /// <summary>
            /// Encode data to an AVPacket.
            /// </summary>
            /// <param name="avctx">
            /// codec context
            /// </param>
            /// <param name="avpkt">
            /// output AVPacket (may contain a user-provided buffer)
            /// </param>
            /// <param name="[in]">
            /// frame          AVFrame containing the raw data to be encoded
            /// </param>
            /// <param name="[out]">
            /// got_packet_ptr encoder sets to 0 or 1 to indicate that a
            /// non-empty packet was returned in avpkt.
            /// </param>
            /// <returns>
            /// 0 on success, negative error code on failure
            /// </returns>
            public global::System.IntPtr encode2;

            public global::System.IntPtr decode;

            public global::System.IntPtr close;

            /// <summary>
            /// Flush buffers.
            /// Will be called when seeking
            /// </summary>
            public global::System.IntPtr flush;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct MpegEncContext
        {
        }

        /// <summary>
        /// AVHWAccel.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVHWAccel
        {
            /// <summary>
            /// Name of the hardware accelerated codec.
            /// The name is globally unique among encoders and among decoders (but an
            /// encoder and a decoder can share the same name).
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// Type of codec implemented by the hardware accelerator.
            /// 
            /// See AVMEDIA_TYPE_xxx
            /// </summary>
            public libavutil.AVMediaType type;

            /// <summary>
            /// Codec implemented by the hardware accelerator.
            /// 
            /// See AV_CODEC_ID_xxx
            /// </summary>
            public libavcodec.AVCodecID id;

            /// <summary>
            /// Supported pixel format.
            /// 
            /// Only hardware accelerated formats are supported here.
            /// </summary>
            public libavutil.AVPixelFormat pix_fmt;

            /// <summary>
            /// Hardware accelerated codec capabilities.
            /// see FF_HWACCEL_CODEC_CAP_
            /// </summary>
            public int capabilities;

            public libavcodec.AVHWAccel* next;

            /// <summary>
            /// Called at the beginning of each frame or field picture.
            /// 
            /// Meaningful frame information (codec specific) is guaranteed to
            /// be parsed at this point. This function is mandatory.
            /// 
            /// Note that buf can be NULL along with buf_size set to 0.
            /// Otherwise, this means the whole frame is available at this point.
            /// </summary>
            /// <param name="avctx">
            /// the codec context
            /// </param>
            /// <param name="buf">
            /// the frame data buffer base
            /// </param>
            /// <param name="buf_size">
            /// the size of the frame in bytes
            /// </param>
            /// <returns>
            /// zero if successful, a negative value otherwise
            /// </returns>
            public global::System.IntPtr start_frame;

            /// <summary>
            /// Callback for each slice.
            /// 
            /// Meaningful slice information (codec specific) is guaranteed to
            /// be parsed at this point. This function is mandatory.
            /// The only exception is XvMC, that works on MB level.
            /// </summary>
            /// <param name="avctx">
            /// the codec context
            /// </param>
            /// <param name="buf">
            /// the slice data buffer base
            /// </param>
            /// <param name="buf_size">
            /// the size of the slice in bytes
            /// </param>
            /// <returns>
            /// zero if successful, a negative value otherwise
            /// </returns>
            public global::System.IntPtr decode_slice;

            /// <summary>
            /// Called at the end of each frame or field picture.
            /// 
            /// The whole picture is parsed at this point and can now be sent
            /// to the hardware accelerator. This function is mandatory.
            /// </summary>
            /// <param name="avctx">
            /// the codec context
            /// </param>
            /// <returns>
            /// zero if successful, a negative value otherwise
            /// </returns>
            public global::System.IntPtr end_frame;

            /// <summary>
            /// Size of HW accelerator private data.
            /// 
            /// Private data is allocated with av_mallocz() before
            /// AVCodecContext.get_buffer() and deallocated after
            /// AVCodecContext.release_buffer().
            /// </summary>
            public int priv_data_size;

            /// <summary>
            /// Called for every Macroblock in a slice.
            /// 
            /// XvMC uses it to replace the ff_MPV_decode_mb().
            /// Instead of decoding to raw picture, MB parameters are
            /// stored in an array provided by the video driver.
            /// </summary>
            /// <param name="s">
            /// the mpeg context
            /// </param>
            public global::System.IntPtr decode_mb;
        }

        /// <summary>
        /// Picture data structure.
        /// 
        /// Up to four components can be stored into it, the last component is
        /// alpha.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVPicture
        {
            /// <summary>
            /// pointers to the image data planes
            /// </summary>
            public libavutil.ArrayWrapper_BytePtr8 data;

            /// <summary>
            /// number of bytes per line
            /// </summary>
            public fixed int linesize[8];
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVSubtitleRect
        {
            /// <summary>
            /// top left corner  of pict, undefined when pict is not set
            /// </summary>
            public int x;

            /// <summary>
            /// top left corner  of pict, undefined when pict is not set
            /// </summary>
            public int y;

            /// <summary>
            /// width            of pict, undefined when pict is not set
            /// </summary>
            public int w;

            /// <summary>
            /// height           of pict, undefined when pict is not set
            /// </summary>
            public int h;

            /// <summary>
            /// number of colors in pict, undefined when pict is not set
            /// </summary>
            public int nb_colors;

            /// <summary>
            /// data+linesize for the bitmap of this subtitle.
            /// can be set for text/ass as well once they where rendered
            /// </summary>
            public libavcodec.AVPicture pict;

            public libavcodec.AVSubtitleType type;

            /// <summary>
            /// 0 terminated plain UTF-8 text
            /// </summary>
            public sbyte* text;

            /// <summary>
            /// 0 terminated ASS/SSA compatible event line.
            /// The presentation of this is unaffected by the other values in this
            /// struct.
            /// </summary>
            public sbyte* ass;

            public int flags;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVSubtitle
        {
            public ushort format;

            public uint start_display_time;

            public uint end_display_time;

            public uint num_rects;

            public libavcodec.AVSubtitleRect** rects;

            /// <summary>
            /// Same as packet pts, in AV_TIME_BASE
            /// </summary>
            public long pts;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVCodecParserContext
        {
            public void* priv_data;

            public libavcodec.AVCodecParser* parser;

            public long frame_offset;

            public long cur_offset;

            public long next_frame_offset;

            public int pict_type;

            /// <summary>
            /// This field is used for proper frame duration computation in lavf.
            /// It signals, how much longer the frame duration of the current frame
            /// is compared to normal frame duration.
            /// 
            /// frame_duration = (1 + repeat_pict) * time_base
            /// 
            /// It is used by codecs like H.264 to display telecined material.
            /// </summary>
            public int repeat_pict;

            public long pts;

            public long dts;

            public long last_pts;

            public long last_dts;

            public int fetch_timestamp;

            public int cur_frame_start_index;

            public fixed long cur_frame_offset[4];

            public fixed long cur_frame_pts[4];

            public fixed long cur_frame_dts[4];

            public int flags;

            /// <summary>
            /// byte offset from starting packet start
            /// </summary>
            public long offset;

            public fixed long cur_frame_end[4];

            /// <summary>
            /// Set by parser to 1 for key frames and 0 for non-key frames.
            /// It is initialized to -1, so if the parser doesn't set this flag,
            /// old-style fallback using AV_PICTURE_TYPE_I picture type as key frames
            /// will be used.
            /// </summary>
            public int key_frame;

            /// <summary>
            /// Time difference in stream time base units from the pts of this
            /// packet to the point at which the output from the decoder has converged
            /// independent from the availability of previous frames. That is, the
            /// frames are virtually identical no matter if decoding started from
            /// the very first frame or from this keyframe.
            /// Is AV_NOPTS_VALUE if unknown.
            /// This field is not the display duration of the current frame.
            /// This field has no meaning if the packet does not have AV_PKT_FLAG_KEY
            /// set.
            /// 
            /// The purpose of this field is to allow seeking in streams that have no
            /// keyframes in the conventional sense. It corresponds to the
            /// recovery point SEI in H.264 and match_time_delta in NUT. It is also
            /// essential for some types of subtitle streams to ensure that all
            /// subtitles are correctly displayed after seeking.
            /// </summary>
            public long convergence_duration;

            /// <summary>
            /// Synchronization point for start of timestamp generation.
            /// 
            /// Set to >0 for sync point, 0 for no sync point and <0 for undefined
            /// (default).
            /// 
            /// For example, this corresponds to presence of H.264 buffering period
            /// SEI message.
            /// </summary>
            public int dts_sync_point;

            /// <summary>
            /// Offset of the current timestamp against last timestamp sync point in
            /// units of AVCodecContext.time_base.
            /// 
            /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
            /// contain a valid timestamp offset.
            /// 
            /// Note that the timestamp of sync point has usually a nonzero
            /// dts_ref_dts_delta, which refers to the previous sync point. Offset of
            /// the next frame after timestamp sync point will be usually 1.
            /// 
            /// For example, this corresponds to H.264 cpb_removal_delay.
            /// </summary>
            public int dts_ref_dts_delta;

            /// <summary>
            /// Presentation delay of current frame in units of
            /// AVCodecContext.time_base.
            /// 
            /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
            /// contain valid non-negative timestamp delta (presentation time of a
            /// frame
            /// must not lie in the past).
            /// 
            /// This delay represents the difference between decoding and presentation
            /// time of the frame.
            /// 
            /// For example, this corresponds to H.264 dpb_output_delay.
            /// </summary>
            public int pts_dts_delta;

            /// <summary>
            /// Position of the packet in file.
            /// 
            /// Analogous to cur_frame_pts/dts
            /// </summary>
            public fixed long cur_frame_pos[4];

            /// <summary>
            /// Byte position of currently parsed frame in stream.
            /// </summary>
            public long pos;

            /// <summary>
            /// Previous frame byte position.
            /// </summary>
            public long last_pos;

            /// <summary>
            /// Duration of the current frame.
            /// For audio, this is in units of 1 / AVCodecContext.sample_rate.
            /// For all other types, this is in units of AVCodecContext.time_base.
            /// </summary>
            public int duration;

            public libavcodec.AVFieldOrder field_order;

            /// <summary>
            /// Indicate whether a picture is coded as a frame, top field or bottom
            /// field.
            /// 
            /// For example, H.264 field_pic_flag equal to 0 corresponds to
            /// AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag
            /// equal to 1 and bottom_field_flag equal to 0 corresponds to
            /// AV_PICTURE_STRUCTURE_TOP_FIELD.
            /// </summary>
            public libavcodec.AVPictureStructure picture_structure;

            /// <summary>
            /// Picture number incremented in presentation or output order.
            /// This field may be reinitialized at the first picture of a new sequence.
            /// 
            /// For example, this corresponds to H.264 PicOrderCnt.
            /// </summary>
            public int output_picture_number;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVCodecParser
        {
            public fixed int codec_ids[5];

            public int priv_data_size;

            public global::System.IntPtr parser_init;

            public global::System.IntPtr parser_parse;

            public global::System.IntPtr parser_close;

            public global::System.IntPtr split;

            public libavcodec.AVCodecParser* next;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct ReSampleContext
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVResampleContext
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVBitStreamFilterContext
        {
            public void* priv_data;

            public libavcodec.AVBitStreamFilter* filter;

            public libavcodec.AVCodecParserContext* parser;

            public libavcodec.AVBitStreamFilterContext* next;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVBitStreamFilter
        {
            public sbyte* name;

            public int priv_data_size;

            public global::System.IntPtr filter;

            public global::System.IntPtr close;

            public libavcodec.AVBitStreamFilter* next;
        }

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_pkt_timebase")]
        public static extern libavutil.AVRational av_codec_get_pkt_timebase(libavcodec.AVCodecContext* avctx);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_set_pkt_timebase")]
        public static extern void av_codec_set_pkt_timebase(libavcodec.AVCodecContext* avctx, libavutil.AVRational val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_codec_descriptor")]
        public static extern libavcodec.AVCodecDescriptor* av_codec_get_codec_descriptor(libavcodec.AVCodecContext* avctx);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_set_codec_descriptor")]
        public static extern void av_codec_set_codec_descriptor(libavcodec.AVCodecContext* avctx, libavcodec.AVCodecDescriptor* desc);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_lowres")]
        public static extern int av_codec_get_lowres(libavcodec.AVCodecContext* avctx);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_set_lowres")]
        public static extern void av_codec_set_lowres(libavcodec.AVCodecContext* avctx, int val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_seek_preroll")]
        public static extern int av_codec_get_seek_preroll(libavcodec.AVCodecContext* avctx);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_set_seek_preroll")]
        public static extern void av_codec_set_seek_preroll(libavcodec.AVCodecContext* avctx, int val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_chroma_intra_matrix")]
        public static extern ushort* av_codec_get_chroma_intra_matrix(libavcodec.AVCodecContext* avctx);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_set_chroma_intra_matrix")]
        public static extern void av_codec_set_chroma_intra_matrix(libavcodec.AVCodecContext* avctx, ushort* val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_max_lowres")]
        public static extern int av_codec_get_max_lowres(libavcodec.AVCodec* codec);

        /// <summary>
        /// If c is NULL, returns the first registered codec,
        /// if c is non-NULL, returns the next registered codec after c,
        /// or NULL if c is the last one.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_next")]
        public static extern libavcodec.AVCodec* av_codec_next(libavcodec.AVCodec* c);

        /// <summary>
        /// Return the LIBAVCODEC_VERSION_INT constant.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_version")]
        public static extern uint avcodec_version();

        /// <summary>
        /// Return the libavcodec build-time configuration.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_configuration")]
        public static extern sbyte* avcodec_configuration();

        /// <summary>
        /// Return the libavcodec license.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_license")]
        public static extern sbyte* avcodec_license();

        /// <summary>
        /// Register the codec codec and initialize libavcodec.
        /// 
        /// @warning either this function or avcodec_register_all() must be called
        /// before any other libavcodec functions.
        /// 
        /// @see avcodec_register_all()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_register")]
        public static extern void avcodec_register(libavcodec.AVCodec* codec);

        /// <summary>
        /// Register all the codecs, parsers and bitstream filters which were
        /// enabled at
        /// configuration time. If you do not call this function you can select
        /// exactly
        /// which formats you want to support, by using the individual registration
        /// functions.
        /// 
        /// @see avcodec_register
        /// @see av_register_codec_parser
        /// @see av_register_bitstream_filter
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_register_all")]
        public static extern void avcodec_register_all();

        /// <summary>
        /// Allocate an AVCodecContext and set its fields to default values.  The
        /// resulting struct can be deallocated by calling avcodec_close() on it
        /// followed
        /// by av_free().
        /// </summary>
        /// <param name="codec">
        /// if non-NULL, allocate private data and initialize defaults
        /// for the given codec. It is illegal to then call avcodec_open2()
        /// with a different codec.
        /// If NULL, then the codec-specific defaults won't be initialized,
        /// which may result in suboptimal default settings (this is
        /// important mainly for encoders, e.g. libx264).
        /// </param>
        /// <returns>
        /// An AVCodecContext filled with default values or NULL on failure.
        /// @see avcodec_get_context_defaults
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_alloc_context3")]
        public static extern libavcodec.AVCodecContext* avcodec_alloc_context3(libavcodec.AVCodec* codec);

        /// <summary>
        /// Set the fields of the given AVCodecContext to default values
        /// corresponding
        /// to the given codec (defaults may be codec-dependent).
        /// 
        /// Do not call this function if a non-NULL codec has been passed
        /// to avcodec_alloc_context3() that allocated this AVCodecContext.
        /// If codec is non-NULL, it is illegal to call avcodec_open2() with a
        /// different codec on this AVCodecContext.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_get_context_defaults3")]
        public static extern int avcodec_get_context_defaults3(libavcodec.AVCodecContext* s, libavcodec.AVCodec* codec);

        /// <summary>
        /// Get the AVClass for AVCodecContext. It can be used in combination with
        /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
        /// 
        /// @see av_opt_find().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_get_class")]
        public static extern libavutil.AVClass* avcodec_get_class();

        /// <summary>
        /// Get the AVClass for AVFrame. It can be used in combination with
        /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
        /// 
        /// @see av_opt_find().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_get_frame_class")]
        public static extern libavutil.AVClass* avcodec_get_frame_class();

        /// <summary>
        /// Get the AVClass for AVSubtitleRect. It can be used in combination with
        /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
        /// 
        /// @see av_opt_find().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_get_subtitle_rect_class")]
        public static extern libavutil.AVClass* avcodec_get_subtitle_rect_class();

        /// <summary>
        /// Copy the settings of the source AVCodecContext into the destination
        /// AVCodecContext. The resulting destination codec context will be
        /// unopened, i.e. you are required to call avcodec_open2() before you
        /// can use this AVCodecContext to decode/encode video/audio data.
        /// </summary>
        /// <param name="dest">
        /// target codec context, should be initialized with
        /// avcodec_alloc_context3(NULL), but otherwise uninitialized
        /// </param>
        /// <param name="src">
        /// source codec context
        /// </param>
        /// <returns>
        /// AVERROR() on error (e.g. memory allocation error), 0 on success
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_copy_context")]
        public static extern int avcodec_copy_context(libavcodec.AVCodecContext* dest, libavcodec.AVCodecContext* src);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_alloc_frame")]
        public static extern libavutil.AVFrame* avcodec_alloc_frame();

        /// <summary>
        /// Set the fields of the given AVFrame to default values.
        /// </summary>
        /// <param name="frame">
        /// The AVFrame of which the fields should be set to default values.
        /// 
        /// @deprecated use av_frame_unref()
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_get_frame_defaults")]
        public static extern void avcodec_get_frame_defaults(libavutil.AVFrame* frame);

        /// <summary>
        /// Free the frame and any dynamically allocated objects in it,
        /// e.g. extended_data.
        /// </summary>
        /// <param name="frame">
        /// frame to be freed. The pointer will be set to NULL.
        /// 
        /// @warning this function does NOT free the data buffers themselves
        /// (it does not know how, since they might have been allocated with
        /// a custom get_buffer()).
        /// 
        /// @deprecated use av_frame_free()
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_free_frame")]
        public static extern void avcodec_free_frame(libavutil.AVFrame** frame);

        /// <summary>
        /// Free the frame and any dynamically allocated objects in it,
        /// e.g. extended_data.
        /// </summary>
        /// <param name="frame">
        /// frame to be freed. The pointer will be set to NULL.
        /// 
        /// @warning this function does NOT free the data buffers themselves
        /// (it does not know how, since they might have been allocated with
        /// a custom get_buffer()).
        /// 
        /// @deprecated use av_frame_free()
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_free_frame")]
        public static extern void avcodec_free_frame(ref libavutil.AVFrame* frame);

        /// <summary>
        /// Initialize the AVCodecContext to use the given AVCodec. Prior to using
        /// this
        /// function the context has to be allocated with avcodec_alloc_context3().
        /// 
        /// The functions avcodec_find_decoder_by_name(),
        /// avcodec_find_encoder_by_name(),
        /// avcodec_find_decoder() and avcodec_find_encoder() provide an easy way
        /// for
        /// retrieving a codec.
        /// 
        /// @warning This function is not thread safe!
        /// 
        /// @code
        /// avcodec_register_all();
        /// av_dict_set(&opts, "b", "2.5M", 0);
        /// codec = avcodec_find_decoder(AV_CODEC_ID_H264);
        /// if (!codec)
        /// exit(1);
        /// 
        /// context = avcodec_alloc_context3(codec);
        /// 
        /// if (avcodec_open2(context, codec, opts) < 0)
        /// exit(1);
        /// @endcode
        /// </summary>
        /// <param name="avctx">
        /// The context to initialize.
        /// </param>
        /// <param name="codec">
        /// The codec to open this context for. If a non-NULL codec has been
        /// previously passed to avcodec_alloc_context3() or
        /// avcodec_get_context_defaults3() for this context, then this
        /// parameter MUST be either NULL or equal to the previously passed
        /// codec.
        /// </param>
        /// <param name="options">
        /// A dictionary filled with AVCodecContext and codec-private options.
        /// On return this object will be filled with options that were not found.
        /// </param>
        /// <returns>
        /// zero on success, a negative value on error
        /// @see avcodec_alloc_context3(), avcodec_find_decoder(),
        /// avcodec_find_encoder(),
        /// av_dict_set(), av_opt_find().
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_open2")]
        public static extern int avcodec_open2(libavcodec.AVCodecContext* avctx, libavcodec.AVCodec* codec, libavutil.AVDictionary** options);

        /// <summary>
        /// Initialize the AVCodecContext to use the given AVCodec. Prior to using
        /// this
        /// function the context has to be allocated with avcodec_alloc_context3().
        /// 
        /// The functions avcodec_find_decoder_by_name(),
        /// avcodec_find_encoder_by_name(),
        /// avcodec_find_decoder() and avcodec_find_encoder() provide an easy way
        /// for
        /// retrieving a codec.
        /// 
        /// @warning This function is not thread safe!
        /// 
        /// @code
        /// avcodec_register_all();
        /// av_dict_set(&opts, "b", "2.5M", 0);
        /// codec = avcodec_find_decoder(AV_CODEC_ID_H264);
        /// if (!codec)
        /// exit(1);
        /// 
        /// context = avcodec_alloc_context3(codec);
        /// 
        /// if (avcodec_open2(context, codec, opts) < 0)
        /// exit(1);
        /// @endcode
        /// </summary>
        /// <param name="avctx">
        /// The context to initialize.
        /// </param>
        /// <param name="codec">
        /// The codec to open this context for. If a non-NULL codec has been
        /// previously passed to avcodec_alloc_context3() or
        /// avcodec_get_context_defaults3() for this context, then this
        /// parameter MUST be either NULL or equal to the previously passed
        /// codec.
        /// </param>
        /// <param name="options">
        /// A dictionary filled with AVCodecContext and codec-private options.
        /// On return this object will be filled with options that were not found.
        /// </param>
        /// <returns>
        /// zero on success, a negative value on error
        /// @see avcodec_alloc_context3(), avcodec_find_decoder(),
        /// avcodec_find_encoder(),
        /// av_dict_set(), av_opt_find().
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_open2")]
        public static extern int avcodec_open2(libavcodec.AVCodecContext* avctx, libavcodec.AVCodec* codec, ref libavutil.AVDictionary* options);

        /// <summary>
        /// Close a given AVCodecContext and free all the data associated with it
        /// (but not the AVCodecContext itself).
        /// 
        /// Calling this function on an AVCodecContext that hasn't been opened will
        /// free
        /// the codec-specific data allocated in avcodec_alloc_context3()
        /// avcodec_get_context_defaults3() with a non-NULL codec. Subsequent calls
        /// will
        /// do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_close")]
        public static extern int avcodec_close(libavcodec.AVCodecContext* avctx);

        /// <summary>
        /// Free all allocated data in the given subtitle struct.
        /// </summary>
        /// <param name="sub">
        /// AVSubtitle to free.
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avsubtitle_free")]
        public static extern void avsubtitle_free(libavcodec.AVSubtitle* sub);

        /// <summary>
        /// Default packet destructor.
        /// @deprecated use the AVBuffer API instead
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_destruct_packet")]
        public static extern void av_destruct_packet(libavcodec.AVPacket* pkt);

        /// <summary>
        /// Initialize optional fields of a packet with default values.
        /// 
        /// Note, this does not touch the data and size members, which have to be
        /// initialized separately.
        /// </summary>
        /// <param name="pkt">
        /// packet
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_init_packet")]
        public static extern void av_init_packet(libavcodec.AVPacket* pkt);

        /// <summary>
        /// Allocate the payload of a packet and initialize its fields with
        /// default values.
        /// </summary>
        /// <param name="pkt">
        /// packet
        /// </param>
        /// <param name="size">
        /// wanted payload size
        /// </param>
        /// <returns>
        /// 0 if OK, AVERROR_xxx otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_new_packet")]
        public static extern int av_new_packet(libavcodec.AVPacket* pkt, int size);

        /// <summary>
        /// Reduce packet size, correctly zeroing padding
        /// </summary>
        /// <param name="pkt">
        /// packet
        /// </param>
        /// <param name="size">
        /// new size
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_shrink_packet")]
        public static extern void av_shrink_packet(libavcodec.AVPacket* pkt, int size);

        /// <summary>
        /// Increase packet size, correctly zeroing padding
        /// </summary>
        /// <param name="pkt">
        /// packet
        /// </param>
        /// <param name="grow_by">
        /// number of bytes by which to increase the size of the packet
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_grow_packet")]
        public static extern int av_grow_packet(libavcodec.AVPacket* pkt, int grow_by);

        /// <summary>
        /// Initialize a reference-counted packet from av_malloc()ed data.
        /// </summary>
        /// <param name="pkt">
        /// packet to be initialized. This function will set the data, size,
        /// buf and destruct fields, all others are left untouched.
        /// </param>
        /// <param name="data">
        /// Data allocated by av_malloc() to be used as packet data. If this
        /// function returns successfully, the data is owned by the underlying
        /// AVBuffer.
        /// The caller may not access the data through other means.
        /// </param>
        /// <param name="size">
        /// size of data in bytes, without the padding. I.e. the full buffer
        /// size is assumed to be size + FF_INPUT_BUFFER_PADDING_SIZE.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on error
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_from_data")]
        public static extern int av_packet_from_data(libavcodec.AVPacket* pkt, byte* data, int size);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_dup_packet")]
        public static extern int av_dup_packet(libavcodec.AVPacket* pkt);

        /// <summary>
        /// Copy packet, including contents
        /// </summary>
        /// <returns>
        /// 0 on success, negative AVERROR on fail
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_copy_packet")]
        public static extern int av_copy_packet(libavcodec.AVPacket* dst, libavcodec.AVPacket* src);

        /// <summary>
        /// Copy packet side data
        /// </summary>
        /// <returns>
        /// 0 on success, negative AVERROR on fail
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_copy_packet_side_data")]
        public static extern int av_copy_packet_side_data(libavcodec.AVPacket* dst, libavcodec.AVPacket* src);

        /// <summary>
        /// Free a packet.
        /// </summary>
        /// <param name="pkt">
        /// packet to free
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_free_packet")]
        public static extern void av_free_packet(libavcodec.AVPacket* pkt);

        /// <summary>
        /// Allocate new information of a packet.
        /// </summary>
        /// <param name="pkt">
        /// packet
        /// </param>
        /// <param name="type">
        /// side information type
        /// </param>
        /// <param name="size">
        /// side information size
        /// </param>
        /// <returns>
        /// pointer to fresh allocated data or NULL otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_new_side_data")]
        public static extern byte* av_packet_new_side_data(libavcodec.AVPacket* pkt, libavcodec.AVPacketSideDataType type, int size);

        /// <summary>
        /// Shrink the already allocated side data buffer
        /// </summary>
        /// <param name="pkt">
        /// packet
        /// </param>
        /// <param name="type">
        /// side information type
        /// </param>
        /// <param name="size">
        /// new side information size
        /// </param>
        /// <returns>
        /// 0 on success, < 0 on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_shrink_side_data")]
        public static extern int av_packet_shrink_side_data(libavcodec.AVPacket* pkt, libavcodec.AVPacketSideDataType type, int size);

        /// <summary>
        /// Get side information from packet.
        /// </summary>
        /// <param name="pkt">
        /// packet
        /// </param>
        /// <param name="type">
        /// desired side information type
        /// </param>
        /// <param name="size">
        /// pointer for side information size to store (optional)
        /// </param>
        /// <returns>
        /// pointer to data if present or NULL otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_get_side_data")]
        public static extern byte* av_packet_get_side_data(libavcodec.AVPacket* pkt, libavcodec.AVPacketSideDataType type, int* size);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_merge_side_data")]
        public static extern int av_packet_merge_side_data(libavcodec.AVPacket* pkt);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_split_side_data")]
        public static extern int av_packet_split_side_data(libavcodec.AVPacket* pkt);

        /// <summary>
        /// Pack a dictionary for use in side_data.
        /// </summary>
        /// <param name="dict">
        /// The dictionary to pack.
        /// </param>
        /// <param name="size">
        /// pointer to store the size of the returned data
        /// </param>
        /// <returns>
        /// pointer to data if successful, NULL otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_pack_dictionary")]
        public static extern byte* av_packet_pack_dictionary(libavutil.AVDictionary* dict, int* size);

        /// <summary>
        /// Unpack a dictionary from side_data.
        /// </summary>
        /// <param name="data">
        /// data from side_data
        /// </param>
        /// <param name="size">
        /// size of the data
        /// </param>
        /// <param name="dict">
        /// the metadata storage dictionary
        /// </param>
        /// <returns>
        /// 0 on success, < 0 on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_unpack_dictionary")]
        public static extern int av_packet_unpack_dictionary(byte* data, int size, libavutil.AVDictionary** dict);

        /// <summary>
        /// Unpack a dictionary from side_data.
        /// </summary>
        /// <param name="data">
        /// data from side_data
        /// </param>
        /// <param name="size">
        /// size of the data
        /// </param>
        /// <param name="dict">
        /// the metadata storage dictionary
        /// </param>
        /// <returns>
        /// 0 on success, < 0 on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_unpack_dictionary")]
        public static extern int av_packet_unpack_dictionary(byte* data, int size, ref libavutil.AVDictionary* dict);

        /// <summary>
        /// Convenience function to free all the side data stored.
        /// All the other fields stay untouched.
        /// </summary>
        /// <param name="pkt">
        /// packet
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_free_side_data")]
        public static extern void av_packet_free_side_data(libavcodec.AVPacket* pkt);

        /// <summary>
        /// Setup a new reference to the data described by a given packet
        /// 
        /// If src is reference-counted, setup dst as a new reference to the
        /// buffer in src. Otherwise allocate a new buffer in dst and copy the
        /// data from src into it.
        /// 
        /// All the other fields are copied from src.
        /// 
        /// @see av_packet_unref
        /// </summary>
        /// <param name="dst">
        /// Destination packet
        /// </param>
        /// <param name="src">
        /// Source packet
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_ref")]
        public static extern int av_packet_ref(libavcodec.AVPacket* dst, libavcodec.AVPacket* src);

        /// <summary>
        /// Wipe the packet.
        /// 
        /// Unreference the buffer referenced by the packet and reset the
        /// remaining packet fields to their default values.
        /// </summary>
        /// <param name="pkt">
        /// The packet to be unreferenced.
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_unref")]
        public static extern void av_packet_unref(libavcodec.AVPacket* pkt);

        /// <summary>
        /// Move every field in src to dst and reset src.
        /// 
        /// @see av_packet_unref
        /// </summary>
        /// <param name="src">
        /// Source packet, will be reset
        /// </param>
        /// <param name="dst">
        /// Destination packet
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_move_ref")]
        public static extern void av_packet_move_ref(libavcodec.AVPacket* dst, libavcodec.AVPacket* src);

        /// <summary>
        /// Copy only "properties" fields from src to dst.
        /// 
        /// Properties for the purpose of this function are all the fields
        /// beside those related to the packet data (buf, data, size)
        /// </summary>
        /// <param name="dst">
        /// Destination packet
        /// </param>
        /// <param name="src">
        /// Source packet
        /// </param>
        /// <returns>
        /// 0 on success AVERROR on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_packet_copy_props")]
        public static extern int av_packet_copy_props(libavcodec.AVPacket* dst, libavcodec.AVPacket* src);

        /// <summary>
        /// Find a registered decoder with a matching codec ID.
        /// </summary>
        /// <param name="id">
        /// AVCodecID of the requested decoder
        /// </param>
        /// <returns>
        /// A decoder if one was found, NULL otherwise.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_find_decoder")]
        public static extern libavcodec.AVCodec* avcodec_find_decoder(libavcodec.AVCodecID id);

        /// <summary>
        /// Find a registered decoder with the specified name.
        /// </summary>
        /// <param name="name">
        /// name of the requested decoder
        /// </param>
        /// <returns>
        /// A decoder if one was found, NULL otherwise.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_find_decoder_by_name")]
        public static extern libavcodec.AVCodec* avcodec_find_decoder_by_name(string name);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_default_get_buffer")]
        public static extern int avcodec_default_get_buffer(libavcodec.AVCodecContext* s, libavutil.AVFrame* pic);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_default_release_buffer")]
        public static extern void avcodec_default_release_buffer(libavcodec.AVCodecContext* s, libavutil.AVFrame* pic);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_default_reget_buffer")]
        public static extern int avcodec_default_reget_buffer(libavcodec.AVCodecContext* s, libavutil.AVFrame* pic);

        /// <summary>
        /// The default callback for AVCodecContext.get_buffer2(). It is made
        /// public so
        /// it can be called by custom get_buffer2() implementations for decoders
        /// without
        /// CODEC_CAP_DR1 set.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_default_get_buffer2")]
        public static extern int avcodec_default_get_buffer2(libavcodec.AVCodecContext* s, libavutil.AVFrame* frame, int flags);

        /// <summary>
        /// Return the amount of padding in pixels which the get_buffer callback
        /// must
        /// provide around the edge of the image for codecs which do not have the
        /// CODEC_FLAG_EMU_EDGE flag.
        /// </summary>
        /// <returns>
        /// Required padding in pixels.
        /// 
        /// @deprecated CODEC_FLAG_EMU_EDGE is deprecated, so this function is no
        /// longer
        /// needed
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_get_edge_width")]
        public static extern uint avcodec_get_edge_width();

        /// <summary>
        /// Modify width and height values so that they will result in a memory
        /// buffer that is acceptable for the codec if you do not use any
        /// horizontal
        /// padding.
        /// 
        /// May only be used if a codec with CODEC_CAP_DR1 has been opened.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_align_dimensions")]
        public static extern void avcodec_align_dimensions(libavcodec.AVCodecContext* s, int* width, int* height);

        /// <summary>
        /// Modify width and height values so that they will result in a memory
        /// buffer that is acceptable for the codec if you also ensure that all
        /// line sizes are a multiple of the respective linesize_align[i].
        /// 
        /// May only be used if a codec with CODEC_CAP_DR1 has been opened.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_align_dimensions2")]
        public static extern void avcodec_align_dimensions2(libavcodec.AVCodecContext* s, int* width, int* height, int* linesize_align);

        /// <summary>
        /// Converts AVChromaLocation to swscale x/y chroma position.
        /// 
        /// The positions represent the chroma (0,0) position in a coordinates
        /// system
        /// with luma (0,0) representing the origin and luma(1,1) representing
        /// 256,256
        /// </summary>
        /// <param name="xpos">
        /// horizontal chroma sample position
        /// </param>
        /// <param name="ypos">
        /// vertical   chroma sample position
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_enum_to_chroma_pos")]
        public static extern int avcodec_enum_to_chroma_pos(int* xpos, int* ypos, libavcodec.AVChromaLocation pos);

        /// <summary>
        /// Converts swscale x/y chroma position to AVChromaLocation.
        /// 
        /// The positions represent the chroma (0,0) position in a coordinates
        /// system
        /// with luma (0,0) representing the origin and luma(1,1) representing
        /// 256,256
        /// </summary>
        /// <param name="xpos">
        /// horizontal chroma sample position
        /// </param>
        /// <param name="ypos">
        /// vertical   chroma sample position
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_chroma_pos_to_enum")]
        public static extern libavcodec.AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos);

        /// <summary>
        /// Wrapper function which calls avcodec_decode_audio4.
        /// 
        /// @deprecated Use avcodec_decode_audio4 instead.
        /// 
        /// Decode the audio frame of size avpkt->size from avpkt->data into
        /// samples.
        /// Some decoders may support multiple frames in a single AVPacket, such
        /// decoders would then just decode the first frame. In this case,
        /// avcodec_decode_audio3 has to be called again with an AVPacket that
        /// contains
        /// the remaining data in order to decode the second frame etc.
        /// If no frame
        /// could be outputted, frame_size_ptr is zero. Otherwise, it is the
        /// decompressed frame size in bytes.
        /// 
        /// @warning You must set frame_size_ptr to the allocated size of the
        /// output buffer before calling avcodec_decode_audio3().
        /// 
        /// @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger
        /// than
        /// the actual read bytes because some optimized bitstream readers read 32
        /// or 64
        /// bits at once and could read over the end.
        /// 
        /// @warning The end of the input buffer avpkt->data should be set to 0 to
        /// ensure that
        /// no overreading happens for damaged MPEG streams.
        /// 
        /// @warning You must not provide a custom get_buffer() when using
        /// avcodec_decode_audio3().  Doing so will override it with
        /// avcodec_default_get_buffer.  Use avcodec_decode_audio4() instead,
        /// which does allow the application to provide a custom get_buffer().
        /// </summary>
        /// <remark>
        /// You might have to align the input buffer avpkt->data and output buffer
        /// samples. The alignment requirements depend on the CPU: On some CPUs it
        /// isn't
        /// necessary at all, on others it won't work at all if not aligned and on
        /// others
        /// it will work but it will have an impact on performance.
        /// 
        /// In practice, avpkt->data should have 4 byte alignment at minimum and
        /// samples should be 16 byte aligned unless the CPU doesn't need it
        /// (AltiVec and SSE do).
        /// </remark>
        /// <remark>
        /// Codecs which have the CODEC_CAP_DELAY capability set have a delay
        /// between input and output, these need to be fed with avpkt->data=NULL,
        /// avpkt->size=0 at the end to return the remaining frames.
        /// </remark>
        /// <param name="avctx">
        /// the codec context
        /// </param>
        /// <param name="[out]">
        /// samples the output buffer, sample type in avctx->sample_fmt
        /// If the sample format is planar, each channel plane will
        /// be the same size, with no padding between channels.
        /// </param>
        /// <param name="[in,out]">
        /// frame_size_ptr the output buffer size in bytes
        /// </param>
        /// <param name="[in]">
        /// avpkt The input AVPacket containing the input buffer.
        /// You can create such packet with av_init_packet() and by then setting
        /// data and size, some decoders might in addition need other fields.
        /// All decoders are designed to use the least fields possible though.
        /// </param>
        /// <returns>
        /// On error a negative value is returned, otherwise the number of bytes
        /// used or zero if no frame data was decompressed (used) from the input
        /// AVPacket.
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_decode_audio3")]
        public static extern int avcodec_decode_audio3(libavcodec.AVCodecContext* avctx, short* samples, int* frame_size_ptr, libavcodec.AVPacket* avpkt);

        /// <summary>
        /// Decode the audio frame of size avpkt->size from avpkt->data into frame.
        /// 
        /// Some decoders may support multiple frames in a single AVPacket. Such
        /// decoders would then just decode the first frame and the return value
        /// would be
        /// less than the packet size. In this case, avcodec_decode_audio4 has to
        /// be
        /// called again with an AVPacket containing the remaining data in order to
        /// decode the second frame, etc...  Even if no frames are returned, the
        /// packet
        /// needs to be fed to the decoder with remaining data until it is
        /// completely
        /// consumed or an error occurs.
        /// 
        /// Some decoders (those marked with CODEC_CAP_DELAY) have a delay between
        /// input
        /// and output. This means that for some packets they will not immediately
        /// produce decoded output and need to be flushed at the end of decoding to
        /// get
        /// all the decoded data. Flushing is done by calling this function with
        /// packets
        /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
        /// returning samples. It is safe to flush even those decoders that are not
        /// marked with CODEC_CAP_DELAY, then no samples will be returned.
        /// 
        /// @warning The input buffer, avpkt->data must be
        /// FF_INPUT_BUFFER_PADDING_SIZE
        /// larger than the actual read bytes because some optimized bitstream
        /// readers read 32 or 64 bits at once and could read over the end.
        /// </summary>
        /// <param name="avctx">
        /// the codec context
        /// </param>
        /// <param name="[out]">
        /// frame The AVFrame in which to store decoded audio samples.
        /// The decoder will allocate a buffer for the decoded frame by
        /// calling the AVCodecContext.get_buffer2() callback.
        /// When AVCodecContext.refcounted_frames is set to 1, the frame is
        /// reference counted and the returned reference belongs to the
        /// caller. The caller must release the frame using av_frame_unref()
        /// when the frame is no longer needed. The caller may safely write
        /// to the frame if av_frame_is_writable() returns 1.
        /// When AVCodecContext.refcounted_frames is set to 0, the returned
        /// reference belongs to the decoder and is valid only until the
        /// next call to this function or until closing or flushing the
        /// decoder. The caller may not write to it.
        /// </param>
        /// <param name="[out]">
        /// got_frame_ptr Zero if no frame could be decoded, otherwise it is
        /// non-zero. Note that this field being set to zero
        /// does not mean that an error has occurred. For
        /// decoders with CODEC_CAP_DELAY set, no given decode
        /// call is guaranteed to produce a frame.
        /// </param>
        /// <param name="[in]">
        /// avpkt The input AVPacket containing the input buffer.
        /// At least avpkt->data and avpkt->size should be set. Some
        /// decoders might also require additional fields to be set.
        /// </param>
        /// <returns>
        /// A negative error code is returned if an error occurred during
        /// decoding, otherwise the number of bytes consumed from the input
        /// AVPacket is returned.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_decode_audio4")]
        public static extern int avcodec_decode_audio4(libavcodec.AVCodecContext* avctx, libavutil.AVFrame* frame, int* got_frame_ptr, libavcodec.AVPacket* avpkt);

        /// <summary>
        /// Decode the video frame of size avpkt->size from avpkt->data into
        /// picture.
        /// Some decoders may support multiple frames in a single AVPacket, such
        /// decoders would then just decode the first frame.
        /// 
        /// @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger
        /// than
        /// the actual read bytes because some optimized bitstream readers read 32
        /// or 64
        /// bits at once and could read over the end.
        /// 
        /// @warning The end of the input buffer buf should be set to 0 to ensure
        /// that
        /// no overreading happens for damaged MPEG streams.
        /// </summary>
        /// <remark>
        /// Codecs which have the CODEC_CAP_DELAY capability set have a delay
        /// between input and output, these need to be fed with avpkt->data=NULL,
        /// avpkt->size=0 at the end to return the remaining frames.
        /// </remark>
        /// <param name="avctx">
        /// the codec context
        /// </param>
        /// <param name="[out]">
        /// picture The AVFrame in which the decoded video frame will be stored.
        /// Use av_frame_alloc() to get an AVFrame. The codec will
        /// allocate memory for the actual bitmap by calling the
        /// AVCodecContext.get_buffer2() callback.
        /// When AVCodecContext.refcounted_frames is set to 1, the frame is
        /// reference counted and the returned reference belongs to the
        /// caller. The caller must release the frame using av_frame_unref()
        /// when the frame is no longer needed. The caller may safely write
        /// to the frame if av_frame_is_writable() returns 1.
        /// When AVCodecContext.refcounted_frames is set to 0, the returned
        /// reference belongs to the decoder and is valid only until the
        /// next call to this function or until closing or flushing the
        /// decoder. The caller may not write to it.
        /// </param>
        /// <param name="[in]">
        /// avpkt The input AVPacket containing the input buffer.
        /// You can create such packet with av_init_packet() and by then setting
        /// data and size, some decoders might in addition need other fields like
        /// flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least
        /// fields possible.
        /// </param>
        /// <param name="[in,out]">
        /// got_picture_ptr Zero if no frame could be decompressed, otherwise, it
        /// is nonzero.
        /// </param>
        /// <returns>
        /// On error a negative value is returned, otherwise the number of bytes
        /// used or zero if no frame could be decompressed.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_decode_video2")]
        public static extern int avcodec_decode_video2(libavcodec.AVCodecContext* avctx, libavutil.AVFrame* picture, int* got_picture_ptr, libavcodec.AVPacket* avpkt);

        /// <summary>
        /// Decode a subtitle message.
        /// Return a negative value on error, otherwise return the number of bytes
        /// used.
        /// If no subtitle could be decompressed, got_sub_ptr is zero.
        /// Otherwise, the subtitle is stored in *sub.
        /// Note that CODEC_CAP_DR1 is not available for subtitle codecs. This is
        /// for
        /// simplicity, because the performance difference is expect to be
        /// negligible
        /// and reusing a get_buffer written for video codecs would probably
        /// perform badly
        /// due to a potentially very different allocation pattern.
        /// 
        /// Some decoders (those marked with CODEC_CAP_DELAY) have a delay between
        /// input
        /// and output. This means that for some packets they will not immediately
        /// produce decoded output and need to be flushed at the end of decoding to
        /// get
        /// all the decoded data. Flushing is done by calling this function with
        /// packets
        /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
        /// returning subtitles. It is safe to flush even those decoders that are
        /// not
        /// marked with CODEC_CAP_DELAY, then no subtitles will be returned.
        /// </summary>
        /// <param name="avctx">
        /// the codec context
        /// </param>
        /// <param name="[out]">
        /// sub The AVSubtitle in which the decoded subtitle will be stored, must
        /// be
        /// freed with avsubtitle_free if *got_sub_ptr is set.
        /// </param>
        /// <param name="[in,out]">
        /// got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is
        /// nonzero.
        /// </param>
        /// <param name="[in]">
        /// avpkt The input AVPacket containing the input buffer.
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_decode_subtitle2")]
        public static extern int avcodec_decode_subtitle2(libavcodec.AVCodecContext* avctx, libavcodec.AVSubtitle* sub, int* got_sub_ptr, libavcodec.AVPacket* avpkt);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_parser_next")]
        public static extern libavcodec.AVCodecParser* av_parser_next(libavcodec.AVCodecParser* c);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_register_codec_parser")]
        public static extern void av_register_codec_parser(libavcodec.AVCodecParser* parser);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_parser_init")]
        public static extern libavcodec.AVCodecParserContext* av_parser_init(int codec_id);

        /// <summary>
        /// Parse a packet.
        /// </summary>
        /// <param name="s">
        /// parser context.
        /// </param>
        /// <param name="avctx">
        /// codec context.
        /// </param>
        /// <param name="poutbuf">
        /// set to pointer to parsed buffer or NULL if not yet finished.
        /// </param>
        /// <param name="poutbuf_size">
        /// set to size of parsed buffer or zero if not yet finished.
        /// </param>
        /// <param name="buf">
        /// input buffer.
        /// </param>
        /// <param name="buf_size">
        /// input length, to signal EOF, this should be 0 (so that the last frame
        /// can be output).
        /// </param>
        /// <param name="pts">
        /// input presentation timestamp.
        /// </param>
        /// <param name="dts">
        /// input decoding timestamp.
        /// </param>
        /// <param name="pos">
        /// input byte position in stream.
        /// </param>
        /// <returns>
        /// the number of bytes of the input bitstream used.
        /// 
        /// Example:
        /// @code
        /// while(in_len){
        /// len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
        /// in_data, in_len,
        /// pts, dts, pos);
        /// in_data += len;
        /// in_len  -= len;
        /// 
        /// if(size)
        /// decode_frame(data, size);
        /// }
        /// @endcode
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_parser_parse2")]
        public static extern int av_parser_parse2(libavcodec.AVCodecParserContext* s, libavcodec.AVCodecContext* avctx, byte** poutbuf, int* poutbuf_size, byte* buf, int buf_size, long pts, long dts, long pos);

        /// <summary>
        /// Parse a packet.
        /// </summary>
        /// <param name="s">
        /// parser context.
        /// </param>
        /// <param name="avctx">
        /// codec context.
        /// </param>
        /// <param name="poutbuf">
        /// set to pointer to parsed buffer or NULL if not yet finished.
        /// </param>
        /// <param name="poutbuf_size">
        /// set to size of parsed buffer or zero if not yet finished.
        /// </param>
        /// <param name="buf">
        /// input buffer.
        /// </param>
        /// <param name="buf_size">
        /// input length, to signal EOF, this should be 0 (so that the last frame
        /// can be output).
        /// </param>
        /// <param name="pts">
        /// input presentation timestamp.
        /// </param>
        /// <param name="dts">
        /// input decoding timestamp.
        /// </param>
        /// <param name="pos">
        /// input byte position in stream.
        /// </param>
        /// <returns>
        /// the number of bytes of the input bitstream used.
        /// 
        /// Example:
        /// @code
        /// while(in_len){
        /// len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
        /// in_data, in_len,
        /// pts, dts, pos);
        /// in_data += len;
        /// in_len  -= len;
        /// 
        /// if(size)
        /// decode_frame(data, size);
        /// }
        /// @endcode
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_parser_parse2")]
        public static extern int av_parser_parse2(libavcodec.AVCodecParserContext* s, libavcodec.AVCodecContext* avctx, ref byte* poutbuf, int* poutbuf_size, byte* buf, int buf_size, long pts, long dts, long pos);

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// 0 if the output buffer is a subset of the input, 1 if it is allocated
        /// and must be freed
        /// @deprecated use AVBitStreamFilter
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_parser_change")]
        public static extern int av_parser_change(libavcodec.AVCodecParserContext* s, libavcodec.AVCodecContext* avctx, byte** poutbuf, int* poutbuf_size, byte* buf, int buf_size, int keyframe);

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// 0 if the output buffer is a subset of the input, 1 if it is allocated
        /// and must be freed
        /// @deprecated use AVBitStreamFilter
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_parser_change")]
        public static extern int av_parser_change(libavcodec.AVCodecParserContext* s, libavcodec.AVCodecContext* avctx, ref byte* poutbuf, int* poutbuf_size, byte* buf, int buf_size, int keyframe);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_parser_close")]
        public static extern void av_parser_close(libavcodec.AVCodecParserContext* s);

        /// <summary>
        /// Find a registered encoder with a matching codec ID.
        /// </summary>
        /// <param name="id">
        /// AVCodecID of the requested encoder
        /// </param>
        /// <returns>
        /// An encoder if one was found, NULL otherwise.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_find_encoder")]
        public static extern libavcodec.AVCodec* avcodec_find_encoder(libavcodec.AVCodecID id);

        /// <summary>
        /// Find a registered encoder with the specified name.
        /// </summary>
        /// <param name="name">
        /// name of the requested encoder
        /// </param>
        /// <returns>
        /// An encoder if one was found, NULL otherwise.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_find_encoder_by_name")]
        public static extern libavcodec.AVCodec* avcodec_find_encoder_by_name(string name);

        /// <summary>
        /// Encode an audio frame from samples into buf.
        /// 
        /// @deprecated Use avcodec_encode_audio2 instead.
        /// </summary>
        /// <remark>
        /// The output buffer should be at least FF_MIN_BUFFER_SIZE bytes large.
        /// However, for codecs with avctx->frame_size equal to 0 (e.g. PCM) the
        /// user
        /// will know how much space is needed because it depends on the value
        /// passed
        /// in buf_size as described below. In that case a lower value can be used.
        /// </remark>
        /// <param name="avctx">
        /// the codec context
        /// </param>
        /// <param name="[out]">
        /// buf the output buffer
        /// </param>
        /// <param name="[in]">
        /// buf_size the output buffer size
        /// </param>
        /// <param name="[in]">
        /// samples the input buffer containing the samples
        /// The number of samples read from this buffer is frame_size*channels,
        /// both of which are defined in avctx.
        /// For codecs which have avctx->frame_size equal to 0 (e.g. PCM) the
        /// number of
        /// samples read from samples is equal to:
        /// buf_size * 8 / (avctx->channels *
        /// av_get_bits_per_sample(avctx->codec_id))
        /// This also implies that av_get_bits_per_sample() must not return 0 for
        /// these
        /// codecs.
        /// </param>
        /// <returns>
        /// On error a negative value is returned, on success zero or the number
        /// of bytes used to encode the data read from the input buffer.
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_encode_audio")]
        public static extern int avcodec_encode_audio(libavcodec.AVCodecContext* avctx, byte* buf, int buf_size, short* samples);

        /// <summary>
        /// Encode a frame of audio.
        /// 
        /// Takes input samples from frame and writes the next output packet, if
        /// available, to avpkt. The output packet does not necessarily contain
        /// data for
        /// the most recent frame, as encoders can delay, split, and combine input
        /// frames
        /// internally as needed.
        /// </summary>
        /// <param name="avctx">
        /// codec context
        /// </param>
        /// <param name="avpkt">
        /// output AVPacket.
        /// The user can supply an output buffer by setting
        /// avpkt->data and avpkt->size prior to calling the
        /// function, but if the size of the user-provided data is not
        /// large enough, encoding will fail. If avpkt->data and
        /// avpkt->size are set, avpkt->destruct must also be set. All
        /// other AVPacket fields will be reset by the encoder using
        /// av_init_packet(). If avpkt->data is NULL, the encoder will
        /// allocate it. The encoder will set avpkt->size to the size
        /// of the output packet.
        /// 
        /// If this function fails or produces no output, avpkt will be
        /// freed using av_free_packet() (i.e. avpkt->destruct will be
        /// called to free the user supplied buffer).
        /// </param>
        /// <param name="[in]">
        /// frame AVFrame containing the raw audio data to be encoded.
        /// May be NULL when flushing an encoder that has the
        /// CODEC_CAP_DELAY capability set.
        /// If CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
        /// can have any number of samples.
        /// If it is not set, frame->nb_samples must be equal to
        /// avctx->frame_size for all frames except the last.
        /// The final frame may be smaller than avctx->frame_size.
        /// </param>
        /// <param name="[out]">
        /// got_packet_ptr This field is set to 1 by libavcodec if the
        /// output packet is non-empty, and to 0 if it is
        /// empty. If the function returns an error, the
        /// packet can be assumed to be invalid, and the
        /// value of got_packet_ptr is undefined and should
        /// not be used.
        /// </param>
        /// <returns>
        /// 0 on success, negative error code on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_encode_audio2")]
        public static extern int avcodec_encode_audio2(libavcodec.AVCodecContext* avctx, libavcodec.AVPacket* avpkt, libavutil.AVFrame* frame, int* got_packet_ptr);

        /// <summary>
        /// @deprecated use avcodec_encode_video2() instead.
        /// 
        /// Encode a video frame from pict into buf.
        /// The input picture should be
        /// stored using a specific format, namely avctx.pix_fmt.
        /// </summary>
        /// <param name="avctx">
        /// the codec context
        /// </param>
        /// <param name="[out]">
        /// buf the output buffer for the bitstream of encoded frame
        /// </param>
        /// <param name="[in]">
        /// buf_size the size of the output buffer in bytes
        /// </param>
        /// <param name="[in]">
        /// pict the input picture to encode
        /// </param>
        /// <returns>
        /// On error a negative value is returned, on success zero or the number
        /// of bytes used from the output buffer.
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_encode_video")]
        public static extern int avcodec_encode_video(libavcodec.AVCodecContext* avctx, byte* buf, int buf_size, libavutil.AVFrame* pict);

        /// <summary>
        /// Encode a frame of video.
        /// 
        /// Takes input raw video data from frame and writes the next output
        /// packet, if
        /// available, to avpkt. The output packet does not necessarily contain
        /// data for
        /// the most recent frame, as encoders can delay and reorder input frames
        /// internally as needed.
        /// </summary>
        /// <param name="avctx">
        /// codec context
        /// </param>
        /// <param name="avpkt">
        /// output AVPacket.
        /// The user can supply an output buffer by setting
        /// avpkt->data and avpkt->size prior to calling the
        /// function, but if the size of the user-provided data is not
        /// large enough, encoding will fail. All other AVPacket fields
        /// will be reset by the encoder using av_init_packet(). If
        /// avpkt->data is NULL, the encoder will allocate it.
        /// The encoder will set avpkt->size to the size of the
        /// output packet. The returned data (if any) belongs to the
        /// caller, he is responsible for freeing it.
        /// 
        /// If this function fails or produces no output, avpkt will be
        /// freed using av_free_packet() (i.e. avpkt->destruct will be
        /// called to free the user supplied buffer).
        /// </param>
        /// <param name="[in]">
        /// frame AVFrame containing the raw video data to be encoded.
        /// May be NULL when flushing an encoder that has the
        /// CODEC_CAP_DELAY capability set.
        /// </param>
        /// <param name="[out]">
        /// got_packet_ptr This field is set to 1 by libavcodec if the
        /// output packet is non-empty, and to 0 if it is
        /// empty. If the function returns an error, the
        /// packet can be assumed to be invalid, and the
        /// value of got_packet_ptr is undefined and should
        /// not be used.
        /// </param>
        /// <returns>
        /// 0 on success, negative error code on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_encode_video2")]
        public static extern int avcodec_encode_video2(libavcodec.AVCodecContext* avctx, libavcodec.AVPacket* avpkt, libavutil.AVFrame* frame, int* got_packet_ptr);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_encode_subtitle")]
        public static extern int avcodec_encode_subtitle(libavcodec.AVCodecContext* avctx, byte* buf, int buf_size, libavcodec.AVSubtitle* sub);

        /// <summary>
        /// Initialize audio resampling context.
        /// </summary>
        /// <param name="output_channels">
        /// number of output channels
        /// </param>
        /// <param name="input_channels">
        /// number of input channels
        /// </param>
        /// <param name="output_rate">
        /// output sample rate
        /// </param>
        /// <param name="input_rate">
        /// input sample rate
        /// </param>
        /// <param name="sample_fmt_out">
        /// requested output sample format
        /// </param>
        /// <param name="sample_fmt_in">
        /// input sample format
        /// </param>
        /// <param name="filter_length">
        /// length of each FIR filter in the filterbank relative to the cutoff
        /// frequency
        /// </param>
        /// <param name="log2_phase_count">
        /// log2 of the number of entries in the polyphase filterbank
        /// </param>
        /// <param name="linear">
        /// if 1 then the used FIR filter will be linearly interpolated
        /// between the 2 closest, if 0 the closest will be used
        /// </param>
        /// <param name="cutoff">
        /// cutoff frequency, 1.0 corresponds to half the output sampling rate
        /// </param>
        /// <returns>
        /// allocated ReSampleContext, NULL if error occurred
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_resample_init")]
        public static extern libavcodec.ReSampleContext* av_audio_resample_init(int output_channels, int input_channels, int output_rate, int input_rate, libavutil.AVSampleFormat sample_fmt_out, libavutil.AVSampleFormat sample_fmt_in, int filter_length, int log2_phase_count, int linear, double cutoff);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="audio_resample")]
        public static extern int audio_resample(libavcodec.ReSampleContext* s, short* output, short* input, int nb_samples);

        /// <summary>
        /// Free resample context.
        /// </summary>
        /// <param name="s">
        /// a non-NULL pointer to a resample context previously
        /// created with av_audio_resample_init()
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="audio_resample_close")]
        public static extern void audio_resample_close(libavcodec.ReSampleContext* s);

        /// <summary>
        /// Initialize an audio resampler.
        /// Note, if either rate is not an integer then simply scale both rates up
        /// so they are.
        /// </summary>
        /// <param name="filter_length">
        /// length of each FIR filter in the filterbank relative to the cutoff freq
        /// </param>
        /// <param name="log2_phase_count">
        /// log2 of the number of entries in the polyphase filterbank
        /// </param>
        /// <param name="linear">
        /// If 1 then the used FIR filter will be linearly interpolated
        /// between the 2 closest, if 0 the closest will be used
        /// </param>
        /// <param name="cutoff">
        /// cutoff frequency, 1.0 corresponds to half the output sampling rate
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_resample_init")]
        public static extern libavcodec.AVResampleContext* av_resample_init(int out_rate, int in_rate, int filter_length, int log2_phase_count, int linear, double cutoff);

        /// <summary>
        /// Resample an array of samples using a previously configured context.
        /// </summary>
        /// <param name="src">
        /// an array of unconsumed samples
        /// </param>
        /// <param name="consumed">
        /// the number of samples of src which have been consumed are returned here
        /// </param>
        /// <param name="src_size">
        /// the number of unconsumed samples available
        /// </param>
        /// <param name="dst_size">
        /// the amount of space in samples available in dst
        /// </param>
        /// <param name="update_ctx">
        /// If this is 0 then the context will not be modified, that way several
        /// channels can be resampled with the same context.
        /// </param>
        /// <returns>
        /// the number of samples written in dst or -1 if an error occurred
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_resample")]
        public static extern int av_resample(libavcodec.AVResampleContext* c, short* dst, short* src, int* consumed, int src_size, int dst_size, int update_ctx);

        /// <summary>
        /// Compensate samplerate/timestamp drift. The compensation is done by
        /// changing
        /// the resampler parameters, so no audible clicks or similar distortions
        /// occur
        /// </summary>
        /// <param name="compensation_distance">
        /// distance in output samples over which the compensation should be
        /// performed
        /// </param>
        /// <param name="sample_delta">
        /// number of output samples which should be output less
        /// 
        /// example: av_resample_compensate(c, 10, 500)
        /// here instead of 510 samples only 500 samples would be output
        /// 
        /// note, due to rounding the actual compensation might be slightly
        /// different,
        /// especially if the compensation_distance is large and the in_rate used
        /// during init is small
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_resample_compensate")]
        public static extern void av_resample_compensate(libavcodec.AVResampleContext* c, int sample_delta, int compensation_distance);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_resample_close")]
        public static extern void av_resample_close(libavcodec.AVResampleContext* c);

        /// <summary>
        /// Allocate memory for the pixels of a picture and setup the AVPicture
        /// fields for it.
        /// 
        /// Call avpicture_free() to free it.
        /// </summary>
        /// <param name="picture">
        /// the picture structure to be filled in
        /// </param>
        /// <param name="pix_fmt">
        /// the pixel format of the picture
        /// </param>
        /// <param name="width">
        /// the width of the picture
        /// </param>
        /// <param name="height">
        /// the height of the picture
        /// </param>
        /// <returns>
        /// zero if successful, a negative error code otherwise
        /// 
        /// @see av_image_alloc(), avpicture_fill()
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avpicture_alloc")]
        public static extern int avpicture_alloc(libavcodec.AVPicture* picture, libavutil.AVPixelFormat pix_fmt, int width, int height);

        /// <summary>
        /// Free a picture previously allocated by avpicture_alloc().
        /// The data buffer used by the AVPicture is freed, but the AVPicture
        /// structure
        /// itself is not.
        /// </summary>
        /// <param name="picture">
        /// the AVPicture to be freed
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avpicture_free")]
        public static extern void avpicture_free(libavcodec.AVPicture* picture);

        /// <summary>
        /// Setup the picture fields based on the specified image parameters
        /// and the provided image data buffer.
        /// 
        /// The picture fields are filled in by using the image data buffer
        /// pointed to by ptr.
        /// 
        /// If ptr is NULL, the function will fill only the picture linesize
        /// array and return the required size for the image buffer.
        /// 
        /// To allocate an image buffer and fill the picture data in one call,
        /// use avpicture_alloc().
        /// </summary>
        /// <param name="picture">
        /// the picture to be filled in
        /// </param>
        /// <param name="ptr">
        /// buffer where the image data is stored, or NULL
        /// </param>
        /// <param name="pix_fmt">
        /// the pixel format of the image
        /// </param>
        /// <param name="width">
        /// the width of the image in pixels
        /// </param>
        /// <param name="height">
        /// the height of the image in pixels
        /// </param>
        /// <returns>
        /// the size in bytes required for src, a negative error code
        /// in case of failure
        /// 
        /// @see av_image_fill_arrays()
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avpicture_fill")]
        public static extern int avpicture_fill(libavcodec.AVPicture* picture, byte* ptr, libavutil.AVPixelFormat pix_fmt, int width, int height);

        /// <summary>
        /// Copy pixel data from an AVPicture into a buffer.
        /// 
        /// avpicture_get_size() can be used to compute the required size for
        /// the buffer to fill.
        /// </summary>
        /// <param name="src">
        /// source picture with filled data
        /// </param>
        /// <param name="pix_fmt">
        /// picture pixel format
        /// </param>
        /// <param name="width">
        /// picture width
        /// </param>
        /// <param name="height">
        /// picture height
        /// </param>
        /// <param name="dest">
        /// destination buffer
        /// </param>
        /// <param name="dest_size">
        /// destination buffer size in bytes
        /// </param>
        /// <returns>
        /// the number of bytes written to dest, or a negative value
        /// (error code) on error, for example if the destination buffer is not
        /// big enough
        /// 
        /// @see av_image_copy_to_buffer()
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avpicture_layout")]
        public static extern int avpicture_layout(libavcodec.AVPicture* src, libavutil.AVPixelFormat pix_fmt, int width, int height, byte* dest, int dest_size);

        /// <summary>
        /// Calculate the size in bytes that a picture of the given width and
        /// height
        /// would occupy if stored in the given picture format.
        /// </summary>
        /// <param name="pix_fmt">
        /// picture pixel format
        /// </param>
        /// <param name="width">
        /// picture width
        /// </param>
        /// <param name="height">
        /// picture height
        /// </param>
        /// <returns>
        /// the computed picture buffer size or a negative error code
        /// in case of error
        /// 
        /// @see av_image_get_buffer_size().
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avpicture_get_size")]
        public static extern int avpicture_get_size(libavutil.AVPixelFormat pix_fmt, int width, int height);

        /// <summary>
        /// deinterlace - if not supported return -1
        /// 
        /// @deprecated - use yadif (in libavfilter) instead
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avpicture_deinterlace")]
        public static extern int avpicture_deinterlace(libavcodec.AVPicture* dst, libavcodec.AVPicture* src, libavutil.AVPixelFormat pix_fmt, int width, int height);

        /// <summary>
        /// Copy image src to dst. Wraps av_image_copy().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_picture_copy")]
        public static extern void av_picture_copy(libavcodec.AVPicture* dst, libavcodec.AVPicture* src, libavutil.AVPixelFormat pix_fmt, int width, int height);

        /// <summary>
        /// Crop image top and left side.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_picture_crop")]
        public static extern int av_picture_crop(libavcodec.AVPicture* dst, libavcodec.AVPicture* src, libavutil.AVPixelFormat pix_fmt, int top_band, int left_band);

        /// <summary>
        /// Pad image.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_picture_pad")]
        public static extern int av_picture_pad(libavcodec.AVPicture* dst, libavcodec.AVPicture* src, int height, int width, libavutil.AVPixelFormat pix_fmt, int padtop, int padbottom, int padleft, int padright, int* color);

        /// <summary>
        /// Utility function to access log2_chroma_w log2_chroma_h from
        /// the pixel format AVPixFmtDescriptor.
        /// 
        /// This function asserts that pix_fmt is valid. See
        /// av_pix_fmt_get_chroma_sub_sample
        /// for one that returns a failure code and continues in case of invalid
        /// pix_fmts.
        /// </summary>
        /// <param name="[in]">
        /// pix_fmt the pixel format
        /// </param>
        /// <param name="[out]">
        /// h_shift store log2_chroma_w
        /// </param>
        /// <param name="[out]">
        /// v_shift store log2_chroma_h
        /// 
        /// @see av_pix_fmt_get_chroma_sub_sample
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_get_chroma_sub_sample")]
        public static extern void avcodec_get_chroma_sub_sample(libavutil.AVPixelFormat pix_fmt, int* h_shift, int* v_shift);

        /// <summary>
        /// Return a value representing the fourCC code associated to the
        /// pixel format pix_fmt, or 0 if no associated fourCC code can be
        /// found.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_pix_fmt_to_codec_tag")]
        public static extern uint avcodec_pix_fmt_to_codec_tag(libavutil.AVPixelFormat pix_fmt);

        /// <summary>
        /// Compute what kind of losses will occur when converting from one
        /// specific
        /// pixel format to another.
        /// When converting from one pixel format to another, information loss may
        /// occur.
        /// For example, when converting from RGB24 to GRAY, the color information
        /// will
        /// be lost. Similarly, other losses occur when converting from some
        /// formats to
        /// other formats. These losses can involve loss of chroma, but also loss
        /// of
        /// resolution, loss of color depth, loss due to the color space
        /// conversion, loss
        /// of the alpha bits or loss due to color quantization.
        /// avcodec_get_fix_fmt_loss() informs you about the various types of
        /// losses
        /// which will occur when converting from one pixel format to another.
        /// </summary>
        /// <param name="[in]">
        /// dst_pix_fmt destination pixel format
        /// </param>
        /// <param name="[in]">
        /// src_pix_fmt source pixel format
        /// </param>
        /// <param name="[in]">
        /// has_alpha Whether the source pixel format alpha channel is used.
        /// </param>
        /// <returns>
        /// Combination of flags informing you what kind of losses will occur
        /// (maximum loss for an invalid dst_pix_fmt).
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_get_pix_fmt_loss")]
        public static extern int avcodec_get_pix_fmt_loss(libavutil.AVPixelFormat dst_pix_fmt, libavutil.AVPixelFormat src_pix_fmt, int has_alpha);

        /// <summary>
        /// Find the best pixel format to convert to given a certain source pixel
        /// format.  When converting from one pixel format to another, information
        /// loss
        /// may occur.  For example, when converting from RGB24 to GRAY, the color
        /// information will be lost. Similarly, other losses occur when converting
        /// from
        /// some formats to other formats. avcodec_find_best_pix_fmt_of_2()
        /// searches which of
        /// the given pixel formats should be used to suffer the least amount of
        /// loss.
        /// The pixel formats from which it chooses one, are determined by the
        /// pix_fmt_list parameter.
        /// </summary>
        /// <param name="[in]">
        /// pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to
        /// choose from
        /// </param>
        /// <param name="[in]">
        /// src_pix_fmt source pixel format
        /// </param>
        /// <param name="[in]">
        /// has_alpha Whether the source pixel format alpha channel is used.
        /// </param>
        /// <param name="[out]">
        /// loss_ptr Combination of flags informing you what kind of losses will
        /// occur.
        /// </param>
        /// <returns>
        /// The best pixel format to convert to or -1 if none was found.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_find_best_pix_fmt_of_list")]
        public static extern libavutil.AVPixelFormat avcodec_find_best_pix_fmt_of_list(libavutil.AVPixelFormat* pix_fmt_list, libavutil.AVPixelFormat src_pix_fmt, int has_alpha, int* loss_ptr);

        /// <summary>
        /// Find the best pixel format to convert to given a certain source pixel
        /// format and a selection of two destination pixel formats. When
        /// converting from
        /// one pixel format to another, information loss may occur.  For example,
        /// when converting
        /// from RGB24 to GRAY, the color information will be lost. Similarly,
        /// other losses occur when
        /// converting from some formats to other formats.
        /// avcodec_find_best_pix_fmt_of_2() selects which of
        /// the given pixel formats should be used to suffer the least amount of
        /// loss.
        /// 
        /// If one of the destination formats is AV_PIX_FMT_NONE the other pixel
        /// format (if valid) will be
        /// returned.
        /// 
        /// @code
        /// src_pix_fmt = AV_PIX_FMT_YUV420P;
        /// dst_pix_fmt1= AV_PIX_FMT_RGB24;
        /// dst_pix_fmt2= AV_PIX_FMT_GRAY8;
        /// dst_pix_fmt3= AV_PIX_FMT_RGB8;
        /// loss= FF_LOSS_CHROMA; // don't care about chroma loss, so chroma loss
        /// will be ignored.
        /// dst_pix_fmt = avcodec_find_best_pix_fmt_of_2(dst_pix_fmt1,
        /// dst_pix_fmt2, src_pix_fmt, alpha, &loss);
        /// dst_pix_fmt = avcodec_find_best_pix_fmt_of_2(dst_pix_fmt, dst_pix_fmt3,
        /// src_pix_fmt, alpha, &loss);
        /// @endcode
        /// </summary>
        /// <param name="[in]">
        /// dst_pix_fmt1 One of the two destination pixel formats to choose from
        /// </param>
        /// <param name="[in]">
        /// dst_pix_fmt2 The other of the two destination pixel formats to choose
        /// from
        /// </param>
        /// <param name="[in]">
        /// src_pix_fmt Source pixel format
        /// </param>
        /// <param name="[in]">
        /// has_alpha Whether the source pixel format alpha channel is used.
        /// </param>
        /// <param name="[in,">
        /// out] loss_ptr Combination of loss flags. In: selects which of the
        /// losses to ignore, i.e.
        /// NULL or value of zero means we care about all losses. Out: the loss
        /// that occurs when converting from src to selected dst pixel format.
        /// </param>
        /// <returns>
        /// The best pixel format to convert to or -1 if none was found.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_find_best_pix_fmt_of_2")]
        public static extern libavutil.AVPixelFormat avcodec_find_best_pix_fmt_of_2(libavutil.AVPixelFormat dst_pix_fmt1, libavutil.AVPixelFormat dst_pix_fmt2, libavutil.AVPixelFormat src_pix_fmt, int has_alpha, int* loss_ptr);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_find_best_pix_fmt2")]
        public static extern libavutil.AVPixelFormat avcodec_find_best_pix_fmt2(libavutil.AVPixelFormat dst_pix_fmt1, libavutil.AVPixelFormat dst_pix_fmt2, libavutil.AVPixelFormat src_pix_fmt, int has_alpha, int* loss_ptr);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_default_get_format")]
        public static extern libavutil.AVPixelFormat avcodec_default_get_format(libavcodec.AVCodecContext* s, libavutil.AVPixelFormat* fmt);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_set_dimensions")]
        public static extern void avcodec_set_dimensions(libavcodec.AVCodecContext* s, int width, int height);

        /// <summary>
        /// Put a string representing the codec tag codec_tag in buf.
        /// </summary>
        /// <param name="buf">
        /// buffer to place codec tag in
        /// </param>
        /// <param name="buf_size">
        /// size in bytes of buf
        /// </param>
        /// <param name="codec_tag">
        /// codec tag to assign
        /// </param>
        /// <returns>
        /// the length of the string that would have been generated if
        /// enough space had been available, excluding the trailing null
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_codec_tag_string")]
        public static extern global::System.UIntPtr av_get_codec_tag_string(System.Text.StringBuilder buf, global::System.UIntPtr buf_size, uint codec_tag);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_string")]
        public static extern void avcodec_string(System.Text.StringBuilder buf, int buf_size, libavcodec.AVCodecContext* enc, int encode);

        /// <summary>
        /// Return a name for the specified profile, if available.
        /// </summary>
        /// <param name="codec">
        /// the codec that is searched for the given profile
        /// </param>
        /// <param name="profile">
        /// the profile value for which a name is requested
        /// </param>
        /// <returns>
        /// A name for the profile if found, NULL otherwise.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_profile_name")]
        public static extern sbyte* av_get_profile_name(libavcodec.AVCodec* codec, int profile);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_default_execute")]
        public static extern int avcodec_default_execute(libavcodec.AVCodecContext* c, global::System.IntPtr func, void* arg, int* ret, int count, int size);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_default_execute2")]
        public static extern int avcodec_default_execute2(libavcodec.AVCodecContext* c, global::System.IntPtr func, void* arg, int* ret, int count);

        /// <summary>
        /// Fill AVFrame audio data and linesize pointers.
        /// 
        /// The buffer buf must be a preallocated buffer with a size big enough
        /// to contain the specified samples amount. The filled AVFrame data
        /// pointers will point to this buffer.
        /// 
        /// AVFrame extended_data channel pointers are allocated if necessary for
        /// planar audio.
        /// </summary>
        /// <param name="frame">
        /// the AVFrame
        /// frame->nb_samples must be set prior to calling the
        /// function. This function fills in frame->data,
        /// frame->extended_data, frame->linesize[0].
        /// </param>
        /// <param name="nb_channels">
        /// channel count
        /// </param>
        /// <param name="sample_fmt">
        /// sample format
        /// </param>
        /// <param name="buf">
        /// buffer to use for frame data
        /// </param>
        /// <param name="buf_size">
        /// size of buffer
        /// </param>
        /// <param name="align">
        /// plane size sample alignment (0 = default)
        /// </param>
        /// <returns>
        /// >=0 on success, negative error code on failure
        /// @todo return the size in bytes required to store the samples in
        /// case of success, at the next libavutil bump
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_fill_audio_frame")]
        public static extern int avcodec_fill_audio_frame(libavutil.AVFrame* frame, int nb_channels, libavutil.AVSampleFormat sample_fmt, byte* buf, int buf_size, int align);

        /// <summary>
        /// Reset the internal decoder state / flush internal buffers. Should be
        /// called
        /// e.g. when seeking or when switching to a different stream.
        /// </summary>
        /// <remark>
        /// when refcounted frames are not used (i.e. avctx->refcounted_frames is
        /// 0),
        /// this invalidates the frames previously returned from the decoder. When
        /// refcounted frames are used, the decoder just releases any references it
        /// might
        /// keep internally, but the caller's reference remains valid.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_flush_buffers")]
        public static extern void avcodec_flush_buffers(libavcodec.AVCodecContext* avctx);

        /// <summary>
        /// Return codec bits per sample.
        /// </summary>
        /// <param name="[in]">
        /// codec_id the codec
        /// </param>
        /// <returns>
        /// Number of bits per sample or zero if unknown for the given codec.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_bits_per_sample")]
        public static extern int av_get_bits_per_sample(libavcodec.AVCodecID codec_id);

        /// <summary>
        /// Return the PCM codec associated with a sample format.
        /// </summary>
        /// <param name="be">
        /// endianness, 0 for little, 1 for big,
        /// -1 (or anything else) for native
        /// </param>
        /// <returns>
        /// AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_pcm_codec")]
        public static extern libavcodec.AVCodecID av_get_pcm_codec(libavutil.AVSampleFormat fmt, int be);

        /// <summary>
        /// Return codec bits per sample.
        /// Only return non-zero if the bits per sample is exactly correct, not an
        /// approximation.
        /// </summary>
        /// <param name="[in]">
        /// codec_id the codec
        /// </param>
        /// <returns>
        /// Number of bits per sample or zero if unknown for the given codec.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_exact_bits_per_sample")]
        public static extern int av_get_exact_bits_per_sample(libavcodec.AVCodecID codec_id);

        /// <summary>
        /// Return audio frame duration.
        /// </summary>
        /// <param name="avctx">
        /// codec context
        /// </param>
        /// <param name="frame_bytes">
        /// size of the frame, or 0 if unknown
        /// </param>
        /// <returns>
        /// frame duration, in samples, if known. 0 if not able to
        /// determine.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_audio_frame_duration")]
        public static extern int av_get_audio_frame_duration(libavcodec.AVCodecContext* avctx, int frame_bytes);

        /// <summary>
        /// Register a bitstream filter.
        /// 
        /// The filter will be accessible to the application code through
        /// av_bitstream_filter_next() or can be directly initialized with
        /// av_bitstream_filter_init().
        /// 
        /// @see avcodec_register_all()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_register_bitstream_filter")]
        public static extern void av_register_bitstream_filter(libavcodec.AVBitStreamFilter* bsf);

        /// <summary>
        /// Create and initialize a bitstream filter context given a bitstream
        /// filter name.
        /// 
        /// The returned context must be freed with av_bitstream_filter_close().
        /// </summary>
        /// <param name="name">
        /// the name of the bitstream filter
        /// </param>
        /// <returns>
        /// a bitstream filter context if a matching filter was found
        /// and successfully initialized, NULL otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_bitstream_filter_init")]
        public static extern libavcodec.AVBitStreamFilterContext* av_bitstream_filter_init(string name);

        /// <summary>
        /// Filter bitstream.
        /// 
        /// This function filters the buffer buf with size buf_size, and places the
        /// filtered buffer in the buffer pointed to by poutbuf.
        /// 
        /// The output buffer must be freed by the caller.
        /// </summary>
        /// <param name="bsfc">
        /// bitstream filter context created by av_bitstream_filter_init()
        /// </param>
        /// <param name="avctx">
        /// AVCodecContext accessed by the filter, may be NULL.
        /// If specified, this must point to the encoder context of the
        /// output stream the packet is sent to.
        /// </param>
        /// <param name="args">
        /// arguments which specify the filter configuration, may be NULL
        /// </param>
        /// <param name="poutbuf">
        /// pointer which is updated to point to the filtered buffer
        /// </param>
        /// <param name="poutbuf_size">
        /// pointer which is updated to the filtered buffer size in bytes
        /// </param>
        /// <param name="buf">
        /// buffer containing the data to filter
        /// </param>
        /// <param name="buf_size">
        /// size in bytes of buf
        /// </param>
        /// <param name="keyframe">
        /// set to non-zero if the buffer to filter corresponds to a key-frame
        /// packet data
        /// </param>
        /// <returns>
        /// >= 0 in case of success, or a negative error code in case of failure
        /// 
        /// If the return value is positive, an output buffer is allocated and
        /// is availble in *poutbuf, and is distinct from the input buffer.
        /// 
        /// If the return value is 0, the output buffer is not allocated and
        /// should be considered identical to the input buffer, or in case
        /// poutbuf was set it points to the input buffer (not necessarily to
        /// its starting address).
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_bitstream_filter_filter")]
        public static extern int av_bitstream_filter_filter(libavcodec.AVBitStreamFilterContext* bsfc, libavcodec.AVCodecContext* avctx, string args, byte** poutbuf, int* poutbuf_size, byte* buf, int buf_size, int keyframe);

        /// <summary>
        /// Filter bitstream.
        /// 
        /// This function filters the buffer buf with size buf_size, and places the
        /// filtered buffer in the buffer pointed to by poutbuf.
        /// 
        /// The output buffer must be freed by the caller.
        /// </summary>
        /// <param name="bsfc">
        /// bitstream filter context created by av_bitstream_filter_init()
        /// </param>
        /// <param name="avctx">
        /// AVCodecContext accessed by the filter, may be NULL.
        /// If specified, this must point to the encoder context of the
        /// output stream the packet is sent to.
        /// </param>
        /// <param name="args">
        /// arguments which specify the filter configuration, may be NULL
        /// </param>
        /// <param name="poutbuf">
        /// pointer which is updated to point to the filtered buffer
        /// </param>
        /// <param name="poutbuf_size">
        /// pointer which is updated to the filtered buffer size in bytes
        /// </param>
        /// <param name="buf">
        /// buffer containing the data to filter
        /// </param>
        /// <param name="buf_size">
        /// size in bytes of buf
        /// </param>
        /// <param name="keyframe">
        /// set to non-zero if the buffer to filter corresponds to a key-frame
        /// packet data
        /// </param>
        /// <returns>
        /// >= 0 in case of success, or a negative error code in case of failure
        /// 
        /// If the return value is positive, an output buffer is allocated and
        /// is availble in *poutbuf, and is distinct from the input buffer.
        /// 
        /// If the return value is 0, the output buffer is not allocated and
        /// should be considered identical to the input buffer, or in case
        /// poutbuf was set it points to the input buffer (not necessarily to
        /// its starting address).
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_bitstream_filter_filter")]
        public static extern int av_bitstream_filter_filter(libavcodec.AVBitStreamFilterContext* bsfc, libavcodec.AVCodecContext* avctx, string args, ref byte* poutbuf, int* poutbuf_size, byte* buf, int buf_size, int keyframe);

        /// <summary>
        /// Release bitstream filter context.
        /// </summary>
        /// <param name="bsf">
        /// the bitstream filter context created with
        /// av_bitstream_filter_init(), can be NULL
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_bitstream_filter_close")]
        public static extern void av_bitstream_filter_close(libavcodec.AVBitStreamFilterContext* bsf);

        /// <summary>
        /// If f is NULL, return the first registered bitstream filter,
        /// if f is non-NULL, return the next registered bitstream filter
        /// after f, or NULL if f is the last one.
        /// 
        /// This function can be used to iterate over all registered bitstream
        /// filters.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_bitstream_filter_next")]
        public static extern libavcodec.AVBitStreamFilter* av_bitstream_filter_next(libavcodec.AVBitStreamFilter* f);

        /// <summary>
        /// Same behaviour av_fast_malloc but the buffer has additional
        /// FF_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.
        /// 
        /// In addition the whole buffer will initially and after resizes
        /// be 0-initialized so that no uninitialized data will ever appear.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_fast_padded_malloc")]
        public static extern void av_fast_padded_malloc(void* ptr, uint* size, global::System.UIntPtr min_size);

        /// <summary>
        /// Same behaviour av_fast_padded_malloc except that buffer will always
        /// be 0-initialized after call.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_fast_padded_mallocz")]
        public static extern void av_fast_padded_mallocz(void* ptr, uint* size, global::System.UIntPtr min_size);

        /// <summary>
        /// Encode extradata length to a buffer. Used by xiph codecs.
        /// </summary>
        /// <param name="s">
        /// buffer to write to; must be at least (v/255+1) bytes long
        /// </param>
        /// <param name="v">
        /// size of extradata in bytes
        /// </param>
        /// <returns>
        /// number of bytes written to the buffer.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_xiphlacing")]
        public static extern uint av_xiphlacing(byte* s, uint v);

        /// <summary>
        /// Log a generic warning message about a missing feature. This function is
        /// intended to be used internally by FFmpeg (libavcodec, libavformat,
        /// etc.)
        /// only, and would normally not be used by applications.
        /// </summary>
        /// <param name="[in]">
        /// avc a pointer to an arbitrary struct of which the first field is
        /// a pointer to an AVClass struct
        /// </param>
        /// <param name="[in]">
        /// feature string containing the name of the missing feature
        /// </param>
        /// <param name="[in]">
        /// want_sample indicates if samples are wanted which exhibit this feature.
        /// If want_sample is non-zero, additional verbage will be added to the log
        /// message which tells the user how to report samples to the development
        /// mailing list.
        /// @deprecated Use avpriv_report_missing_feature() instead.
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_log_missing_feature")]
        public static extern void av_log_missing_feature(void* avc, string feature, int want_sample);

        /// <summary>
        /// Log a generic warning message asking for a sample. This function is
        /// intended to be used internally by FFmpeg (libavcodec, libavformat,
        /// etc.)
        /// only, and would normally not be used by applications.
        /// </summary>
        /// <param name="[in]">
        /// avc a pointer to an arbitrary struct of which the first field is
        /// a pointer to an AVClass struct
        /// </param>
        /// <param name="[in]">
        /// msg string containing an optional message, or NULL if no message
        /// @deprecated Use avpriv_request_sample() instead.
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_log_ask_for_sample")]
        public static extern void av_log_ask_for_sample(void* avc, string msg);

        /// <summary>
        /// Register the hardware accelerator hwaccel.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_register_hwaccel")]
        public static extern void av_register_hwaccel(libavcodec.AVHWAccel* hwaccel);

        /// <summary>
        /// If hwaccel is NULL, returns the first registered hardware accelerator,
        /// if hwaccel is non-NULL, returns the next registered hardware
        /// accelerator
        /// after hwaccel, or NULL if hwaccel is the last one.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwaccel_next")]
        public static extern libavcodec.AVHWAccel* av_hwaccel_next(libavcodec.AVHWAccel* hwaccel);

        /// <summary>
        /// Register a user provided lock manager supporting the operations
        /// specified by AVLockOp. mutex points to a (void *) where the
        /// lockmgr should store/get a pointer to a user allocated mutex. It's
        /// NULL upon AV_LOCK_CREATE and != NULL for all other ops.
        /// </summary>
        /// <param name="cb">
        /// User defined callback. Note: FFmpeg may invoke calls to this
        /// callback during the call to av_lockmgr_register().
        /// Thus, the application must be prepared to handle that.
        /// If cb is set to NULL the lockmgr will be unregistered.
        /// Also note that during unregistration the previously registered
        /// lockmgr callback may also be invoked.
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_lockmgr_register")]
        public static extern int av_lockmgr_register(global::System.IntPtr cb);

        /// <summary>
        /// Get the type of the given codec.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_get_type")]
        public static extern libavutil.AVMediaType avcodec_get_type(libavcodec.AVCodecID codec_id);

        /// <summary>
        /// Get the name of a codec.
        /// </summary>
        /// <returns>
        /// a static string identifying the codec; never NULL
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_get_name")]
        public static extern sbyte* avcodec_get_name(libavcodec.AVCodecID id);

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// a positive value if s is open (i.e. avcodec_open2() was called on it
        /// with no corresponding avcodec_close()), 0 otherwise.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_is_open")]
        public static extern int avcodec_is_open(libavcodec.AVCodecContext* s);

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// a non-zero number if codec is an encoder, zero otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_is_encoder")]
        public static extern int av_codec_is_encoder(libavcodec.AVCodec* codec);

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// a non-zero number if codec is a decoder, zero otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_is_decoder")]
        public static extern int av_codec_is_decoder(libavcodec.AVCodec* codec);

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// descriptor for given codec ID or NULL if no descriptor exists.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_descriptor_get")]
        public static extern libavcodec.AVCodecDescriptor* avcodec_descriptor_get(libavcodec.AVCodecID id);

        /// <summary>
        /// Iterate over all codec descriptors known to libavcodec.
        /// </summary>
        /// <param name="prev">
        /// previous descriptor. NULL to get the first descriptor.
        /// </param>
        /// <returns>
        /// next descriptor or NULL after the last descriptor
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_descriptor_next")]
        public static extern libavcodec.AVCodecDescriptor* avcodec_descriptor_next(libavcodec.AVCodecDescriptor* prev);

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// codec descriptor with the given name or NULL if no such descriptor
        /// exists.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVCODEC_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avcodec_descriptor_get_by_name")]
        public static extern libavcodec.AVCodecDescriptor* avcodec_descriptor_get_by_name(string name);
    }
}
