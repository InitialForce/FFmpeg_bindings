//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using FFmpeg;

namespace FFmpeg
{
    /// <summary>
    /// A function executing multiple jobs, possibly in parallel.
    /// </summary>
    /// <param name="ctx">
    /// the filter context to which the jobs belong
    /// </param>
    /// <param name="func">
    /// the function to be called multiple times
    /// </param>
    /// <param name="arg">
    /// the argument to be passed to func
    /// </param>
    /// <param name="ret">
    /// a nb_jobs-sized array to be filled with return values from each
    /// invocation of func
    /// </param>
    /// <param name="nb_jobs">
    /// the number of jobs to execute
    /// </param>
    /// <returns>
    /// 0 on success, a negative AVERROR on error
    /// </returns>
    /// <summary>
    /// A function pointer passed to the @ref AVFilterGraph.execute
    /// callback to be
    /// executed multiple times, possibly in parallel.
    /// </summary>
    /// <param name="ctx">
    /// the filter context the job belongs to
    /// </param>
    /// <param name="arg">
    /// an opaque parameter passed through from @ref
    /// AVFilterGraph.execute
    /// </param>
    /// <param name="jobnr">
    /// the index of the job being executed
    /// </param>
    /// <param name="nb_jobs">
    /// the total number of jobs
    /// </param>
    /// <returns>
    /// 0 on success, a negative AVERROR on error
    /// </returns>
    public unsafe static partial class libavfilter
    {
        public const sbyte AV_PERM_READ = 1;

        public const sbyte AV_PERM_WRITE = 2;

        public const sbyte AV_PERM_PRESERVE = 4;

        public const sbyte AV_PERM_REUSE = 8;

        public const sbyte AV_PERM_REUSE2 = 10;

        public const sbyte AV_PERM_NEG_LINESIZES = 20;

        public const sbyte AV_PERM_ALIGN = 40;

        public const sbyte AVFILTER_ALIGN = 16;

        public const sbyte AVFILTER_CMD_FLAG_ONE = 1;

        public const sbyte AVFILTER_CMD_FLAG_FAST = 2;

        public enum AVFILTER_AUTO_CONVERT
        {
            /// <summary>all automatic conversions enabled</summary>
            AVFILTER_AUTO_CONVERT_ALL = 0,
            /// <summary>all automatic conversions disabled</summary>
            AVFILTER_AUTO_CONVERT_NONE = -1
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterChannelLayouts
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterPool
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterCommand
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterFormats
        {
        }

        /// <summary>
        /// A reference-counted buffer data type used by the filter system. Filters
        /// should not store pointers to this structure directly, but instead use
        /// the
        /// AVFilterBufferRef structure below.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterBuffer
        {
            /// <summary>
            /// buffer data for each plane/channel
            /// </summary>
            public libavutil.ArrayWrapper_BytePtr8 data;

            /// <summary>
            /// pointers to the data planes/channels.
            /// 
            /// For video, this should simply point to data[].
            /// 
            /// For planar audio, each channel has a separate data pointer, and
            /// linesize[0] contains the size of each channel buffer.
            /// For packed audio, there is just one data pointer, and linesize[0]
            /// contains the total size of the buffer for all channels.
            /// 
            /// Note: Both data and extended_data will always be set, but for planar
            /// audio with more channels that can fit in data, extended_data must be
            /// used
            /// in order to access all channels.
            /// </summary>
            public byte** extended_data;

            /// <summary>
            /// number of bytes per line
            /// </summary>
            public fixed int linesize[8];

            /// <summary>
            /// private data to be used by a custom free function
            /// </summary>
            public void* priv;

            /// <summary>
            /// A pointer to the function to deallocate this buffer if the default
            /// function is not sufficient. This could, for example, add the memory
            /// back into a memory pool to be reused later without the overhead of
            /// reallocating it from scratch.
            /// </summary>
            public global::System.IntPtr free;

            /// <summary>
            /// media format
            /// </summary>
            public int format;

            /// <summary>
            /// width and height of the allocated buffer
            /// </summary>
            public int w;

            /// <summary>
            /// width and height of the allocated buffer
            /// </summary>
            public int h;

            /// <summary>
            /// number of references to this buffer
            /// </summary>
            public uint refcount;
        }

        /// <summary>
        /// Audio specific properties in a reference to an AVFilterBuffer. Since
        /// AVFilterBufferRef is common to different media formats, audio specific
        /// per reference properties must be separated out.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterBufferRefAudioProps
        {
            /// <summary>
            /// channel layout of audio buffer
            /// </summary>
            public ulong channel_layout;

            /// <summary>
            /// number of audio samples per channel
            /// </summary>
            public int nb_samples;

            /// <summary>
            /// audio buffer sample rate
            /// </summary>
            public int sample_rate;

            /// <summary>
            /// number of channels (do not access directly)
            /// </summary>
            public int channels;
        }

        /// <summary>
        /// Video specific properties in a reference to an AVFilterBuffer. Since
        /// AVFilterBufferRef is common to different media formats, video specific
        /// per reference properties must be separated out.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterBufferRefVideoProps
        {
            /// <summary>
            /// image width
            /// </summary>
            public int w;

            /// <summary>
            /// image height
            /// </summary>
            public int h;

            /// <summary>
            /// sample aspect ratio
            /// </summary>
            public libavutil.AVRational sample_aspect_ratio;

            /// <summary>
            /// is frame interlaced
            /// </summary>
            public int interlaced;

            /// <summary>
            /// field order
            /// </summary>
            public int top_field_first;

            /// <summary>
            /// picture type of the frame
            /// </summary>
            public libavutil.AVPictureType pict_type;

            /// <summary>
            /// 1 -> keyframe, 0-> not
            /// </summary>
            public int key_frame;

            /// <summary>
            /// qp_table stride
            /// </summary>
            public int qp_table_linesize;

            /// <summary>
            /// qp_table size
            /// </summary>
            public int qp_table_size;

            /// <summary>
            /// array of Quantization Parameters
            /// </summary>
            public sbyte* qp_table;
        }

        /// <summary>
        /// A reference to an AVFilterBuffer. Since filters can manipulate the
        /// origin of
        /// a buffer to, for example, crop image without any memcpy, the buffer
        /// origin
        /// and dimensions are per-reference properties. Linesize is also useful
        /// for
        /// image flipping, frame to field filters, etc, and so is also
        /// per-reference.
        /// 
        /// TODO: add anything necessary for frame reordering
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterBufferRef
        {
            /// <summary>
            /// the buffer that this is a reference to
            /// </summary>
            public libavfilter.AVFilterBuffer* buf;

            /// <summary>
            /// picture/audio data for each plane
            /// </summary>
            public libavutil.ArrayWrapper_BytePtr8 data;

            /// <summary>
            /// pointers to the data planes/channels.
            /// 
            /// For video, this should simply point to data[].
            /// 
            /// For planar audio, each channel has a separate data pointer, and
            /// linesize[0] contains the size of each channel buffer.
            /// For packed audio, there is just one data pointer, and linesize[0]
            /// contains the total size of the buffer for all channels.
            /// 
            /// Note: Both data and extended_data will always be set, but for planar
            /// audio with more channels that can fit in data, extended_data must be
            /// used
            /// in order to access all channels.
            /// </summary>
            public byte** extended_data;

            /// <summary>
            /// number of bytes per line
            /// </summary>
            public fixed int linesize[8];

            /// <summary>
            /// video buffer specific properties
            /// </summary>
            public libavfilter.AVFilterBufferRefVideoProps* video;

            /// <summary>
            /// audio buffer specific properties
            /// </summary>
            public libavfilter.AVFilterBufferRefAudioProps* audio;

            /// <summary>
            /// presentation timestamp. The time unit may change during
            /// filtering, as it is specified in the link and the filter code
            /// may need to rescale the PTS accordingly.
            /// </summary>
            public long pts;

            /// <summary>
            /// byte position in stream, -1 if unknown
            /// </summary>
            public long pos;

            /// <summary>
            /// media format
            /// </summary>
            public int format;

            /// <summary>
            /// permissions, see the AV_PERM_* flags
            /// </summary>
            public int perms;

            /// <summary>
            /// media type of buffer data
            /// </summary>
            public libavutil.AVMediaType type;

            /// <summary>
            /// dictionary containing metadata key=value tags
            /// </summary>
            public libavutil.AVDictionary* metadata;
        }

        /// <summary>
        /// A filter pad used for either input or output.
        /// 
        /// See doc/filter_design.txt for details on how to implement the methods.
        /// 
        /// @warning this struct might be removed from public API.
        /// users should call avfilter_pad_get_name() and avfilter_pad_get_type()
        /// to access the name and type fields; there should be no need to access
        /// any other fields from outside of libavfilter.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterPad
        {
            /// <summary>
            /// Pad name. The name is unique among inputs and among outputs, but an
            /// input may have the same name as an output. This may be NULL if this
            /// pad has no need to ever be referenced by name.
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// AVFilterPad type.
            /// </summary>
            public libavutil.AVMediaType type;

            /// <summary>
            /// Input pads:
            /// Minimum required permissions on incoming buffers. Any buffer with
            /// insufficient permissions will be automatically copied by the filter
            /// system to a new buffer which provides the needed access permissions.
            /// 
            /// Output pads:
            /// Guaranteed permissions on outgoing buffers. Any buffer pushed on the
            /// link must have at least these permissions; this fact is checked by
            /// asserts. It can be used to optimize buffer allocation.
            /// </summary>
            [System.ObsoleteAttribute()]
            public int min_perms;

            /// <summary>
            /// Input pads:
            /// Permissions which are not accepted on incoming buffers. Any buffer
            /// which has any of these permissions set will be automatically copied
            /// by the filter system to a new buffer which does not have those
            /// permissions. This can be used to easily disallow buffers with
            /// AV_PERM_REUSE.
            /// 
            /// Output pads:
            /// Permissions which are automatically removed on outgoing buffers. It
            /// can be used to optimize buffer allocation.
            /// </summary>
            [System.ObsoleteAttribute()]
            public int rej_perms;

            public global::System.IntPtr start_frame;

            /// <summary>
            /// Callback function to get a video buffer. If NULL, the filter system
            /// will
            /// use ff_default_get_video_buffer().
            /// 
            /// Input video pads only.
            /// </summary>
            public global::System.IntPtr get_video_buffer;

            /// <summary>
            /// Callback function to get an audio buffer. If NULL, the filter system
            /// will
            /// use ff_default_get_audio_buffer().
            /// 
            /// Input audio pads only.
            /// </summary>
            public global::System.IntPtr get_audio_buffer;

            public global::System.IntPtr end_frame;

            public global::System.IntPtr draw_slice;

            /// <summary>
            /// Filtering callback. This is where a filter receives a frame with
            /// audio/video data and should do its processing.
            /// 
            /// Input pads only.
            /// </summary>
            /// <returns>
            /// >= 0 on success, a negative AVERROR on error. This function
            /// must ensure that frame is properly unreferenced on error if it
            /// hasn't been passed on to another filter.
            /// </returns>
            public global::System.IntPtr filter_frame;

            /// <summary>
            /// Frame poll callback. This returns the number of immediately available
            /// samples. It should return a positive value if the next request_frame()
            /// is guaranteed to return one frame (with no delay).
            /// 
            /// Defaults to just calling the source poll_frame() method.
            /// 
            /// Output pads only.
            /// </summary>
            public global::System.IntPtr poll_frame;

            /// <summary>
            /// Frame request callback. A call to this should result in at least one
            /// frame being output over the given link. This should return zero on
            /// success, and another value on error.
            /// See ff_request_frame() for the error codes with a specific
            /// meaning.
            /// 
            /// Output pads only.
            /// </summary>
            public global::System.IntPtr request_frame;

            /// <summary>
            /// Link configuration callback.
            /// 
            /// For output pads, this should set the following link properties:
            /// video: width, height, sample_aspect_ratio, time_base
            /// audio: sample_rate.
            /// 
            /// This should NOT set properties such as format, channel_layout, etc
            /// which
            /// are negotiated between filters by the filter system using the
            /// query_formats() callback before this function is called.
            /// 
            /// For input pads, this should check the properties of the link, and
            /// update
            /// the filter's internal state as necessary.
            /// 
            /// For both input and output pads, this should return zero on success,
            /// and another value on error.
            /// </summary>
            public global::System.IntPtr config_props;

            /// <summary>
            /// The filter expects a fifo to be inserted on its input link,
            /// typically because it has a delay.
            /// 
            /// input pads only.
            /// </summary>
            public int needs_fifo;

            /// <summary>
            /// The filter expects writable frames from its input link,
            /// duplicating data buffers if needed.
            /// 
            /// input pads only.
            /// </summary>
            public int needs_writable;
        }

        /// <summary>
        /// Filter definition. This defines the pads a filter contains, and all the
        /// callback functions used to interact with the filter.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilter
        {
            /// <summary>
            /// Filter name. Must be non-NULL and unique among filters.
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// A description of the filter. May be NULL.
            /// 
            /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
            /// </summary>
            public sbyte* description;

            /// <summary>
            /// List of inputs, terminated by a zeroed element.
            /// 
            /// NULL if there are no (static) inputs. Instances of filters with
            /// AVFILTER_FLAG_DYNAMIC_INPUTS set may have more inputs than present in
            /// this list.
            /// </summary>
            public libavfilter.AVFilterPad* inputs;

            /// <summary>
            /// List of outputs, terminated by a zeroed element.
            /// 
            /// NULL if there are no (static) outputs. Instances of filters with
            /// AVFILTER_FLAG_DYNAMIC_OUTPUTS set may have more outputs than present in
            /// this list.
            /// </summary>
            public libavfilter.AVFilterPad* outputs;

            /// <summary>
            /// A class for the private data, used to declare filter private AVOptions.
            /// This field is NULL for filters that do not declare any options.
            /// 
            /// If this field is non-NULL, the first member of the filter private data
            /// must be a pointer to AVClass, which will be set by libavfilter generic
            /// code to this class.
            /// </summary>
            public libavutil.AVClass* priv_class;

            /// <summary>
            /// A combination of AVFILTER_FLAG_
            /// </summary>
            public int flags;

            /// <summary>
            /// Filter initialization function.
            /// 
            /// This callback will be called only once during the filter lifetime,
            /// after
            /// all the options have been set, but before links between filters are
            /// established and format negotiation is done.
            /// 
            /// Basic filter initialization should be done here. Filters with dynamic
            /// inputs and/or outputs should create those inputs/outputs here based on
            /// provided options. No more changes to this filter's inputs/outputs can
            /// be
            /// done after this callback.
            /// 
            /// This callback must not assume that the filter links exist or frame
            /// parameters are known.
            /// 
            /// @ref AVFilter.uninit "uninit" is guaranteed to be called even if
            /// initialization fails, so this callback does not have to clean up on
            /// failure.
            /// </summary>
            /// <returns>
            /// 0 on success, a negative AVERROR on failure
            /// </returns>
            public global::System.IntPtr init;

            /// <summary>
            /// Should be set instead of @ref AVFilter.init "init" by the filters that
            /// want to pass a dictionary of AVOptions to nested contexts that are
            /// allocated during init.
            /// 
            /// On return, the options dict should be freed and replaced with one that
            /// contains all the options which could not be processed by this filter
            /// (or
            /// with NULL if all the options were processed).
            /// 
            /// Otherwise the semantics is the same as for @ref AVFilter.init "init".
            /// </summary>
            public global::System.IntPtr init_dict;

            /// <summary>
            /// Filter uninitialization function.
            /// 
            /// Called only once right before the filter is freed. Should deallocate
            /// any
            /// memory held by the filter, release any buffer references, etc. It does
            /// not need to deallocate the AVFilterContext.priv memory itself.
            /// 
            /// This callback may be called even if @ref AVFilter.init "init" was not
            /// called or failed, so it must be prepared to handle such a situation.
            /// </summary>
            public global::System.IntPtr uninit;

            /// <summary>
            /// Query formats supported by the filter on its inputs and outputs.
            /// 
            /// This callback is called after the filter is initialized (so the inputs
            /// and outputs are fixed), shortly before the format negotiation. This
            /// callback may be called more than once.
            /// 
            /// This callback must set AVFilterLink.out_formats on every input link and
            /// AVFilterLink.in_formats on every output link to a list of pixel/sample
            /// formats that the filter supports on that link. For audio links, this
            /// filter must also set @ref AVFilterLink.in_samplerates "in_samplerates"
            /// @ref AVFilterLink.out_samplerates "out_samplerates" and
            /// @ref AVFilterLink.in_channel_layouts "in_channel_layouts"
            /// @ref AVFilterLink.out_channel_layouts "out_channel_layouts"
            /// analogously.
            /// 
            /// This callback may be NULL for filters with one input, in which case
            /// libavfilter assumes that it supports all input formats and preserves
            /// them on output.
            /// </summary>
            /// <returns>
            /// zero on success, a negative value corresponding to an
            /// AVERROR code otherwise
            /// </returns>
            public global::System.IntPtr query_formats;

            /// <summary>
            /// size of private data to allocate for the filter
            /// </summary>
            public int priv_size;

            /// <summary>
            /// Used by the filter registration system. Must not be touched by any
            /// other
            /// code.
            /// </summary>
            public libavfilter.AVFilter* next;

            /// <summary>
            /// Make the filter instance process a command.
            /// </summary>
            /// <param name="cmd">
            /// the command to process, for handling simplicity all commands must be
            /// alphanumeric only
            /// </param>
            /// <param name="arg">
            /// the argument for the command
            /// </param>
            /// <param name="res">
            /// a buffer with size res_size where the filter(s) can return a response.
            /// This must not change when the command is not supported.
            /// </param>
            /// <param name="flags">
            /// if AVFILTER_CMD_FLAG_FAST is set and the command would be
            /// time consuming then a filter should treat it like an unsupported
            /// command
            /// </param>
            /// <returns>
            /// s >=0 on success otherwise an error code.
            /// AVERROR(ENOSYS) on unsupported commands
            /// </returns>
            public global::System.IntPtr process_command;

            /// <summary>
            /// Filter initialization function, alternative to the init()
            /// callback. Args contains the user-supplied parameters, opaque is
            /// used for providing binary data.
            /// </summary>
            public global::System.IntPtr init_opaque;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterInternal
        {
        }

        /// <summary>
        /// An instance of a filter
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterContext
        {
            /// <summary>
            /// needed for av_log() and filters common options
            /// </summary>
            public libavutil.AVClass* av_class;

            /// <summary>
            /// the AVFilter of which this is an instance
            /// </summary>
            public libavfilter.AVFilter* filter;

            /// <summary>
            /// name of this filter instance
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// array of input pads
            /// </summary>
            public libavfilter.AVFilterPad* input_pads;

            /// <summary>
            /// array of pointers to input links
            /// </summary>
            public libavfilter.AVFilterLink** inputs;

            [System.ObsoleteAttribute()]
            public uint input_count;

            /// <summary>
            /// number of input pads
            /// </summary>
            public uint nb_inputs;

            /// <summary>
            /// array of output pads
            /// </summary>
            public libavfilter.AVFilterPad* output_pads;

            /// <summary>
            /// array of pointers to output links
            /// </summary>
            public libavfilter.AVFilterLink** outputs;

            [System.ObsoleteAttribute()]
            public uint output_count;

            /// <summary>
            /// number of output pads
            /// </summary>
            public uint nb_outputs;

            /// <summary>
            /// private data for use by the filter
            /// </summary>
            public void* priv;

            /// <summary>
            /// filtergraph this filter belongs to
            /// </summary>
            public libavfilter.AVFilterGraph* graph;

            /// <summary>
            /// Type of multithreading being allowed/used. A combination of
            /// AVFILTER_THREAD_* flags.
            /// 
            /// May be set by the caller before initializing the filter to forbid some
            /// or all kinds of multithreading for this filter. The default is allowing
            /// everything.
            /// 
            /// When the filter is initialized, this field is combined using bit AND
            /// with
            /// AVFilterGraph.thread_type to get the final mask used for determining
            /// allowed threading types. I.e. a threading type needs to be set in both
            /// to be allowed.
            /// 
            /// After the filter is initialzed, libavfilter sets this field to the
            /// threading type that is actually used (0 for no multithreading).
            /// </summary>
            public int thread_type;

            /// <summary>
            /// An opaque struct for libavfilter internal use.
            /// </summary>
            public libavfilter.AVFilterInternal* @internal;

            public libavfilter.AVFilterCommand* command_queue;

            /// <summary>
            /// enable expression string
            /// </summary>
            public sbyte* enable_str;

            /// <summary>
            /// parsed expression (AVExpr*)
            /// </summary>
            public void* enable;

            /// <summary>
            /// variable values for the enable expression
            /// </summary>
            public double* var_values;

            /// <summary>
            /// the enabled state from the last expression evaluation
            /// </summary>
            public int is_disabled;
        }

        /// <summary>
        /// A link between two filters. This contains pointers to the source and
        /// destination filters between which this link exists, and the indexes of
        /// the pads involved. In addition, this link also contains the parameters
        /// which have been negotiated and agreed upon between the filter, such as
        /// image dimensions, format, etc.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterLink
        {
            /// <summary>
            /// source filter
            /// </summary>
            public libavfilter.AVFilterContext* src;

            /// <summary>
            /// output pad on the source filter
            /// </summary>
            public libavfilter.AVFilterPad* srcpad;

            /// <summary>
            /// dest filter
            /// </summary>
            public libavfilter.AVFilterContext* dst;

            /// <summary>
            /// input pad on the dest filter
            /// </summary>
            public libavfilter.AVFilterPad* dstpad;

            /// <summary>
            /// filter media type
            /// </summary>
            public libavutil.AVMediaType type;

            /// <summary>
            /// agreed upon image width
            /// </summary>
            public int w;

            /// <summary>
            /// agreed upon image height
            /// </summary>
            public int h;

            /// <summary>
            /// agreed upon sample aspect ratio
            /// </summary>
            public libavutil.AVRational sample_aspect_ratio;

            /// <summary>
            /// channel layout of current buffer (see libavutil/channel_layout.h)
            /// </summary>
            public ulong channel_layout;

            /// <summary>
            /// samples per second
            /// </summary>
            public int sample_rate;

            /// <summary>
            /// agreed upon media format
            /// </summary>
            public int format;

            /// <summary>
            /// Define the time base used by the PTS of the frames/samples
            /// which will pass through this link.
            /// During the configuration stage, each filter is supposed to
            /// change only the output timebase, while the timebase of the
            /// input link is assumed to be an unchangeable property.
            /// </summary>
            public libavutil.AVRational time_base;

            /// <summary>
            /// 
            /// All fields below this line are not part of the public API. They
            /// may not be used outside of libavfilter and can be changed and
            /// removed at will.
            /// New public fields should be added right above.
            /// 
            /// 
            /// 
            /// Lists of formats and channel layouts supported by the input and output
            /// filters respectively. These lists are used for negotiating the format
            /// to actually be used, which will be loaded into the format and
            /// channel_layout members, above, when chosen.
            /// </summary>
            public libavfilter.AVFilterFormats* in_formats;

            public libavfilter.AVFilterFormats* out_formats;

            /// <summary>
            /// Lists of channel layouts and sample rates used for automatic
            /// negotiation.
            /// </summary>
            public libavfilter.AVFilterFormats* in_samplerates;

            public libavfilter.AVFilterFormats* out_samplerates;

            public libavfilter.AVFilterChannelLayouts* in_channel_layouts;

            public libavfilter.AVFilterChannelLayouts* out_channel_layouts;

            /// <summary>
            /// Audio only, the destination filter sets this to a non-zero value to
            /// request that buffers with the given number of samples should be sent to
            /// it. AVFilterPad.needs_fifo must also be set on the corresponding input
            /// pad.
            /// Last buffer before EOF will be padded with silence.
            /// </summary>
            public int request_samples;

            public libavfilter.AVFilterLink.AVLINK init_state;

            public libavfilter.AVFilterPool* pool;

            /// <summary>
            /// Graph the filter belongs to.
            /// </summary>
            public libavfilter.AVFilterGraph* graph;

            /// <summary>
            /// Current timestamp of the link, as defined by the most recent
            /// frame(s), in AV_TIME_BASE units.
            /// </summary>
            public long current_pts;

            /// <summary>
            /// Index in the age array.
            /// </summary>
            public int age_index;

            /// <summary>
            /// Frame rate of the stream on the link, or 1/0 if unknown;
            /// if left to 0/0, will be automatically be copied from the first input
            /// of the source filter if it exists.
            /// 
            /// Sources should set it to the best estimation of the real frame rate.
            /// Filters should update it if necessary depending on their function.
            /// Sinks can use it to set a default output frame rate.
            /// It is similar to the r_frame_rate field in AVStream.
            /// </summary>
            public libavutil.AVRational frame_rate;

            /// <summary>
            /// Buffer partially filled with samples to achieve a fixed/minimum size.
            /// </summary>
            public libavutil.AVFrame* partial_buf;

            /// <summary>
            /// Size of the partial buffer to allocate.
            /// Must be between min_samples and max_samples.
            /// </summary>
            public int partial_buf_size;

            /// <summary>
            /// Minimum number of samples to filter at once. If filter_frame() is
            /// called with fewer samples, it will accumulate them in partial_buf.
            /// This field and the related ones must not be changed after filtering
            /// has started.
            /// If 0, all related fields are ignored.
            /// </summary>
            public int min_samples;

            /// <summary>
            /// Maximum number of samples to filter at once. If filter_frame() is
            /// called with more samples, it will split them.
            /// </summary>
            public int max_samples;

            /// <summary>
            /// The buffer reference currently being received across the link by the
            /// destination filter. This is used internally by the filter system to
            /// allow automatic copying of buffers which do not have sufficient
            /// permissions for the destination. This should not be accessed directly
            /// by the filters.
            /// </summary>
            public libavfilter.AVFilterBufferRef* cur_buf_copy;

            /// <summary>
            /// True if the link is closed.
            /// If set, all attemps of start_frame, filter_frame or request_frame
            /// will fail with AVERROR_EOF, and if necessary the reference will be
            /// destroyed.
            /// If request_frame returns AVERROR_EOF, this flag is set on the
            /// corresponding link.
            /// It can be set also be set by either the source or the destination
            /// filter.
            /// </summary>
            public int closed;

            /// <summary>
            /// Number of channels.
            /// </summary>
            public int channels;

            /// <summary>
            /// True if a frame is being requested on the link.
            /// Used internally by the framework.
            /// </summary>
            public uint frame_requested;

            /// <summary>
            /// Link processing flags.
            /// </summary>
            public uint flags;

            /// <summary>
            /// Number of past frames sent through the link.
            /// </summary>
            public long frame_count;

            /// <summary>
            /// stage of the initialization of the link properties (dimensions, etc)
            /// </summary>
            public enum AVLINK
            {
                /// <summary>not started</summary>
                AVLINK_UNINIT = 0,
                /// <summary>started, but incomplete</summary>
                AVLINK_STARTINIT = 1,
                /// <summary>complete</summary>
                AVLINK_INIT = 2
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterGraphInternal
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterGraph
        {
            public libavutil.AVClass* av_class;

            [System.ObsoleteAttribute()]
            public uint filter_count_unused;

            public libavfilter.AVFilterContext** filters;

            /// <summary>
            /// sws options to use for the auto-inserted scale filters
            /// </summary>
            public sbyte* scale_sws_opts;

            /// <summary>
            /// libavresample options to use for the auto-inserted resample filters
            /// </summary>
            public sbyte* resample_lavr_opts;

            public uint nb_filters;

            /// <summary>
            /// Type of multithreading allowed for filters in this graph. A combination
            /// of AVFILTER_THREAD_* flags.
            /// 
            /// May be set by the caller at any point, the setting will apply to all
            /// filters initialized after that. The default is allowing everything.
            /// 
            /// When a filter in this graph is initialized, this field is combined
            /// using
            /// bit AND with AVFilterContext.thread_type to get the final mask used for
            /// determining allowed threading types. I.e. a threading type needs to be
            /// set in both to be allowed.
            /// </summary>
            public int thread_type;

            /// <summary>
            /// Maximum number of threads used by filters in this graph. May be set by
            /// the caller before adding any filters to the filtergraph. Zero (the
            /// default) means that the number of threads is determined automatically.
            /// </summary>
            public int nb_threads;

            /// <summary>
            /// Opaque object for libavfilter internal use.
            /// </summary>
            public libavfilter.AVFilterGraphInternal* @internal;

            /// <summary>
            /// Opaque user data. May be set by the caller to an arbitrary value, e.g.
            /// to
            /// be used from callbacks like @ref AVFilterGraph.execute.
            /// Libavfilter will not touch this field in any way.
            /// </summary>
            public void* opaque;

            /// <summary>
            /// This callback may be set by the caller immediately after allocating the
            /// graph and before adding any filters to it, to provide a custom
            /// multithreading implementation.
            /// 
            /// If set, filters with slice threading capability will call this callback
            /// to execute multiple jobs in parallel.
            /// 
            /// If this field is left unset, libavfilter will use its internal
            /// implementation, which may or may not be multithreaded depending on the
            /// platform and build options.
            /// </summary>
            public global::System.IntPtr execute;

            /// <summary>
            /// swr options to use for the auto-inserted aresample filters, Access ONLY
            /// through AVOptions
            /// </summary>
            public sbyte* aresample_swr_opts;

            /// <summary>
            /// Private fields
            /// 
            /// The following fields are for internal use only.
            /// Their type, offset, number and semantic can change without notice.
            /// </summary>
            public libavfilter.AVFilterLink** sink_links;

            public int sink_links_count;

            public uint disable_auto_convert;
        }

        /// <summary>
        /// A linked-list of the inputs/outputs of the filter chain.
        /// 
        /// This is mainly useful for avfilter_graph_parse() /
        /// avfilter_graph_parse2(),
        /// where it is used to communicate open (unlinked) inputs and outputs from
        /// and
        /// to the caller.
        /// This struct specifies, per each not connected pad contained in the
        /// graph, the
        /// filter context and the pad index required for establishing a link.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterInOut
        {
            /// <summary>
            /// unique name for this input/output in the list
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// filter context associated to this input/output
            /// </summary>
            public libavfilter.AVFilterContext* filter_ctx;

            /// <summary>
            /// index of the filt_ctx pad to use for linking
            /// </summary>
            public int pad_idx;

            /// <summary>
            /// next input/input in the list, NULL if this is the last
            /// </summary>
            public libavfilter.AVFilterInOut* next;
        }

        /// <summary>
        /// Return the LIBAVFILTER_VERSION_INT constant.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_version")]
        public static extern uint avfilter_version();

        /// <summary>
        /// Return the libavfilter build-time configuration.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_configuration")]
        public static extern sbyte* avfilter_configuration();

        /// <summary>
        /// Return the libavfilter license.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_license")]
        public static extern sbyte* avfilter_license();

        /// <summary>
        /// Copy properties of src to dst, without copying the actual data
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_copy_buffer_ref_props")]
        public static extern void avfilter_copy_buffer_ref_props(libavfilter.AVFilterBufferRef* dst, libavfilter.AVFilterBufferRef* src);

        /// <summary>
        /// Add a new reference to a buffer.
        /// </summary>
        /// <param name="ref">
        /// an existing reference to the buffer
        /// </param>
        /// <param name="pmask">
        /// a bitmask containing the allowable permissions in the new
        /// reference
        /// </param>
        /// <returns>
        /// a new reference to the buffer with the same properties as the
        /// old, excluding any permissions denied by pmask
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_ref_buffer")]
        public static extern libavfilter.AVFilterBufferRef* avfilter_ref_buffer(libavfilter.AVFilterBufferRef* _ref, int pmask);

        /// <summary>
        /// Remove a reference to a buffer. If this is the last reference to the
        /// buffer, the buffer itself is also automatically freed.
        /// </summary>
        /// <param name="ref">
        /// reference to the buffer, may be NULL
        /// </param>
        /// <remark>
        /// it is recommended to use avfilter_unref_bufferp() instead of this
        /// function
        /// </remark>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_unref_buffer")]
        public static extern void avfilter_unref_buffer(libavfilter.AVFilterBufferRef* _ref);

        /// <summary>
        /// Remove a reference to a buffer and set the pointer to NULL.
        /// If this is the last reference to the buffer, the buffer itself
        /// is also automatically freed.
        /// </summary>
        /// <param name="ref">
        /// pointer to the buffer reference
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_unref_bufferp")]
        public static extern void avfilter_unref_bufferp(libavfilter.AVFilterBufferRef** _ref);

        /// <summary>
        /// Remove a reference to a buffer and set the pointer to NULL.
        /// If this is the last reference to the buffer, the buffer itself
        /// is also automatically freed.
        /// </summary>
        /// <param name="ref">
        /// pointer to the buffer reference
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_unref_bufferp")]
        public static extern void avfilter_unref_bufferp(ref libavfilter.AVFilterBufferRef* _ref);

        /// <summary>
        /// Get the number of channels of a buffer reference.
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_ref_get_channels")]
        public static extern int avfilter_ref_get_channels(libavfilter.AVFilterBufferRef* _ref);

        /// <summary>
        /// Get the number of elements in a NULL-terminated array of AVFilterPads
        /// (e.g.
        /// AVFilter.inputs/outputs).
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_pad_count")]
        public static extern int avfilter_pad_count(libavfilter.AVFilterPad* pads);

        /// <summary>
        /// Get the name of an AVFilterPad.
        /// </summary>
        /// <param name="pads">
        /// an array of AVFilterPads
        /// </param>
        /// <param name="pad_idx">
        /// index of the pad in the array it; is the caller's
        /// responsibility to ensure the index is valid
        /// </param>
        /// <returns>
        /// name of the pad_idx'th pad in pads
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_pad_get_name")]
        public static extern sbyte* avfilter_pad_get_name(libavfilter.AVFilterPad* pads, int pad_idx);

        /// <summary>
        /// Get the type of an AVFilterPad.
        /// </summary>
        /// <param name="pads">
        /// an array of AVFilterPads
        /// </param>
        /// <param name="pad_idx">
        /// index of the pad in the array; it is the caller's
        /// responsibility to ensure the index is valid
        /// </param>
        /// <returns>
        /// type of the pad_idx'th pad in pads
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_pad_get_type")]
        public static extern libavutil.AVMediaType avfilter_pad_get_type(libavfilter.AVFilterPad* pads, int pad_idx);

        /// <summary>
        /// Link two filters together.
        /// </summary>
        /// <param name="src">
        /// the source filter
        /// </param>
        /// <param name="srcpad">
        /// index of the output pad on the source filter
        /// </param>
        /// <param name="dst">
        /// the destination filter
        /// </param>
        /// <param name="dstpad">
        /// index of the input pad on the destination filter
        /// </param>
        /// <returns>
        /// zero on success
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_link")]
        public static extern int avfilter_link(libavfilter.AVFilterContext* src, uint srcpad, libavfilter.AVFilterContext* dst, uint dstpad);

        /// <summary>
        /// Free the link in *link, and set its pointer to NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_link_free")]
        public static extern void avfilter_link_free(libavfilter.AVFilterLink** link);

        /// <summary>
        /// Free the link in *link, and set its pointer to NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_link_free")]
        public static extern void avfilter_link_free(ref libavfilter.AVFilterLink* link);

        /// <summary>
        /// Get the number of channels of a link.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_link_get_channels")]
        public static extern int avfilter_link_get_channels(libavfilter.AVFilterLink* link);

        /// <summary>
        /// Set the closed field of a link.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_link_set_closed")]
        public static extern void avfilter_link_set_closed(libavfilter.AVFilterLink* link, int closed);

        /// <summary>
        /// Negotiate the media format, dimensions, etc of all inputs to a filter.
        /// </summary>
        /// <param name="filter">
        /// the filter to negotiate the properties for its inputs
        /// </param>
        /// <returns>
        /// zero on successful negotiation
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_config_links")]
        public static extern int avfilter_config_links(libavfilter.AVFilterContext* filter);

        /// <summary>
        /// Create a buffer reference wrapped around an already allocated image
        /// buffer.
        /// </summary>
        /// <param name="data">
        /// pointers to the planes of the image to reference
        /// </param>
        /// <param name="linesize">
        /// linesizes for the planes of the image to reference
        /// </param>
        /// <param name="perms">
        /// the required access permissions
        /// </param>
        /// <param name="w">
        /// the width of the image specified by the data and linesize arrays
        /// </param>
        /// <param name="h">
        /// the height of the image specified by the data and linesize arrays
        /// </param>
        /// <param name="format">
        /// the pixel format of the image specified by the data and linesize arrays
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_get_video_buffer_ref_from_arrays")]
        public static extern libavfilter.AVFilterBufferRef* avfilter_get_video_buffer_ref_from_arrays(byte** data, int* linesize, int perms, int w, int h, libavutil.AVPixelFormat format);

        /// <summary>
        /// Create an audio buffer reference wrapped around an already
        /// allocated samples buffer.
        /// 
        /// See avfilter_get_audio_buffer_ref_from_arrays_channels() for a version
        /// that can handle unknown channel layouts.
        /// </summary>
        /// <param name="data">
        /// pointers to the samples plane buffers
        /// </param>
        /// <param name="linesize">
        /// linesize for the samples plane buffers
        /// </param>
        /// <param name="perms">
        /// the required access permissions
        /// </param>
        /// <param name="nb_samples">
        /// number of samples per channel
        /// </param>
        /// <param name="sample_fmt">
        /// the format of each sample in the buffer to allocate
        /// </param>
        /// <param name="channel_layout">
        /// the channel layout of the buffer
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_get_audio_buffer_ref_from_arrays")]
        public static extern libavfilter.AVFilterBufferRef* avfilter_get_audio_buffer_ref_from_arrays(byte** data, int linesize, int perms, int nb_samples, libavutil.AVSampleFormat sample_fmt, ulong channel_layout);

        /// <summary>
        /// Create an audio buffer reference wrapped around an already
        /// allocated samples buffer.
        /// 
        /// See avfilter_get_audio_buffer_ref_from_arrays_channels() for a version
        /// that can handle unknown channel layouts.
        /// </summary>
        /// <param name="data">
        /// pointers to the samples plane buffers
        /// </param>
        /// <param name="linesize">
        /// linesize for the samples plane buffers
        /// </param>
        /// <param name="perms">
        /// the required access permissions
        /// </param>
        /// <param name="nb_samples">
        /// number of samples per channel
        /// </param>
        /// <param name="sample_fmt">
        /// the format of each sample in the buffer to allocate
        /// </param>
        /// <param name="channel_layout">
        /// the channel layout of the buffer
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_get_audio_buffer_ref_from_arrays")]
        public static extern libavfilter.AVFilterBufferRef* avfilter_get_audio_buffer_ref_from_arrays(ref byte* data, int linesize, int perms, int nb_samples, libavutil.AVSampleFormat sample_fmt, ulong channel_layout);

        /// <summary>
        /// Create an audio buffer reference wrapped around an already
        /// allocated samples buffer.
        /// </summary>
        /// <param name="data">
        /// pointers to the samples plane buffers
        /// </param>
        /// <param name="linesize">
        /// linesize for the samples plane buffers
        /// </param>
        /// <param name="perms">
        /// the required access permissions
        /// </param>
        /// <param name="nb_samples">
        /// number of samples per channel
        /// </param>
        /// <param name="sample_fmt">
        /// the format of each sample in the buffer to allocate
        /// </param>
        /// <param name="channels">
        /// the number of channels of the buffer
        /// </param>
        /// <param name="channel_layout">
        /// the channel layout of the buffer,
        /// must be either 0 or consistent with channels
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_get_audio_buffer_ref_from_arrays_channels")]
        public static extern libavfilter.AVFilterBufferRef* avfilter_get_audio_buffer_ref_from_arrays_channels(byte** data, int linesize, int perms, int nb_samples, libavutil.AVSampleFormat sample_fmt, int channels, ulong channel_layout);

        /// <summary>
        /// Create an audio buffer reference wrapped around an already
        /// allocated samples buffer.
        /// </summary>
        /// <param name="data">
        /// pointers to the samples plane buffers
        /// </param>
        /// <param name="linesize">
        /// linesize for the samples plane buffers
        /// </param>
        /// <param name="perms">
        /// the required access permissions
        /// </param>
        /// <param name="nb_samples">
        /// number of samples per channel
        /// </param>
        /// <param name="sample_fmt">
        /// the format of each sample in the buffer to allocate
        /// </param>
        /// <param name="channels">
        /// the number of channels of the buffer
        /// </param>
        /// <param name="channel_layout">
        /// the channel layout of the buffer,
        /// must be either 0 or consistent with channels
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_get_audio_buffer_ref_from_arrays_channels")]
        public static extern libavfilter.AVFilterBufferRef* avfilter_get_audio_buffer_ref_from_arrays_channels(ref byte* data, int linesize, int perms, int nb_samples, libavutil.AVSampleFormat sample_fmt, int channels, ulong channel_layout);

        /// <summary>
        /// Make the filter instance process a command.
        /// It is recommended to use avfilter_graph_send_command().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_process_command")]
        public static extern int avfilter_process_command(libavfilter.AVFilterContext* filter, string cmd, string arg, System.Text.StringBuilder res, int res_len, int flags);

        /// <summary>
        /// Initialize the filter system. Register all builtin filters.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_register_all")]
        public static extern void avfilter_register_all();

        /// <summary>
        /// Uninitialize the filter system. Unregister all filters.
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_uninit")]
        public static extern void avfilter_uninit();

        /// <summary>
        /// Register a filter. This is only needed if you plan to use
        /// avfilter_get_by_name later to lookup the AVFilter structure by name. A
        /// filter can still by instantiated with avfilter_graph_alloc_filter even
        /// if it
        /// is not registered.
        /// </summary>
        /// <param name="filter">
        /// the filter to register
        /// </param>
        /// <returns>
        /// 0 if the registration was successful, a negative value
        /// otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_register")]
        public static extern int avfilter_register(libavfilter.AVFilter* filter);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_get_by_name")]
        public static extern libavfilter.AVFilter* avfilter_get_by_name(string name);

        /// <summary>
        /// Iterate over all registered filters.
        /// </summary>
        /// <returns>
        /// If prev is non-NULL, next registered filter after prev or NULL if
        /// prev is the last filter. If prev is NULL, return the first registered
        /// filter.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_next")]
        public static extern libavfilter.AVFilter* avfilter_next(libavfilter.AVFilter* prev);

        /// <summary>
        /// If filter is NULL, returns a pointer to the first registered filter
        /// pointer,
        /// if filter is non-NULL, returns the next pointer after filter.
        /// If the returned pointer points to NULL, the last registered filter
        /// was already reached.
        /// @deprecated use avfilter_next()
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_filter_next")]
        public static extern libavfilter.AVFilter** av_filter_next(libavfilter.AVFilter** filter);

        /// <summary>
        /// If filter is NULL, returns a pointer to the first registered filter
        /// pointer,
        /// if filter is non-NULL, returns the next pointer after filter.
        /// If the returned pointer points to NULL, the last registered filter
        /// was already reached.
        /// @deprecated use avfilter_next()
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_filter_next")]
        public static extern libavfilter.AVFilter** av_filter_next(ref libavfilter.AVFilter* filter);

        /// <summary>
        /// Create a filter instance.
        /// </summary>
        /// <param name="filter_ctx">
        /// put here a pointer to the created filter context
        /// on success, NULL on failure
        /// </param>
        /// <param name="filter">
        /// the filter to create an instance of
        /// </param>
        /// <param name="inst_name">
        /// Name to give to the new instance. Can be NULL for none.
        /// </param>
        /// <returns>
        /// >= 0 in case of success, a negative error code otherwise
        /// @deprecated use avfilter_graph_alloc_filter() instead
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_open")]
        public static extern int avfilter_open(libavfilter.AVFilterContext** filter_ctx, libavfilter.AVFilter* filter, string inst_name);

        /// <summary>
        /// Create a filter instance.
        /// </summary>
        /// <param name="filter_ctx">
        /// put here a pointer to the created filter context
        /// on success, NULL on failure
        /// </param>
        /// <param name="filter">
        /// the filter to create an instance of
        /// </param>
        /// <param name="inst_name">
        /// Name to give to the new instance. Can be NULL for none.
        /// </param>
        /// <returns>
        /// >= 0 in case of success, a negative error code otherwise
        /// @deprecated use avfilter_graph_alloc_filter() instead
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_open")]
        public static extern int avfilter_open(ref libavfilter.AVFilterContext* filter_ctx, libavfilter.AVFilter* filter, string inst_name);

        /// <summary>
        /// Initialize a filter.
        /// </summary>
        /// <param name="filter">
        /// the filter to initialize
        /// </param>
        /// <param name="args">
        /// A string of parameters to use when initializing the filter.
        /// The format and meaning of this string varies by filter.
        /// </param>
        /// <param name="opaque">
        /// Any extra non-string data needed by the filter. The meaning
        /// of this parameter varies by filter.
        /// </param>
        /// <returns>
        /// zero on success
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_init_filter")]
        public static extern int avfilter_init_filter(libavfilter.AVFilterContext* filter, string args, void* opaque);

        /// <summary>
        /// Initialize a filter with the supplied parameters.
        /// </summary>
        /// <param name="ctx">
        /// uninitialized filter context to initialize
        /// </param>
        /// <param name="args">
        /// Options to initialize the filter with. This must be a
        /// ':'-separated list of options in the 'key=value' form.
        /// May be NULL if the options have been set directly using the
        /// AVOptions API or there are no options that need to be set.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_init_str")]
        public static extern int avfilter_init_str(libavfilter.AVFilterContext* ctx, string args);

        /// <summary>
        /// Initialize a filter with the supplied dictionary of options.
        /// </summary>
        /// <param name="ctx">
        /// uninitialized filter context to initialize
        /// </param>
        /// <param name="options">
        /// An AVDictionary filled with options for this filter. On
        /// return this parameter will be destroyed and replaced with
        /// a dict containing options that were not found. This dictionary
        /// must be freed by the caller.
        /// May be NULL, then this function is equivalent to
        /// avfilter_init_str() with the second parameter set to NULL.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on failure
        /// </returns>
        /// <remark>
        /// This function and avfilter_init_str() do essentially the same thing,
        /// the difference is in manner in which the options are passed. It is up
        /// to the
        /// calling code to choose whichever is more preferable. The two functions
        /// also
        /// behave differently when some of the provided options are not declared
        /// as
        /// supported by the filter. In such a case, avfilter_init_str() will fail,
        /// but
        /// this function will leave those extra options in the options
        /// AVDictionary and
        /// continue as usual.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_init_dict")]
        public static extern int avfilter_init_dict(libavfilter.AVFilterContext* ctx, libavutil.AVDictionary** options);

        /// <summary>
        /// Initialize a filter with the supplied dictionary of options.
        /// </summary>
        /// <param name="ctx">
        /// uninitialized filter context to initialize
        /// </param>
        /// <param name="options">
        /// An AVDictionary filled with options for this filter. On
        /// return this parameter will be destroyed and replaced with
        /// a dict containing options that were not found. This dictionary
        /// must be freed by the caller.
        /// May be NULL, then this function is equivalent to
        /// avfilter_init_str() with the second parameter set to NULL.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on failure
        /// </returns>
        /// <remark>
        /// This function and avfilter_init_str() do essentially the same thing,
        /// the difference is in manner in which the options are passed. It is up
        /// to the
        /// calling code to choose whichever is more preferable. The two functions
        /// also
        /// behave differently when some of the provided options are not declared
        /// as
        /// supported by the filter. In such a case, avfilter_init_str() will fail,
        /// but
        /// this function will leave those extra options in the options
        /// AVDictionary and
        /// continue as usual.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_init_dict")]
        public static extern int avfilter_init_dict(libavfilter.AVFilterContext* ctx, ref libavutil.AVDictionary* options);

        /// <summary>
        /// Free a filter context. This will also remove the filter from its
        /// filtergraph's list of filters.
        /// </summary>
        /// <param name="filter">
        /// the filter to free
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_free")]
        public static extern void avfilter_free(libavfilter.AVFilterContext* filter);

        /// <summary>
        /// Insert a filter in the middle of an existing link.
        /// </summary>
        /// <param name="link">
        /// the link into which the filter should be inserted
        /// </param>
        /// <param name="filt">
        /// the filter to be inserted
        /// </param>
        /// <param name="filt_srcpad_idx">
        /// the input pad on the filter to connect
        /// </param>
        /// <param name="filt_dstpad_idx">
        /// the output pad on the filter to connect
        /// </param>
        /// <returns>
        /// zero on success
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_insert_filter")]
        public static extern int avfilter_insert_filter(libavfilter.AVFilterLink* link, libavfilter.AVFilterContext* filt, uint filt_srcpad_idx, uint filt_dstpad_idx);

        /// <summary>
        /// Copy the frame properties of src to dst, without copying the actual
        /// image data.
        /// </summary>
        /// <returns>
        /// 0 on success, a negative number on error.
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_copy_frame_props")]
        public static extern int avfilter_copy_frame_props(libavfilter.AVFilterBufferRef* dst, libavutil.AVFrame* src);

        /// <summary>
        /// Copy the frame properties and data pointers of src to dst, without
        /// copying
        /// the actual data.
        /// </summary>
        /// <returns>
        /// 0 on success, a negative number on error.
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_copy_buf_props")]
        public static extern int avfilter_copy_buf_props(libavutil.AVFrame* dst, libavfilter.AVFilterBufferRef* src);

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// AVClass for AVFilterContext.
        /// 
        /// @see av_opt_find().
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_get_class")]
        public static extern libavutil.AVClass* avfilter_get_class();

        /// <summary>
        /// Allocate a filter graph.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_alloc")]
        public static extern libavfilter.AVFilterGraph* avfilter_graph_alloc();

        /// <summary>
        /// Create a new filter instance in a filter graph.
        /// </summary>
        /// <param name="graph">
        /// graph in which the new filter will be used
        /// </param>
        /// <param name="filter">
        /// the filter to create an instance of
        /// </param>
        /// <param name="name">
        /// Name to give to the new instance (will be copied to
        /// AVFilterContext.name). This may be used by the caller to identify
        /// different filters, libavfilter itself assigns no semantics to
        /// this parameter. May be NULL.
        /// </param>
        /// <returns>
        /// the context of the newly created filter instance (note that it is
        /// also retrievable directly through AVFilterGraph.filters or with
        /// avfilter_graph_get_filter()) on success or NULL or failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_alloc_filter")]
        public static extern libavfilter.AVFilterContext* avfilter_graph_alloc_filter(libavfilter.AVFilterGraph* graph, libavfilter.AVFilter* filter, string name);

        /// <summary>
        /// Get a filter instance with name name from graph.
        /// </summary>
        /// <returns>
        /// the pointer to the found filter instance or NULL if it
        /// cannot be found.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_get_filter")]
        public static extern libavfilter.AVFilterContext* avfilter_graph_get_filter(libavfilter.AVFilterGraph* graph, System.Text.StringBuilder name);

        /// <summary>
        /// Add an existing filter instance to a filter graph.
        /// </summary>
        /// <param name="graphctx">
        /// the filter graph
        /// </param>
        /// <param name="filter">
        /// the filter to be added
        /// 
        /// @deprecated use avfilter_graph_alloc_filter() to allocate a filter in a
        /// filter graph
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_add_filter")]
        public static extern int avfilter_graph_add_filter(libavfilter.AVFilterGraph* graphctx, libavfilter.AVFilterContext* filter);

        /// <summary>
        /// Create and add a filter instance into an existing graph.
        /// The filter instance is created from the filter filt and inited
        /// with the parameters args and opaque.
        /// 
        /// In case of success put in *filt_ctx the pointer to the created
        /// filter instance, otherwise set *filt_ctx to NULL.
        /// </summary>
        /// <param name="name">
        /// the instance name to give to the created filter instance
        /// </param>
        /// <param name="graph_ctx">
        /// the filter graph
        /// </param>
        /// <returns>
        /// a negative AVERROR error code in case of failure, a non
        /// negative value otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_create_filter")]
        public static extern int avfilter_graph_create_filter(libavfilter.AVFilterContext** filt_ctx, libavfilter.AVFilter* filt, string name, string args, void* opaque, libavfilter.AVFilterGraph* graph_ctx);

        /// <summary>
        /// Create and add a filter instance into an existing graph.
        /// The filter instance is created from the filter filt and inited
        /// with the parameters args and opaque.
        /// 
        /// In case of success put in *filt_ctx the pointer to the created
        /// filter instance, otherwise set *filt_ctx to NULL.
        /// </summary>
        /// <param name="name">
        /// the instance name to give to the created filter instance
        /// </param>
        /// <param name="graph_ctx">
        /// the filter graph
        /// </param>
        /// <returns>
        /// a negative AVERROR error code in case of failure, a non
        /// negative value otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_create_filter")]
        public static extern int avfilter_graph_create_filter(ref libavfilter.AVFilterContext* filt_ctx, libavfilter.AVFilter* filt, string name, string args, void* opaque, libavfilter.AVFilterGraph* graph_ctx);

        /// <summary>
        /// Enable or disable automatic format conversion inside the graph.
        /// 
        /// Note that format conversion can still happen inside explicitly inserted
        /// scale and aresample filters.
        /// </summary>
        /// <param name="flags">
        /// any of the AVFILTER_AUTO_CONVERT_* constants
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_set_auto_convert")]
        public static extern void avfilter_graph_set_auto_convert(libavfilter.AVFilterGraph* graph, uint flags);

        /// <summary>
        /// Check validity and configure all the links and formats in the graph.
        /// </summary>
        /// <param name="graphctx">
        /// the filter graph
        /// </param>
        /// <param name="log_ctx">
        /// context used for logging
        /// </param>
        /// <returns>
        /// >= 0 in case of success, a negative AVERROR code otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_config")]
        public static extern int avfilter_graph_config(libavfilter.AVFilterGraph* graphctx, void* log_ctx);

        /// <summary>
        /// Free a graph, destroy its links, and set *graph to NULL.
        /// If *graph is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_free")]
        public static extern void avfilter_graph_free(libavfilter.AVFilterGraph** graph);

        /// <summary>
        /// Free a graph, destroy its links, and set *graph to NULL.
        /// If *graph is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_free")]
        public static extern void avfilter_graph_free(ref libavfilter.AVFilterGraph* graph);

        /// <summary>
        /// Allocate a single AVFilterInOut entry.
        /// Must be freed with avfilter_inout_free().
        /// </summary>
        /// <returns>
        /// allocated AVFilterInOut on success, NULL on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_inout_alloc")]
        public static extern libavfilter.AVFilterInOut* avfilter_inout_alloc();

        /// <summary>
        /// Free the supplied list of AVFilterInOut and set *inout to NULL.
        /// If *inout is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_inout_free")]
        public static extern void avfilter_inout_free(libavfilter.AVFilterInOut** inout);

        /// <summary>
        /// Free the supplied list of AVFilterInOut and set *inout to NULL.
        /// If *inout is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_inout_free")]
        public static extern void avfilter_inout_free(ref libavfilter.AVFilterInOut* inout);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// </summary>
        /// <param name="graph">
        /// the filter graph where to link the parsed graph context
        /// </param>
        /// <param name="filters">
        /// string to be parsed
        /// </param>
        /// <param name="inputs">
        /// pointer to a linked list to the inputs of the graph, may be NULL.
        /// If non-NULL, *inputs is updated to contain the list of open inputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <param name="outputs">
        /// pointer to a linked list to the outputs of the graph, may be NULL.
        /// If non-NULL, *outputs is updated to contain the list of open outputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <returns>
        /// non negative on success, a negative AVERROR code on error
        /// @deprecated Use avfilter_graph_parse_ptr() instead.
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse")]
        public static extern int avfilter_graph_parse(libavfilter.AVFilterGraph* graph, string filters, libavfilter.AVFilterInOut** inputs, libavfilter.AVFilterInOut** outputs, void* log_ctx);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// </summary>
        /// <param name="graph">
        /// the filter graph where to link the parsed graph context
        /// </param>
        /// <param name="filters">
        /// string to be parsed
        /// </param>
        /// <param name="inputs">
        /// pointer to a linked list to the inputs of the graph, may be NULL.
        /// If non-NULL, *inputs is updated to contain the list of open inputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <param name="outputs">
        /// pointer to a linked list to the outputs of the graph, may be NULL.
        /// If non-NULL, *outputs is updated to contain the list of open outputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <returns>
        /// non negative on success, a negative AVERROR code on error
        /// @deprecated Use avfilter_graph_parse_ptr() instead.
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse")]
        public static extern int avfilter_graph_parse(libavfilter.AVFilterGraph* graph, string filters, ref libavfilter.AVFilterInOut* inputs, ref libavfilter.AVFilterInOut* outputs, void* log_ctx);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// </summary>
        /// <param name="graph">
        /// the filter graph where to link the parsed graph context
        /// </param>
        /// <param name="filters">
        /// string to be parsed
        /// </param>
        /// <param name="inputs">
        /// pointer to a linked list to the inputs of the graph, may be NULL.
        /// If non-NULL, *inputs is updated to contain the list of open inputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <param name="outputs">
        /// pointer to a linked list to the outputs of the graph, may be NULL.
        /// If non-NULL, *outputs is updated to contain the list of open outputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <returns>
        /// non negative on success, a negative AVERROR code on error
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse_ptr")]
        public static extern int avfilter_graph_parse_ptr(libavfilter.AVFilterGraph* graph, string filters, libavfilter.AVFilterInOut** inputs, libavfilter.AVFilterInOut** outputs, void* log_ctx);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// </summary>
        /// <param name="graph">
        /// the filter graph where to link the parsed graph context
        /// </param>
        /// <param name="filters">
        /// string to be parsed
        /// </param>
        /// <param name="inputs">
        /// pointer to a linked list to the inputs of the graph, may be NULL.
        /// If non-NULL, *inputs is updated to contain the list of open inputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <param name="outputs">
        /// pointer to a linked list to the outputs of the graph, may be NULL.
        /// If non-NULL, *outputs is updated to contain the list of open outputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <returns>
        /// non negative on success, a negative AVERROR code on error
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse_ptr")]
        public static extern int avfilter_graph_parse_ptr(libavfilter.AVFilterGraph* graph, string filters, ref libavfilter.AVFilterInOut* inputs, ref libavfilter.AVFilterInOut* outputs, void* log_ctx);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// </summary>
        /// <param name="[in]">
        /// graph   the filter graph where to link the parsed graph context
        /// </param>
        /// <param name="[in]">
        /// filters string to be parsed
        /// </param>
        /// <param name="[out]">
        /// inputs  a linked list of all free (unlinked) inputs of the
        /// parsed graph will be returned here. It is to be freed
        /// by the caller using avfilter_inout_free().
        /// </param>
        /// <param name="[out]">
        /// outputs a linked list of all free (unlinked) outputs of the
        /// parsed graph will be returned here. It is to be freed by the
        /// caller using avfilter_inout_free().
        /// </param>
        /// <returns>
        /// zero on success, a negative AVERROR code on error
        /// </returns>
        /// <remark>
        /// This function returns the inputs and outputs that are left
        /// unlinked after parsing the graph and the caller then deals with
        /// them.
        /// </remark>
        /// <remark>
        /// This function makes no reference whatsoever to already
        /// existing parts of the graph and the inputs parameter will on return
        /// contain inputs of the newly parsed part of the graph.  Analogously
        /// the outputs parameter will contain outputs of the newly created
        /// filters.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse2")]
        public static extern int avfilter_graph_parse2(libavfilter.AVFilterGraph* graph, string filters, libavfilter.AVFilterInOut** inputs, libavfilter.AVFilterInOut** outputs);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// </summary>
        /// <param name="[in]">
        /// graph   the filter graph where to link the parsed graph context
        /// </param>
        /// <param name="[in]">
        /// filters string to be parsed
        /// </param>
        /// <param name="[out]">
        /// inputs  a linked list of all free (unlinked) inputs of the
        /// parsed graph will be returned here. It is to be freed
        /// by the caller using avfilter_inout_free().
        /// </param>
        /// <param name="[out]">
        /// outputs a linked list of all free (unlinked) outputs of the
        /// parsed graph will be returned here. It is to be freed by the
        /// caller using avfilter_inout_free().
        /// </param>
        /// <returns>
        /// zero on success, a negative AVERROR code on error
        /// </returns>
        /// <remark>
        /// This function returns the inputs and outputs that are left
        /// unlinked after parsing the graph and the caller then deals with
        /// them.
        /// </remark>
        /// <remark>
        /// This function makes no reference whatsoever to already
        /// existing parts of the graph and the inputs parameter will on return
        /// contain inputs of the newly parsed part of the graph.  Analogously
        /// the outputs parameter will contain outputs of the newly created
        /// filters.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse2")]
        public static extern int avfilter_graph_parse2(libavfilter.AVFilterGraph* graph, string filters, ref libavfilter.AVFilterInOut* inputs, ref libavfilter.AVFilterInOut* outputs);

        /// <summary>
        /// Send a command to one or more filter instances.
        /// </summary>
        /// <param name="graph">
        /// the filter graph
        /// </param>
        /// <param name="target">
        /// the filter(s) to which the command should be sent
        /// "all" sends to all filters
        /// otherwise it can be a filter or filter instance name
        /// which will send the command to all matching filters.
        /// </param>
        /// <param name="cmd">
        /// the command to send, for handling simplicity all commands must be
        /// alphanumeric only
        /// </param>
        /// <param name="arg">
        /// the argument for the command
        /// </param>
        /// <param name="res">
        /// a buffer with size res_size where the filter(s) can return a response.
        /// </param>
        /// <returns>
        /// s >=0 on success otherwise an error code.
        /// AVERROR(ENOSYS) on unsupported commands
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_send_command")]
        public static extern int avfilter_graph_send_command(libavfilter.AVFilterGraph* graph, string target, string cmd, string arg, System.Text.StringBuilder res, int res_len, int flags);

        /// <summary>
        /// Queue a command for one or more filter instances.
        /// </summary>
        /// <param name="graph">
        /// the filter graph
        /// </param>
        /// <param name="target">
        /// the filter(s) to which the command should be sent
        /// "all" sends to all filters
        /// otherwise it can be a filter or filter instance name
        /// which will send the command to all matching filters.
        /// </param>
        /// <param name="cmd">
        /// the command to sent, for handling simplicity all commands must be
        /// alphanummeric only
        /// </param>
        /// <param name="arg">
        /// the argument for the command
        /// </param>
        /// <param name="ts">
        /// time at which the command should be sent to the filter
        /// </param>
        /// <remark>
        /// As this executes commands after this function returns, no return code
        /// from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not
        /// supported.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_queue_command")]
        public static extern int avfilter_graph_queue_command(libavfilter.AVFilterGraph* graph, string target, string cmd, string arg, int flags, double ts);

        /// <summary>
        /// Dump a graph into a human-readable string representation.
        /// </summary>
        /// <param name="graph">
        /// the graph to dump
        /// </param>
        /// <param name="options">
        /// formatting options; currently ignored
        /// </param>
        /// <returns>
        /// a string, or NULL in case of memory allocation failure;
        /// the string must be freed using av_free
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_dump")]
        public static extern sbyte* avfilter_graph_dump(libavfilter.AVFilterGraph* graph, string options);

        /// <summary>
        /// Request a frame on the oldest sink link.
        /// 
        /// If the request returns AVERROR_EOF, try the next.
        /// 
        /// Note that this function is not meant to be the sole scheduling
        /// mechanism
        /// of a filtergraph, only a convenience function to help drain a
        /// filtergraph
        /// in a balanced way under normal circumstances.
        /// 
        /// Also note that AVERROR_EOF does not mean that frames did not arrive on
        /// some of the sinks during the process.
        /// When there are multiple sink links, in case the requested link
        /// returns an EOF, this may cause a filter to flush pending frames
        /// which are sent to another sink link, although unrequested.
        /// </summary>
        /// <returns>
        /// the return value of ff_request_frame(),
        /// or AVERROR_EOF if all links returned AVERROR_EOF
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_request_oldest")]
        public static extern int avfilter_graph_request_oldest(libavfilter.AVFilterGraph* graph);
    }
}
