//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using FFmpeg;

namespace FFmpeg
{
    /// <summary>
    /// Callback used by devices to communicate with application.
    /// </summary>
    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int av_format_control_message(libavformat.AVFormatContext* s, int type, void* data, global::System.UIntPtr data_size);

    public unsafe static partial class libavformat
    {
        public const sbyte AVPROBE_SCORE_EXTENSION = 50;

        public const sbyte AVPROBE_SCORE_MIME = 75;

        public const sbyte AVPROBE_SCORE_MAX = 100;

        public const sbyte AVPROBE_PADDING_SIZE = 32;

        public const sbyte AVFMT_NOFILE = 0x1;

        public const sbyte AVFMT_NEEDNUMBER = 0x2;

        public const sbyte AVFMT_SHOW_IDS = 0x8;

        public const sbyte AVFMT_RAWPICTURE = 0x20;

        public const sbyte AVFMT_GLOBALHEADER = 0x40;

        public const byte AVFMT_NOTIMESTAMPS = 0x80;

        public const short AVFMT_GENERIC_INDEX = 0x100;

        public const short AVFMT_TS_DISCONT = 0x200;

        public const short AVFMT_VARIABLE_FPS = 0x400;

        public const short AVFMT_NODIMENSIONS = 0x800;

        public const short AVFMT_NOSTREAMS = 0x1000;

        public const short AVFMT_NOBINSEARCH = 0x2000;

        public const short AVFMT_NOGENSEARCH = 0x4000;

        public const ushort AVFMT_NO_BYTE_SEEK = 0x8000;

        public const int AVFMT_ALLOW_FLUSH = 0x10000;

        public const int AVFMT_TS_NONSTRICT = 0x20000;

        public const int AVFMT_TS_NEGATIVE = 0x40000;

        public const int AVFMT_SEEK_TO_PTS = 0x4000000;

        public const sbyte AVINDEX_KEYFRAME = 0x1;

        public const sbyte AV_DISPOSITION_DEFAULT = 0x1;

        public const sbyte AV_DISPOSITION_DUB = 0x2;

        public const sbyte AV_DISPOSITION_ORIGINAL = 0x4;

        public const sbyte AV_DISPOSITION_COMMENT = 0x8;

        public const sbyte AV_DISPOSITION_LYRICS = 0x10;

        public const sbyte AV_DISPOSITION_KARAOKE = 0x20;

        public const sbyte AV_DISPOSITION_FORCED = 0x40;

        public const byte AV_DISPOSITION_HEARING_IMPAIRED = 0x80;

        public const short AV_DISPOSITION_VISUAL_IMPAIRED = 0x100;

        public const short AV_DISPOSITION_CLEAN_EFFECTS = 0x200;

        public const short AV_DISPOSITION_ATTACHED_PIC = 0x400;

        public const int AV_DISPOSITION_CAPTIONS = 0x10000;

        public const int AV_DISPOSITION_DESCRIPTIONS = 0x20000;

        public const int AV_DISPOSITION_METADATA = 0x40000;

        public const sbyte AV_PTS_WRAP_IGNORE = 0;

        public const sbyte AV_PTS_WRAP_ADD_OFFSET = 1;

        public const sbyte AV_PTS_WRAP_SUB_OFFSET = -1;

        public const sbyte AVSTREAM_EVENT_FLAG_METADATA_UPDATED = 0x1;

        public const short MAX_PROBE_PACKETS = 2500;

        public const sbyte MAX_REORDER_DELAY = 16;

        public const sbyte AV_PROGRAM_RUNNING = 1;

        public const sbyte AVFMTCTX_NOHEADER = 0x1;

        public const sbyte AVFMT_FLAG_GENPTS = 0x1;

        public const sbyte AVFMT_FLAG_IGNIDX = 0x2;

        public const sbyte AVFMT_FLAG_NONBLOCK = 0x4;

        public const sbyte AVFMT_FLAG_IGNDTS = 0x8;

        public const sbyte AVFMT_FLAG_NOFILLIN = 0x10;

        public const sbyte AVFMT_FLAG_NOPARSE = 0x20;

        public const sbyte AVFMT_FLAG_NOBUFFER = 0x40;

        public const byte AVFMT_FLAG_CUSTOM_IO = 0x80;

        public const short AVFMT_FLAG_DISCARD_CORRUPT = 0x100;

        public const short AVFMT_FLAG_FLUSH_PACKETS = 0x200;

        public const short AVFMT_FLAG_BITEXACT = 0x400;

        public const ushort AVFMT_FLAG_MP4A_LATM = 0x8000;

        public const int AVFMT_FLAG_SORT_DTS = 0x10000;

        public const int AVFMT_FLAG_PRIV_OPT = 0x20000;

        public const int AVFMT_FLAG_KEEP_SIDE_DATA = 0x40000;

        public const sbyte FF_FDEBUG_TS = 0x1;

        public const sbyte AVFMT_EVENT_FLAG_METADATA_UPDATED = 0x1;

        public const sbyte AVFMT_AVOID_NEG_TS_AUTO = -1;

        public const sbyte AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE = 1;

        public const sbyte AVFMT_AVOID_NEG_TS_MAKE_ZERO = 2;

        public const sbyte AVSEEK_FLAG_BACKWARD = 1;

        public const sbyte AVSEEK_FLAG_BYTE = 2;

        public const sbyte AVSEEK_FLAG_ANY = 4;

        public const sbyte AVSEEK_FLAG_FRAME = 8;

        /// <summary>
        /// @}
        /// </summary>
        public enum AVStreamParseType
        {
            AVSTREAM_PARSE_NONE = 0,
            /// <summary>full parsing and repack</summary>
            AVSTREAM_PARSE_FULL = 1,
            /// <summary>Only parse headers, do not repack.</summary>
            AVSTREAM_PARSE_HEADERS = 2,
            /// <summary>full parsing and interpolation of timestamps for frames not starting on a packet boundary</summary>
            AVSTREAM_PARSE_TIMESTAMPS = 3,
            /// <summary>full parsing and repack of the first frame only, only implemented for H.264 currently</summary>
            AVSTREAM_PARSE_FULL_ONCE = 4,
            /// <summary>full parsing and repack with timestamp and position generation by parser for raw this assumes that each packet in the file contains no demuxer level headers and just codec level data, otherwise position generation would fail</summary>
            AVSTREAM_PARSE_FULL_RAW = 1463898624
        }

        /// <summary>
        /// The duration of a video can be estimated through various ways, and this
        /// enum can be used
        /// to know how the duration was estimated.
        /// </summary>
        public enum AVDurationEstimationMethod
        {
            /// <summary>Duration accurately estimated from PTSes</summary>
            AVFMT_DURATION_FROM_PTS = 0,
            /// <summary>Duration estimated from a stream with a known duration</summary>
            AVFMT_DURATION_FROM_STREAM = 1,
            /// <summary>Duration estimated from bitrate (less accurate)</summary>
            AVFMT_DURATION_FROM_BITRATE = 2
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVDeviceInfoList
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVDeviceCapabilitiesQuery
        {
        }

        /// <summary>
        /// The exact value of the fractional number is: 'val + num / den'.
        /// num is assumed to be 0 <= num < den.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFrac
        {
            public long val;

            public long num;

            public long den;
        }

        /// <summary>
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVCodecTag
        {
        }

        /// <summary>
        /// This structure contains the data a format has to probe a file.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVProbeData
        {
            public sbyte* filename;

            /// <summary>
            /// Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled
            /// with zero.
            /// </summary>
            public byte* buf;

            /// <summary>
            /// Size of buf except extra allocated bytes
            /// </summary>
            public int buf_size;

            /// <summary>
            /// mime_type, when known.
            /// </summary>
            public sbyte* mime_type;
        }

        /// <summary>
        /// @addtogroup lavf_encoding
        /// @{
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVOutputFormat
        {
            public sbyte* name;

            /// <summary>
            /// Descriptive name for the format, meant to be more human-readable
            /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
            /// to define it.
            /// </summary>
            public sbyte* long_name;

            public sbyte* mime_type;

            /// <summary>
            /// comma-separated filename extensions
            /// </summary>
            public sbyte* extensions;

            /// <summary>
            /// default audio codec
            /// </summary>
            public libavcodec.AVCodecID audio_codec;

            /// <summary>
            /// default video codec
            /// </summary>
            public libavcodec.AVCodecID video_codec;

            /// <summary>
            /// default subtitle codec
            /// </summary>
            public libavcodec.AVCodecID subtitle_codec;

            /// <summary>
            /// can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_RAWPICTURE,
            /// AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,
            /// AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,
            /// AVFMT_TS_NONSTRICT
            /// </summary>
            public int flags;

            /// <summary>
            /// List of supported codec_id-codec_tag pairs, ordered by "better
            /// choice first". The arrays are all terminated by AV_CODEC_ID_NONE.
            /// </summary>
            public libavformat.AVCodecTag** codec_tag;

            /// <summary>
            /// AVClass for the private context
            /// </summary>
            public libavutil.AVClass* priv_class;

            /// <summary>
            /// 
            /// No fields below this line are part of the public API. They
            /// may not be used outside of libavformat and can be changed and
            /// removed at will.
            /// New public fields should be added right above.
            /// </summary>
            public libavformat.AVOutputFormat* next;

            /// <summary>
            /// size of private data so that it can be allocated in the wrapper
            /// </summary>
            public int priv_data_size;

            public global::System.IntPtr write_header;

            /// <summary>
            /// Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,
            /// pkt can be NULL in order to flush data buffered in the muxer.
            /// When flushing, return 0 if there still is more data to flush,
            /// or 1 if everything was flushed and there is no more buffered
            /// data.
            /// </summary>
            public global::System.IntPtr write_packet;

            public global::System.IntPtr write_trailer;

            /// <summary>
            /// Currently only used to set pixel format if not YUV420P.
            /// </summary>
            public global::System.IntPtr interleave_packet;

            /// <summary>
            /// Test if the given codec can be stored in this container.
            /// </summary>
            /// <returns>
            /// 1 if the codec is supported, 0 if it is not.
            /// A negative number if unknown.
            /// MKTAG('A', 'P', 'I', 'C') if the codec is only supported as
            /// AV_DISPOSITION_ATTACHED_PIC
            /// </returns>
            public global::System.IntPtr query_codec;

            public global::System.IntPtr get_output_timestamp;

            /// <summary>
            /// Allows sending messages from application to device.
            /// </summary>
            public global::System.IntPtr control_message;

            /// <summary>
            /// Write an uncoded AVFrame.
            /// 
            /// See av_write_uncoded_frame() for details.
            /// 
            /// The library will free *frame afterwards, but the muxer can prevent it
            /// by setting the pointer to NULL.
            /// </summary>
            public global::System.IntPtr write_uncoded_frame;

            /// <summary>
            /// Returns device list with it properties.
            /// @see avdevice_list_devices() for more details.
            /// </summary>
            public global::System.IntPtr get_device_list;

            /// <summary>
            /// Initialize device capabilities submodule.
            /// @see avdevice_capabilities_create() for more details.
            /// </summary>
            public global::System.IntPtr create_device_capabilities;

            /// <summary>
            /// Free device capabilities submodule.
            /// @see avdevice_capabilities_free() for more details.
            /// </summary>
            public global::System.IntPtr free_device_capabilities;

            /// <summary>
            /// default data codec
            /// </summary>
            public libavcodec.AVCodecID data_codec;
        }

        /// <summary>
        /// @addtogroup lavf_decoding
        /// @{
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVInputFormat
        {
            /// <summary>
            /// A comma separated list of short names for the format. New names
            /// may be appended with a minor bump.
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// Descriptive name for the format, meant to be more human-readable
            /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
            /// to define it.
            /// </summary>
            public sbyte* long_name;

            /// <summary>
            /// Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,
            /// AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,
            /// AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.
            /// </summary>
            public int flags;

            /// <summary>
            /// If extensions are defined, then no probe is done. You should
            /// usually not use extension format guessing because it is not
            /// reliable enough
            /// </summary>
            public sbyte* extensions;

            public libavformat.AVCodecTag** codec_tag;

            /// <summary>
            /// AVClass for the private context
            /// </summary>
            public libavutil.AVClass* priv_class;

            /// <summary>
            /// Comma-separated list of mime types.
            /// It is used check for matching mime types while probing.
            /// @see av_probe_input_format2
            /// </summary>
            public sbyte* mime_type;

            /// <summary>
            /// 
            /// No fields below this line are part of the public API. They
            /// may not be used outside of libavformat and can be changed and
            /// removed at will.
            /// New public fields should be added right above.
            /// </summary>
            public libavformat.AVInputFormat* next;

            /// <summary>
            /// Raw demuxers store their codec ID here.
            /// </summary>
            public int raw_codec_id;

            /// <summary>
            /// Size of private data so that it can be allocated in the wrapper.
            /// </summary>
            public int priv_data_size;

            /// <summary>
            /// Tell if a given file has a chance of being parsed as this format.
            /// The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes
            /// big so you do not have to check for that unless you need more.
            /// </summary>
            public global::System.IntPtr read_probe;

            /// <summary>
            /// Read the format header and initialize the AVFormatContext
            /// structure. Return 0 if OK. 'avformat_new_stream' should be
            /// called to create new streams.
            /// </summary>
            public global::System.IntPtr read_header;

            /// <summary>
            /// Read one packet and put it in 'pkt'. pts and flags are also
            /// set. 'avformat_new_stream' can be called only if the flag
            /// AVFMTCTX_NOHEADER is used and only in the calling thread (not in a
            /// background thread).
            /// </summary>
            /// <returns>
            /// 0 on success, < 0 on error.
            /// When returning an error, pkt must not have been allocated
            /// or must be freed before returning
            /// </returns>
            public global::System.IntPtr read_packet;

            /// <summary>
            /// Close the stream. The AVFormatContext and AVStreams are not
            /// freed by this function
            /// </summary>
            public global::System.IntPtr read_close;

            /// <summary>
            /// Seek to a given timestamp relative to the frames in
            /// stream component stream_index.
            /// </summary>
            /// <param name="stream_index">
            /// Must not be -1.
            /// </param>
            /// <param name="flags">
            /// Selects which direction should be preferred if no exact
            /// match is available.
            /// </param>
            /// <returns>
            /// >= 0 on success (but not necessarily the new offset)
            /// </returns>
            public global::System.IntPtr read_seek;

            /// <summary>
            /// Get the next timestamp in stream[stream_index].time_base units.
            /// </summary>
            /// <returns>
            /// the timestamp or AV_NOPTS_VALUE if an error occurred
            /// </returns>
            public global::System.IntPtr read_timestamp;

            /// <summary>
            /// Start/resume playing - only meaningful if using a network-based format
            /// (RTSP).
            /// </summary>
            public global::System.IntPtr read_play;

            /// <summary>
            /// Pause playing - only meaningful if using a network-based format
            /// (RTSP).
            /// </summary>
            public global::System.IntPtr read_pause;

            /// <summary>
            /// Seek to timestamp ts.
            /// Seeking will be done so that the point from which all active streams
            /// can be presented successfully will be closest to ts and within
            /// min/max_ts.
            /// Active streams are all streams that have AVStream.discard <
            /// AVDISCARD_ALL.
            /// </summary>
            public global::System.IntPtr read_seek2;

            /// <summary>
            /// Returns device list with it properties.
            /// @see avdevice_list_devices() for more details.
            /// </summary>
            public global::System.IntPtr get_device_list;

            /// <summary>
            /// Initialize device capabilities submodule.
            /// @see avdevice_capabilities_create() for more details.
            /// </summary>
            public global::System.IntPtr create_device_capabilities;

            /// <summary>
            /// Free device capabilities submodule.
            /// @see avdevice_capabilities_free() for more details.
            /// </summary>
            public global::System.IntPtr free_device_capabilities;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVIndexEntry
        {
            public long pos;

            /// <summary>
            /// 
            /// Timestamp in AVStream.time_base units, preferably the time from which
            /// on correctly decoded frames are available
            /// when seeking to this entry. That means preferable PTS on keyframe based
            /// formats.
            /// But demuxers can choose to store a different timestamp, if it is more
            /// convenient for the implementation or nothing better
            /// is known
            /// </summary>
            public long timestamp;

            public int flags;

            public int size;

            /// <summary>
            /// Minimum distance between this and the previous keyframe, used to avoid
            /// unneeded searching.
            /// </summary>
            public int min_distance;
        }

        /// <summary>
        /// Stream structure.
        /// New fields can be added to the end with minor version bumps.
        /// Removal, reordering and changes to existing fields require a major
        /// version bump.
        /// sizeof(AVStream) must not be used outside libav*.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVStream
        {
            /// <summary>
            /// stream index in AVFormatContext
            /// </summary>
            public int index;

            /// <summary>
            /// Format-specific stream ID.
            /// decoding: set by libavformat
            /// encoding: set by the user, replaced by libavformat if left unset
            /// </summary>
            public int id;

            /// <summary>
            /// Codec context associated with this stream. Allocated and freed by
            /// libavformat.
            /// 
            /// - decoding: The demuxer exports codec information stored in the headers
            /// here.
            /// - encoding: The user sets codec information, the muxer writes it to the
            /// output. Mandatory fields as specified in AVCodecContext
            /// documentation must be set even if this AVCodecContext is
            /// not actually used for encoding.
            /// </summary>
            public libavcodec.AVCodecContext* codec;

            public void* priv_data;

            [System.ObsoleteAttribute()]
            public libavformat.AVFrac pts;

            /// <summary>
            /// This is the fundamental unit of time (in seconds) in terms
            /// of which frame timestamps are represented.
            /// 
            /// decoding: set by libavformat
            /// encoding: May be set by the caller before avformat_write_header() to
            /// provide a hint to the muxer about the desired timebase. In
            /// avformat_write_header(), the muxer will overwrite this field
            /// with the timebase that will actually be used for the timestamps
            /// written into the file (which may or may not be related to the
            /// user-provided one, depending on the format).
            /// </summary>
            public libavutil.AVRational time_base;

            /// <summary>
            /// Decoding: pts of the first frame of the stream in presentation order,
            /// in stream time base.
            /// Only set this if you are absolutely 100% sure that the value you set
            /// it to really is the pts of the first frame.
            /// This may be undefined (AV_NOPTS_VALUE).
            /// </summary>
            /// <remark>
            /// The ASF header does NOT contain a correct start_time the ASF
            /// demuxer must NOT set this.
            /// </remark>
            public long start_time;

            /// <summary>
            /// Decoding: duration of the stream, in stream time base.
            /// If a source file does not specify a duration, but does specify
            /// a bitrate, this value will be estimated from bitrate and file size.
            /// </summary>
            public long duration;

            /// <summary>
            /// number of frames in this stream if known or 0
            /// </summary>
            public long nb_frames;

            /// <summary>
            /// AV_DISPOSITION_* bit field
            /// </summary>
            public int disposition;

            /// <summary>
            /// Selects which packets can be discarded at will and do not need to be
            /// demuxed.
            /// </summary>
            public libavcodec.AVDiscard discard;

            /// <summary>
            /// sample aspect ratio (0 if unknown)
            /// - encoding: Set by user.
            /// - decoding: Set by libavformat.
            /// </summary>
            public libavutil.AVRational sample_aspect_ratio;

            public libavutil.AVDictionary* metadata;

            /// <summary>
            /// Average framerate
            /// 
            /// - demuxing: May be set by libavformat when creating the stream or in
            /// avformat_find_stream_info().
            /// - muxing: May be set by the caller before avformat_write_header().
            /// </summary>
            public libavutil.AVRational avg_frame_rate;

            /// <summary>
            /// For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet
            /// will contain the attached picture.
            /// 
            /// decoding: set by libavformat, must not be modified by the caller.
            /// encoding: unused
            /// </summary>
            public libavcodec.AVPacket attached_pic;

            /// <summary>
            /// An array of side data that applies to the whole stream (i.e. the
            /// container does not allow it to change between packets).
            /// 
            /// There may be no overlap between the side data in this array and side
            /// data
            /// in the packets. I.e. a given side data is either exported by the muxer
            /// (demuxing) / set by the caller (muxing) in this array, then it never
            /// appears in the packets, or the side data is exported / sent through
            /// the packets (always in the first packet where the value becomes known
            /// or
            /// changes), then it does not appear in this array.
            /// 
            /// - demuxing: Set by libavformat when the stream is created.
            /// - muxing: May be set by the caller before avformat_write_header().
            /// 
            /// Freed by libavformat in avformat_free_context().
            /// 
            /// @see av_format_inject_global_side_data()
            /// </summary>
            public libavcodec.AVPacketSideData* side_data;

            /// <summary>
            /// The number of elements in the AVStream.side_data array.
            /// </summary>
            public int nb_side_data;

            /// <summary>
            /// Flags for the user to detect events happening on the stream. Flags must
            /// be cleared by the user once the event has been handled.
            /// A combination of AVSTREAM_EVENT_FLAG_*.
            /// </summary>
            public int event_flags;

            public libavformat.AVStream.AVStream_anon* info;

            /// <summary>
            /// number of bits in pts (used for wrapping control)
            /// </summary>
            public int pts_wrap_bits;

            /// <summary>
            /// Timestamp corresponding to the last dts sync point.
            /// 
            /// Initialized when AVCodecParserContext.dts_sync_point >= 0 and
            /// a DTS is received from the underlying container. Otherwise set to
            /// AV_NOPTS_VALUE by default.
            /// </summary>
            public long first_dts;

            public long cur_dts;

            public long last_IP_pts;

            public int last_IP_duration;

            public int probe_packets;

            /// <summary>
            /// Number of frames that have been demuxed during av_find_stream_info()
            /// </summary>
            public int codec_info_nb_frames;

            public libavformat.AVStreamParseType need_parsing;

            public libavcodec.AVCodecParserContext* parser;

            /// <summary>
            /// last packet in packet_buffer for this stream when muxing.
            /// </summary>
            public libavformat.AVPacketList* last_in_packet_buffer;

            public libavformat.AVProbeData probe_data;

            public fixed long pts_buffer[17];

            /// <summary>
            /// Only used if the format does not
            /// support seeking natively.
            /// </summary>
            public libavformat.AVIndexEntry* index_entries;

            public int nb_index_entries;

            public uint index_entries_allocated_size;

            /// <summary>
            /// Real base framerate of the stream.
            /// This is the lowest framerate with which all timestamps can be
            /// represented accurately (it is the least common multiple of all
            /// framerates in the stream). Note, this value is just a guess!
            /// For example, if the time base is 1/90000 and all frames have either
            /// approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.
            /// 
            /// Code outside avformat should access this field using:
            /// av_stream_get/set_r_frame_rate(stream)
            /// </summary>
            public libavutil.AVRational r_frame_rate;

            /// <summary>
            /// Stream Identifier
            /// This is the MPEG-TS stream identifier +1
            /// 0 means unknown
            /// </summary>
            public int stream_identifier;

            public long interleaver_chunk_size;

            public long interleaver_chunk_duration;

            /// <summary>
            /// stream probing state
            /// -1   -> probing finished
            /// 0   -> no probing requested
            /// rest -> perform probing with request_probe being the minimum score to
            /// accept.
            /// NOT PART OF PUBLIC API
            /// </summary>
            public int request_probe;

            /// <summary>
            /// Indicates that everything up to the next keyframe
            /// should be discarded.
            /// </summary>
            public int skip_to_keyframe;

            /// <summary>
            /// Number of samples to skip at the start of the frame decoded from the
            /// next packet.
            /// </summary>
            public int skip_samples;

            /// <summary>
            /// If not 0, the first audio sample that should be discarded from the
            /// stream.
            /// This is broken by design (needs global sample count), but can't be
            /// avoided for broken by design formats such as mp3 with ad-hoc gapless
            /// audio support.
            /// </summary>
            public long first_discard_sample;

            /// <summary>
            /// The sample after last sample that is intended to be discarded after
            /// first_discard_sample. Works on frame boundaries only. Used to prevent
            /// early EOF if the gapless info is broken (considered concatenated mp3s).
            /// </summary>
            public long last_discard_sample;

            /// <summary>
            /// Number of internally decoded frames, used internally in libavformat, do
            /// not access
            /// its lifetime differs from info which is why it is not in that
            /// structure.
            /// </summary>
            public int nb_decoded_frames;

            /// <summary>
            /// Timestamp offset added to timestamps before muxing
            /// NOT PART OF PUBLIC API
            /// </summary>
            public long mux_ts_offset;

            /// <summary>
            /// Internal data to check for wrapping of the time stamp
            /// </summary>
            public long pts_wrap_reference;

            /// <summary>
            /// Options for behavior, when a wrap is detected.
            /// 
            /// Defined by AV_PTS_WRAP_ values.
            /// 
            /// If correction is enabled, there are two possibilities:
            /// If the first time stamp is near the wrap point, the wrap offset
            /// will be subtracted, which will create negative time stamps.
            /// Otherwise the offset will be added.
            /// </summary>
            public int pts_wrap_behavior;

            /// <summary>
            /// Internal data to prevent doing update_initial_durations() twice
            /// </summary>
            public int update_initial_durations_done;

            /// <summary>
            /// Internal data to generate dts from pts
            /// </summary>
            public fixed long pts_reorder_error[17];

            public fixed byte pts_reorder_error_count[17];

            /// <summary>
            /// Internal data to analyze DTS and detect faulty mpeg streams
            /// </summary>
            public long last_dts_for_order_check;

            public byte dts_ordered;

            public byte dts_misordered;

            /// <summary>
            /// Internal data to inject global side data
            /// </summary>
            public int inject_global_side_data;

            /// <summary>
            /// String containing paris of key and values describing recommended
            /// encoder configuration.
            /// Paris are separated by ','.
            /// Keys are separated from values by '='.
            /// </summary>
            public sbyte* recommended_encoder_configuration;

            /// <summary>
            /// display aspect ratio (0 if unknown)
            /// - encoding: unused
            /// - decoding: Set by libavformat to calculate sample_aspect_ratio
            /// internally
            /// </summary>
            public libavutil.AVRational display_aspect_ratio;

            [StructLayout(LayoutKind.Sequential)]
            public unsafe partial struct AVStream_anon
            {
                public long last_dts;

                public long duration_gcd;

                public int duration_count;

                public long rfps_duration_sum;

                public fixed fixed double duration_error[746];

                public long codec_info_duration;

                public long codec_info_duration_fields;

                /// <summary>
                /// 0  -> decoder has not been searched for yet.
                /// >0 -> decoder found
                /// 0 -> decoder with codec_id == -found_decoder has not been found
                /// </summary>
                public int found_decoder;

                public long last_duration;

                /// <summary>
                /// Those are used for average framerate estimation.
                /// </summary>
                public long fps_first_dts;

                public int fps_first_dts_idx;

                public long fps_last_dts;

                public int fps_last_dts_idx;
            }
        }

        /// <summary>
        /// New fields can be added to the end with minor version bumps.
        /// Removal, reordering and changes to existing fields require a major
        /// version bump.
        /// sizeof(AVProgram) must not be used outside libav*.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVProgram
        {
            public int id;

            public int flags;

            /// <summary>
            /// selects which program to discard and which to feed to the caller
            /// </summary>
            public libavcodec.AVDiscard discard;

            public uint* stream_index;

            public uint nb_stream_indexes;

            public libavutil.AVDictionary* metadata;

            public int program_num;

            public int pmt_pid;

            public int pcr_pid;

            /// <summary>
            /// 
            /// All fields below this line are not part of the public API. They
            /// may not be used outside of libavformat and can be changed and
            /// removed at will.
            /// New public fields should be added right above.
            /// </summary>
            public long start_time;

            public long end_time;

            /// <summary>
            /// reference dts for wrap detection
            /// </summary>
            public long pts_wrap_reference;

            /// <summary>
            /// behavior on wrap detection
            /// </summary>
            public int pts_wrap_behavior;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVChapter
        {
            /// <summary>
            /// unique ID to identify the chapter
            /// </summary>
            public int id;

            /// <summary>
            /// time base in which the start/end timestamps are specified
            /// </summary>
            public libavutil.AVRational time_base;

            /// <summary>
            /// chapter start/end time in time_base units
            /// </summary>
            public long start;

            /// <summary>
            /// chapter start/end time in time_base units
            /// </summary>
            public long end;

            public libavutil.AVDictionary* metadata;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFormatInternal
        {
        }

        /// <summary>
        /// Format I/O context.
        /// New fields can be added to the end with minor version bumps.
        /// Removal, reordering and changes to existing fields require a major
        /// version bump.
        /// sizeof(AVFormatContext) must not be used outside libav*, use
        /// avformat_alloc_context() to create an AVFormatContext.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFormatContext
        {
            /// <summary>
            /// A class for logging and @ref avoptions. Set by
            /// avformat_alloc_context().
            /// Exports (de)muxer private options if they exist.
            /// </summary>
            public libavutil.AVClass* av_class;

            /// <summary>
            /// The input container format.
            /// 
            /// Demuxing only, set by avformat_open_input().
            /// </summary>
            public libavformat.AVInputFormat* iformat;

            /// <summary>
            /// The output container format.
            /// 
            /// Muxing only, must be set by the caller before avformat_write_header().
            /// </summary>
            public libavformat.AVOutputFormat* oformat;

            /// <summary>
            /// Format private data. This is an AVOptions-enabled struct
            /// if and only if iformat/oformat.priv_class is not NULL.
            /// 
            /// - muxing: set by avformat_write_header()
            /// - demuxing: set by avformat_open_input()
            /// </summary>
            public void* priv_data;

            /// <summary>
            /// I/O context.
            /// 
            /// - demuxing: either set by the user before avformat_open_input() (then
            /// the user must close it manually) or set by avformat_open_input().
            /// - muxing: set by the user before avformat_write_header(). The caller
            /// must
            /// take care of closing / freeing the IO context.
            /// 
            /// Do NOT set this field if AVFMT_NOFILE flag is set in
            /// iformat/oformat.flags. In such a case, the (de)muxer will handle
            /// I/O in some other way and this field will be NULL.
            /// </summary>
            public libavformat.AVIOContext* pb;

            /// <summary>
            /// Flags signalling stream properties. A combination of AVFMTCTX_*.
            /// Set by libavformat.
            /// </summary>
            public int ctx_flags;

            /// <summary>
            /// Number of elements in AVFormatContext.streams.
            /// 
            /// Set by avformat_new_stream(), must not be modified by any other code.
            /// </summary>
            public uint nb_streams;

            /// <summary>
            /// A list of all streams in the file. New streams are created with
            /// avformat_new_stream().
            /// 
            /// - demuxing: streams are created by libavformat in
            /// avformat_open_input().
            /// If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also
            /// appear in av_read_frame().
            /// - muxing: streams are created by the user before
            /// avformat_write_header().
            /// 
            /// Freed by libavformat in avformat_free_context().
            /// </summary>
            public libavformat.AVStream** streams;

            /// <summary>
            /// input or output filename
            /// 
            /// - demuxing: set by avformat_open_input()
            /// - muxing: may be set by the caller before avformat_write_header()
            /// </summary>
            public fixed sbyte filename[1024];

            /// <summary>
            /// Position of the first frame of the component, in
            /// AV_TIME_BASE fractional seconds. NEVER set this value directly:
            /// It is deduced from the AVStream values.
            /// 
            /// Demuxing only, set by libavformat.
            /// </summary>
            public long start_time;

            /// <summary>
            /// Duration of the stream, in AV_TIME_BASE fractional
            /// seconds. Only set this value if you know none of the individual stream
            /// durations and also do not set any of them. This is deduced from the
            /// AVStream values if not set.
            /// 
            /// Demuxing only, set by libavformat.
            /// </summary>
            public long duration;

            /// <summary>
            /// Total stream bitrate in bit/s, 0 if not
            /// available. Never set it directly if the file_size and the
            /// duration are known as FFmpeg can compute it automatically.
            /// </summary>
            public int bit_rate;

            public uint packet_size;

            public int max_delay;

            /// <summary>
            /// Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.
            /// Set by the user before avformat_open_input() / avformat_write_header().
            /// </summary>
            public int flags;

            public uint probesize;

            [System.ObsoleteAttribute()]
            public int max_analyze_duration;

            public byte* key;

            public int keylen;

            public uint nb_programs;

            public libavformat.AVProgram** programs;

            /// <summary>
            /// Forced video codec_id.
            /// Demuxing: Set by user.
            /// </summary>
            public libavcodec.AVCodecID video_codec_id;

            /// <summary>
            /// Forced audio codec_id.
            /// Demuxing: Set by user.
            /// </summary>
            public libavcodec.AVCodecID audio_codec_id;

            /// <summary>
            /// Forced subtitle codec_id.
            /// Demuxing: Set by user.
            /// </summary>
            public libavcodec.AVCodecID subtitle_codec_id;

            /// <summary>
            /// Maximum amount of memory in bytes to use for the index of each stream.
            /// If the index exceeds this size, entries will be discarded as
            /// needed to maintain a smaller size. This can lead to slower or less
            /// accurate seeking (depends on demuxer).
            /// Demuxers for which a full in-memory index is mandatory will ignore
            /// this.
            /// - muxing: unused
            /// - demuxing: set by user
            /// </summary>
            public uint max_index_size;

            /// <summary>
            /// Maximum amount of memory in bytes to use for buffering frames
            /// obtained from realtime capture devices.
            /// </summary>
            public uint max_picture_buffer;

            /// <summary>
            /// Number of chapters in AVChapter array.
            /// When muxing, chapters are normally written in the file header,
            /// so nb_chapters should normally be initialized before write_header
            /// is called. Some muxers (e.g. mov and mkv) can also write chapters
            /// in the trailer.  To write chapters in the trailer, nb_chapters
            /// must be zero when write_header is called and non-zero when
            /// write_trailer is called.
            /// - muxing: set by user
            /// - demuxing: set by libavformat
            /// </summary>
            public uint nb_chapters;

            public libavformat.AVChapter** chapters;

            /// <summary>
            /// Metadata that applies to the whole file.
            /// 
            /// - demuxing: set by libavformat in avformat_open_input()
            /// - muxing: may be set by the caller before avformat_write_header()
            /// 
            /// Freed by libavformat in avformat_free_context().
            /// </summary>
            public libavutil.AVDictionary* metadata;

            /// <summary>
            /// Start time of the stream in real world time, in microseconds
            /// since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the
            /// stream was captured at this real world time.
            /// - muxing: Set by the caller before avformat_write_header(). If set to
            /// either 0 or AV_NOPTS_VALUE, then the current wall-time will
            /// be used.
            /// - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that
            /// the value may become known after some number of frames
            /// have been received.
            /// </summary>
            public long start_time_realtime;

            /// <summary>
            /// The number of frames used for determining the framerate in
            /// avformat_find_stream_info().
            /// Demuxing only, set by the caller before avformat_find_stream_info().
            /// </summary>
            public int fps_probe_size;

            /// <summary>
            /// Error recognition; higher values will detect more errors but may
            /// misdetect some more or less valid parts as errors.
            /// Demuxing only, set by the caller before avformat_open_input().
            /// </summary>
            public int error_recognition;

            /// <summary>
            /// Custom interrupt callbacks for the I/O layer.
            /// 
            /// demuxing: set by the user before avformat_open_input().
            /// muxing: set by the user before avformat_write_header()
            /// (mainly useful for AVFMT_NOFILE formats). The callback
            /// should also be passed to avio_open2() if it's used to
            /// open the file.
            /// </summary>
            public libavformat.AVIOInterruptCB interrupt_callback;

            /// <summary>
            /// Flags to enable debugging.
            /// </summary>
            public int debug;

            /// <summary>
            /// Maximum buffering duration for interleaving.
            /// 
            /// To ensure all the streams are interleaved correctly,
            /// av_interleaved_write_frame() will wait until it has at least one packet
            /// for each stream before actually writing any packets to the output file.
            /// When some streams are "sparse" (i.e. there are large gaps between
            /// successive packets), this can result in excessive buffering.
            /// 
            /// This field specifies the maximum difference between the timestamps of
            /// the
            /// first and the last packet in the muxing queue, above which libavformat
            /// will output a packet regardless of whether it has queued a packet for
            /// all
            /// the streams.
            /// 
            /// Muxing only, set by the caller before avformat_write_header().
            /// </summary>
            public long max_interleave_delta;

            /// <summary>
            /// Allow non-standard and experimental extension
            /// @see AVCodecContext.strict_std_compliance
            /// </summary>
            public int strict_std_compliance;

            /// <summary>
            /// Flags for the user to detect events happening on the file. Flags must
            /// be cleared by the user once the event has been handled.
            /// A combination of AVFMT_EVENT_FLAG_*.
            /// </summary>
            public int event_flags;

            /// <summary>
            /// Maximum number of packets to read while waiting for the first
            /// timestamp.
            /// Decoding only.
            /// </summary>
            public int max_ts_probe;

            /// <summary>
            /// Avoid negative timestamps during muxing.
            /// Any value of the AVFMT_AVOID_NEG_TS_* constants.
            /// Note, this only works when using av_interleaved_write_frame.
            /// (interleave_packet_per_dts is in use)
            /// - muxing: Set by user
            /// - demuxing: unused
            /// </summary>
            public int avoid_negative_ts;

            /// <summary>
            /// Transport stream id.
            /// This will be moved into demuxer private options. Thus no API/ABI
            /// compatibility
            /// </summary>
            public int ts_id;

            /// <summary>
            /// Audio preload in microseconds.
            /// Note, not all formats support this and unpredictable things may happen
            /// if it is used when not supported.
            /// - encoding: Set by user via AVOptions (NO direct access)
            /// - decoding: unused
            /// </summary>
            public int audio_preload;

            /// <summary>
            /// Max chunk time in microseconds.
            /// Note, not all formats support this and unpredictable things may happen
            /// if it is used when not supported.
            /// - encoding: Set by user via AVOptions (NO direct access)
            /// - decoding: unused
            /// </summary>
            public int max_chunk_duration;

            /// <summary>
            /// Max chunk size in bytes
            /// Note, not all formats support this and unpredictable things may happen
            /// if it is used when not supported.
            /// - encoding: Set by user via AVOptions (NO direct access)
            /// - decoding: unused
            /// </summary>
            public int max_chunk_size;

            /// <summary>
            /// forces the use of wallclock timestamps as pts/dts of packets
            /// This has undefined results in the presence of B frames.
            /// - encoding: unused
            /// - decoding: Set by user via AVOptions (NO direct access)
            /// </summary>
            public int use_wallclock_as_timestamps;

            /// <summary>
            /// avio flags, used to force AVIO_FLAG_DIRECT.
            /// - encoding: unused
            /// - decoding: Set by user via AVOptions (NO direct access)
            /// </summary>
            public int avio_flags;

            /// <summary>
            /// The duration field can be estimated through various ways, and this
            /// field can be used
            /// to know how the duration was estimated.
            /// - encoding: unused
            /// - decoding: Read by user via AVOptions (NO direct access)
            /// </summary>
            public libavformat.AVDurationEstimationMethod duration_estimation_method;

            /// <summary>
            /// Skip initial bytes when opening stream
            /// - encoding: unused
            /// - decoding: Set by user via AVOptions (NO direct access)
            /// </summary>
            public long skip_initial_bytes;

            /// <summary>
            /// Correct single timestamp overflows
            /// - encoding: unused
            /// - decoding: Set by user via AVOptions (NO direct access)
            /// </summary>
            public uint correct_ts_overflow;

            /// <summary>
            /// Force seeking to any (also non key) frames.
            /// - encoding: unused
            /// - decoding: Set by user via AVOptions (NO direct access)
            /// </summary>
            public int seek2any;

            /// <summary>
            /// Flush the I/O context after each packet.
            /// - encoding: Set by user via AVOptions (NO direct access)
            /// - decoding: unused
            /// </summary>
            public int flush_packets;

            /// <summary>
            /// format probing score.
            /// The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes
            /// the format.
            /// - encoding: unused
            /// - decoding: set by avformat, read by user via
            /// av_format_get_probe_score() (NO direct access)
            /// </summary>
            public int probe_score;

            /// <summary>
            /// number of bytes to read maximally to identify format.
            /// - encoding: unused
            /// - decoding: set by user through AVOPtions (NO direct access)
            /// </summary>
            public int format_probesize;

            /// <summary>
            /// ',' separated list of allowed decoders.
            /// If NULL then all are allowed
            /// - encoding: unused
            /// - decoding: set by user through AVOptions (NO direct access)
            /// </summary>
            public sbyte* codec_whitelist;

            /// <summary>
            /// ',' separated list of allowed demuxers.
            /// If NULL then all are allowed
            /// - encoding: unused
            /// - decoding: set by user through AVOptions (NO direct access)
            /// </summary>
            public sbyte* format_whitelist;

            /// <summary>
            /// An opaque field for libavformat internal usage.
            /// Must not be accessed in any way by callers.
            /// </summary>
            public libavformat.AVFormatInternal* @internal;

            /// <summary>
            /// IO repositioned flag.
            /// This is set by avformat when the underlaying IO context read pointer
            /// is repositioned, for example when doing byte based seeking.
            /// Demuxers can use the flag to detect such changes.
            /// </summary>
            public int io_repositioned;

            /// <summary>
            /// Forced video codec.
            /// This allows forcing a specific decoder, even when there are multiple
            /// with
            /// the same codec_id.
            /// Demuxing: Set by user via av_format_set_video_codec (NO direct access).
            /// </summary>
            public libavcodec.AVCodec* video_codec;

            /// <summary>
            /// Forced audio codec.
            /// This allows forcing a specific decoder, even when there are multiple
            /// with
            /// the same codec_id.
            /// Demuxing: Set by user via av_format_set_audio_codec (NO direct access).
            /// </summary>
            public libavcodec.AVCodec* audio_codec;

            /// <summary>
            /// Forced subtitle codec.
            /// This allows forcing a specific decoder, even when there are multiple
            /// with
            /// the same codec_id.
            /// Demuxing: Set by user via av_format_set_subtitle_codec (NO direct
            /// access).
            /// </summary>
            public libavcodec.AVCodec* subtitle_codec;

            /// <summary>
            /// Forced data codec.
            /// This allows forcing a specific decoder, even when there are multiple
            /// with
            /// the same codec_id.
            /// Demuxing: Set by user via av_format_set_data_codec (NO direct access).
            /// </summary>
            public libavcodec.AVCodec* data_codec;

            /// <summary>
            /// Number of bytes to be written as padding in a metadata header.
            /// Demuxing: Unused.
            /// Muxing: Set by user via av_format_set_metadata_header_padding.
            /// </summary>
            public int metadata_header_padding;

            /// <summary>
            /// User data.
            /// This is a place for some private data of the user.
            /// Mostly usable with control_message_cb or any future callbacks in
            /// device's context.
            /// </summary>
            public void* opaque;

            /// <summary>
            /// Callback used by devices to communicate with application.
            /// </summary>
            public global::System.IntPtr control_message_cb;

            /// <summary>
            /// Output timestamp offset, in microseconds.
            /// Muxing: set by user via AVOptions (NO direct access)
            /// </summary>
            public long output_ts_offset;

            /// <summary>
            /// Maximum duration (in AV_TIME_BASE units) of the data read
            /// from input in avformat_find_stream_info().
            /// Demuxing only, set by the caller before avformat_find_stream_info()
            /// via AVOptions (NO direct access).
            /// Can be set to 0 to let avformat choose using a heuristic.
            /// </summary>
            public long max_analyze_duration2;

            /// <summary>
            /// Maximum size of the data read from input for determining
            /// the input container format.
            /// Demuxing only, set by the caller before avformat_open_input()
            /// via AVOptions (NO direct access).
            /// </summary>
            public long probesize2;

            /// <summary>
            /// dump format separator.
            /// can be ", " or "\n      " or anything else
            /// Code outside libavformat should access this field using AVOptions
            /// (NO direct access).
            /// - muxing: Set by user.
            /// - demuxing: Set by user.
            /// </summary>
            public byte* dump_separator;

            /// <summary>
            /// Forced Data codec_id.
            /// Demuxing: Set by user.
            /// </summary>
            public libavcodec.AVCodecID data_codec_id;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVPacketList
        {
            public libavcodec.AVPacket pkt;

            public libavformat.AVPacketList* next;
        }

        /// <summary>
        /// Allocate and read the payload of a packet and initialize its
        /// fields with default values.
        /// </summary>
        /// <param name="s">
        /// associated IO context
        /// </param>
        /// <param name="pkt">
        /// packet
        /// </param>
        /// <param name="size">
        /// desired payload size
        /// </param>
        /// <returns>
        /// >0 (read size) if OK, AVERROR_xxx otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_packet")]
        public static extern int av_get_packet(libavformat.AVIOContext* s, libavcodec.AVPacket* pkt, int size);

        /// <summary>
        /// Read data and append it to the current content of the AVPacket.
        /// If pkt->size is 0 this is identical to av_get_packet.
        /// Note that this uses av_grow_packet and thus involves a realloc
        /// which is inefficient. Thus this function should only be used
        /// when there is no reasonable way to know (an upper bound of)
        /// the final size.
        /// </summary>
        /// <param name="s">
        /// associated IO context
        /// </param>
        /// <param name="pkt">
        /// packet
        /// </param>
        /// <param name="size">
        /// amount of data to read
        /// </param>
        /// <returns>
        /// >0 (read size) if OK, AVERROR_xxx otherwise, previous data
        /// will not be lost even if an error occurs.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_append_packet")]
        public static extern int av_append_packet(libavformat.AVIOContext* s, libavcodec.AVPacket* pkt, int size);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_stream_get_r_frame_rate")]
        public static extern libavutil.AVRational av_stream_get_r_frame_rate(libavformat.AVStream* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_stream_set_r_frame_rate")]
        public static extern void av_stream_set_r_frame_rate(libavformat.AVStream* s, libavutil.AVRational r);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_stream_get_parser")]
        public static extern libavcodec.AVCodecParserContext* av_stream_get_parser(libavformat.AVStream* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_stream_get_recommended_encoder_configuration")]
        public static extern sbyte* av_stream_get_recommended_encoder_configuration(libavformat.AVStream* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_stream_set_recommended_encoder_configuration")]
        public static extern void av_stream_set_recommended_encoder_configuration(libavformat.AVStream* s, System.Text.StringBuilder configuration);

        /// <summary>
        /// Returns the pts of the last muxed packet + its duration
        /// 
        /// the retuned value is undefined when used with a demuxer.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_stream_get_end_pts")]
        public static extern long av_stream_get_end_pts(libavformat.AVStream* st);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_get_probe_score")]
        public static extern int av_format_get_probe_score(libavformat.AVFormatContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_get_video_codec")]
        public static extern libavcodec.AVCodec* av_format_get_video_codec(libavformat.AVFormatContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_set_video_codec")]
        public static extern void av_format_set_video_codec(libavformat.AVFormatContext* s, libavcodec.AVCodec* c);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_get_audio_codec")]
        public static extern libavcodec.AVCodec* av_format_get_audio_codec(libavformat.AVFormatContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_set_audio_codec")]
        public static extern void av_format_set_audio_codec(libavformat.AVFormatContext* s, libavcodec.AVCodec* c);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_get_subtitle_codec")]
        public static extern libavcodec.AVCodec* av_format_get_subtitle_codec(libavformat.AVFormatContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_set_subtitle_codec")]
        public static extern void av_format_set_subtitle_codec(libavformat.AVFormatContext* s, libavcodec.AVCodec* c);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_get_data_codec")]
        public static extern libavcodec.AVCodec* av_format_get_data_codec(libavformat.AVFormatContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_set_data_codec")]
        public static extern void av_format_set_data_codec(libavformat.AVFormatContext* s, libavcodec.AVCodec* c);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_get_metadata_header_padding")]
        public static extern int av_format_get_metadata_header_padding(libavformat.AVFormatContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_set_metadata_header_padding")]
        public static extern void av_format_set_metadata_header_padding(libavformat.AVFormatContext* s, int c);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_get_opaque")]
        public static extern void* av_format_get_opaque(libavformat.AVFormatContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_set_opaque")]
        public static extern void av_format_set_opaque(libavformat.AVFormatContext* s, void* opaque);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_get_control_message_cb")]
        public static extern global::System.IntPtr av_format_get_control_message_cb(libavformat.AVFormatContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_set_control_message_cb")]
        public static extern void av_format_set_control_message_cb(libavformat.AVFormatContext* s, global::System.IntPtr callback);

        /// <summary>
        /// This function will cause global side data to be injected in the next
        /// packet
        /// of each stream as well as after any subsequent seek.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_format_inject_global_side_data")]
        public static extern void av_format_inject_global_side_data(libavformat.AVFormatContext* s);

        /// <summary>
        /// Returns the method used to set ctx->duration.
        /// </summary>
        /// <returns>
        /// AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or
        /// AVFMT_DURATION_FROM_BITRATE.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_fmt_ctx_get_duration_estimation_method")]
        public static extern libavformat.AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method(libavformat.AVFormatContext* ctx);

        /// <summary>
        /// Return the LIBAVFORMAT_VERSION_INT constant.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_version")]
        public static extern uint avformat_version();

        /// <summary>
        /// Return the libavformat build-time configuration.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_configuration")]
        public static extern sbyte* avformat_configuration();

        /// <summary>
        /// Return the libavformat license.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_license")]
        public static extern sbyte* avformat_license();

        /// <summary>
        /// Initialize libavformat and register all the muxers, demuxers and
        /// protocols. If you do not call this function, then you can select
        /// exactly which formats you want to support.
        /// 
        /// @see av_register_input_format()
        /// @see av_register_output_format()
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_register_all")]
        public static extern void av_register_all();

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_register_input_format")]
        public static extern void av_register_input_format(libavformat.AVInputFormat* format);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_register_output_format")]
        public static extern void av_register_output_format(libavformat.AVOutputFormat* format);

        /// <summary>
        /// Do global initialization of network components. This is optional,
        /// but recommended, since it avoids the overhead of implicitly
        /// doing the setup for each session.
        /// 
        /// Calling this function will become mandatory if using network
        /// protocols at some major version bump.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_network_init")]
        public static extern int avformat_network_init();

        /// <summary>
        /// Undo the initialization done by avformat_network_init.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_network_deinit")]
        public static extern int avformat_network_deinit();

        /// <summary>
        /// If f is NULL, returns the first registered input format,
        /// if f is non-NULL, returns the next registered input format after f
        /// or NULL if f is the last one.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_iformat_next")]
        public static extern libavformat.AVInputFormat* av_iformat_next(libavformat.AVInputFormat* f);

        /// <summary>
        /// If f is NULL, returns the first registered output format,
        /// if f is non-NULL, returns the next registered output format after f
        /// or NULL if f is the last one.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_oformat_next")]
        public static extern libavformat.AVOutputFormat* av_oformat_next(libavformat.AVOutputFormat* f);

        /// <summary>
        /// Allocate an AVFormatContext.
        /// avformat_free_context() can be used to free the context and everything
        /// allocated by the framework within it.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_alloc_context")]
        public static extern libavformat.AVFormatContext* avformat_alloc_context();

        /// <summary>
        /// Free an AVFormatContext and all its streams.
        /// </summary>
        /// <param name="s">
        /// context to free
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_free_context")]
        public static extern void avformat_free_context(libavformat.AVFormatContext* s);

        /// <summary>
        /// Get the AVClass for AVFormatContext. It can be used in combination with
        /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
        /// 
        /// @see av_opt_find().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_get_class")]
        public static extern libavutil.AVClass* avformat_get_class();

        /// <summary>
        /// Add a new stream to a media file.
        /// 
        /// When demuxing, it is called by the demuxer in read_header(). If the
        /// flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also
        /// be called in read_packet().
        /// 
        /// When muxing, should be called by the user before
        /// avformat_write_header().
        /// 
        /// User is required to call avcodec_close() and avformat_free_context() to
        /// clean up the allocation by avformat_new_stream().
        /// </summary>
        /// <param name="s">
        /// media file handle
        /// </param>
        /// <param name="c">
        /// If non-NULL, the AVCodecContext corresponding to the new stream
        /// will be initialized to use this codec. This is needed for e.g.
        /// codec-specific
        /// defaults to be set, so codec should be provided if it is known.
        /// </param>
        /// <returns>
        /// newly created stream or NULL on error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_new_stream")]
        public static extern libavformat.AVStream* avformat_new_stream(libavformat.AVFormatContext* s, libavcodec.AVCodec* c);

        /// <summary>
        /// Get side information from stream.
        /// </summary>
        /// <param name="stream">
        /// stream
        /// </param>
        /// <param name="type">
        /// desired side information type
        /// </param>
        /// <param name="size">
        /// pointer for side information size to store (optional)
        /// </param>
        /// <returns>
        /// pointer to data if present or NULL otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_stream_get_side_data")]
        public static extern byte* av_stream_get_side_data(libavformat.AVStream* stream, libavcodec.AVPacketSideDataType type, int* size);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_new_program")]
        public static extern libavformat.AVProgram* av_new_program(libavformat.AVFormatContext* s, int id);

        /// <summary>
        /// Allocate an AVFormatContext for an output format.
        /// avformat_free_context() can be used to free the context and
        /// everything allocated by the framework within it.
        /// </summary>
        /// <param name="ctx">
        /// is set to the created format context, or to NULL in
        /// case of failure
        /// </param>
        /// <param name="oformat">
        /// format to use for allocating the context, if NULL
        /// format_name and filename are used instead
        /// </param>
        /// <param name="format_name">
        /// the name of output format to use for allocating the
        /// context, if NULL filename is used instead
        /// </param>
        /// <param name="filename">
        /// the name of the filename to use for allocating the
        /// context, may be NULL
        /// </param>
        /// <returns>
        /// >= 0 in case of success, a negative AVERROR code in case of
        /// failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_alloc_output_context2")]
        public static extern int avformat_alloc_output_context2(libavformat.AVFormatContext** ctx, libavformat.AVOutputFormat* oformat, string format_name, string filename);

        /// <summary>
        /// Allocate an AVFormatContext for an output format.
        /// avformat_free_context() can be used to free the context and
        /// everything allocated by the framework within it.
        /// </summary>
        /// <param name="ctx">
        /// is set to the created format context, or to NULL in
        /// case of failure
        /// </param>
        /// <param name="oformat">
        /// format to use for allocating the context, if NULL
        /// format_name and filename are used instead
        /// </param>
        /// <param name="format_name">
        /// the name of output format to use for allocating the
        /// context, if NULL filename is used instead
        /// </param>
        /// <param name="filename">
        /// the name of the filename to use for allocating the
        /// context, may be NULL
        /// </param>
        /// <returns>
        /// >= 0 in case of success, a negative AVERROR code in case of
        /// failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_alloc_output_context2")]
        public static extern int avformat_alloc_output_context2(ref libavformat.AVFormatContext* ctx, libavformat.AVOutputFormat* oformat, string format_name, string filename);

        /// <summary>
        /// Find AVInputFormat based on the short name of the input format.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_find_input_format")]
        public static extern libavformat.AVInputFormat* av_find_input_format(string short_name);

        /// <summary>
        /// Guess the file format.
        /// </summary>
        /// <param name="pd">
        /// data to be probed
        /// </param>
        /// <param name="is_opened">
        /// Whether the file is already opened; determines whether
        /// demuxers with or without AVFMT_NOFILE are probed.
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_probe_input_format")]
        public static extern libavformat.AVInputFormat* av_probe_input_format(libavformat.AVProbeData* pd, int is_opened);

        /// <summary>
        /// Guess the file format.
        /// </summary>
        /// <param name="pd">
        /// data to be probed
        /// </param>
        /// <param name="is_opened">
        /// Whether the file is already opened; determines whether
        /// demuxers with or without AVFMT_NOFILE are probed.
        /// </param>
        /// <param name="score_max">
        /// A probe score larger that this is required to accept a
        /// detection, the variable is set to the actual detection
        /// score afterwards.
        /// If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended
        /// to retry with a larger probe buffer.
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_probe_input_format2")]
        public static extern libavformat.AVInputFormat* av_probe_input_format2(libavformat.AVProbeData* pd, int is_opened, int* score_max);

        /// <summary>
        /// Guess the file format.
        /// </summary>
        /// <param name="is_opened">
        /// Whether the file is already opened; determines whether
        /// demuxers with or without AVFMT_NOFILE are probed.
        /// </param>
        /// <param name="score_ret">
        /// The score of the best detection.
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_probe_input_format3")]
        public static extern libavformat.AVInputFormat* av_probe_input_format3(libavformat.AVProbeData* pd, int is_opened, int* score_ret);

        /// <summary>
        /// Probe a bytestream to determine the input format. Each time a probe
        /// returns
        /// with a score that is too low, the probe buffer size is increased and
        /// another
        /// attempt is made. When the maximum probe size is reached, the input
        /// format
        /// with the highest score is returned.
        /// </summary>
        /// <param name="pb">
        /// the bytestream to probe
        /// </param>
        /// <param name="fmt">
        /// the input format is put here
        /// </param>
        /// <param name="filename">
        /// the filename of the stream
        /// </param>
        /// <param name="logctx">
        /// the log context
        /// </param>
        /// <param name="offset">
        /// the offset within the bytestream to probe from
        /// </param>
        /// <param name="max_probe_size">
        /// the maximum probe buffer size (zero for default)
        /// </param>
        /// <returns>
        /// the score in case of success, a negative value corresponding to an
        /// the maximal score is AVPROBE_SCORE_MAX
        /// AVERROR code otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_probe_input_buffer2")]
        public static extern int av_probe_input_buffer2(libavformat.AVIOContext* pb, libavformat.AVInputFormat** fmt, string filename, void* logctx, uint offset, uint max_probe_size);

        /// <summary>
        /// Probe a bytestream to determine the input format. Each time a probe
        /// returns
        /// with a score that is too low, the probe buffer size is increased and
        /// another
        /// attempt is made. When the maximum probe size is reached, the input
        /// format
        /// with the highest score is returned.
        /// </summary>
        /// <param name="pb">
        /// the bytestream to probe
        /// </param>
        /// <param name="fmt">
        /// the input format is put here
        /// </param>
        /// <param name="filename">
        /// the filename of the stream
        /// </param>
        /// <param name="logctx">
        /// the log context
        /// </param>
        /// <param name="offset">
        /// the offset within the bytestream to probe from
        /// </param>
        /// <param name="max_probe_size">
        /// the maximum probe buffer size (zero for default)
        /// </param>
        /// <returns>
        /// the score in case of success, a negative value corresponding to an
        /// the maximal score is AVPROBE_SCORE_MAX
        /// AVERROR code otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_probe_input_buffer2")]
        public static extern int av_probe_input_buffer2(libavformat.AVIOContext* pb, ref libavformat.AVInputFormat* fmt, string filename, void* logctx, uint offset, uint max_probe_size);

        /// <summary>
        /// Like av_probe_input_buffer2() but returns 0 on success
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_probe_input_buffer")]
        public static extern int av_probe_input_buffer(libavformat.AVIOContext* pb, libavformat.AVInputFormat** fmt, string filename, void* logctx, uint offset, uint max_probe_size);

        /// <summary>
        /// Like av_probe_input_buffer2() but returns 0 on success
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_probe_input_buffer")]
        public static extern int av_probe_input_buffer(libavformat.AVIOContext* pb, ref libavformat.AVInputFormat* fmt, string filename, void* logctx, uint offset, uint max_probe_size);

        /// <summary>
        /// Open an input stream and read the header. The codecs are not opened.
        /// The stream must be closed with avformat_close_input().
        /// </summary>
        /// <param name="ps">
        /// Pointer to user-supplied AVFormatContext (allocated by
        /// avformat_alloc_context).
        /// May be a pointer to NULL, in which case an AVFormatContext is allocated
        /// by this
        /// function and written into ps.
        /// Note that a user-supplied AVFormatContext will be freed on failure.
        /// </param>
        /// <param name="filename">
        /// Name of the stream to open.
        /// </param>
        /// <param name="fmt">
        /// If non-NULL, this parameter forces a specific input format.
        /// Otherwise the format is autodetected.
        /// </param>
        /// <param name="options">
        /// A dictionary filled with AVFormatContext and demuxer-private options.
        /// On return this parameter will be destroyed and replaced with a dict
        /// containing
        /// options that were not found. May be NULL.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on failure.
        /// </returns>
        /// <remark>
        /// If you want to use custom IO, preallocate the format context and set
        /// its pb field.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_open_input")]
        public static extern int avformat_open_input(libavformat.AVFormatContext** ps, string filename, libavformat.AVInputFormat* fmt, libavutil.AVDictionary** options);

        /// <summary>
        /// Open an input stream and read the header. The codecs are not opened.
        /// The stream must be closed with avformat_close_input().
        /// </summary>
        /// <param name="ps">
        /// Pointer to user-supplied AVFormatContext (allocated by
        /// avformat_alloc_context).
        /// May be a pointer to NULL, in which case an AVFormatContext is allocated
        /// by this
        /// function and written into ps.
        /// Note that a user-supplied AVFormatContext will be freed on failure.
        /// </param>
        /// <param name="filename">
        /// Name of the stream to open.
        /// </param>
        /// <param name="fmt">
        /// If non-NULL, this parameter forces a specific input format.
        /// Otherwise the format is autodetected.
        /// </param>
        /// <param name="options">
        /// A dictionary filled with AVFormatContext and demuxer-private options.
        /// On return this parameter will be destroyed and replaced with a dict
        /// containing
        /// options that were not found. May be NULL.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on failure.
        /// </returns>
        /// <remark>
        /// If you want to use custom IO, preallocate the format context and set
        /// its pb field.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_open_input")]
        public static extern int avformat_open_input(ref libavformat.AVFormatContext* ps, string filename, libavformat.AVInputFormat* fmt, ref libavutil.AVDictionary* options);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_demuxer_open")]
        public static extern int av_demuxer_open(libavformat.AVFormatContext* ic);

        /// <summary>
        /// Read packets of a media file to get stream information. This
        /// is useful for file formats with no headers such as MPEG. This
        /// function also computes the real framerate in case of MPEG-2 repeat
        /// frame mode.
        /// The logical file position is not changed by this function;
        /// examined packets may be buffered for later processing.
        /// </summary>
        /// <param name="ic">
        /// media file handle
        /// </param>
        /// <param name="options">
        /// If non-NULL, an ic.nb_streams long array of pointers to
        /// dictionaries, where i-th member contains options for
        /// codec corresponding to i-th stream.
        /// On return each dictionary will be filled with options that were not
        /// found.
        /// </param>
        /// <returns>
        /// >=0 if OK, AVERROR_xxx on error
        /// </returns>
        /// <remark>
        /// this function isn't guaranteed to open all the codecs, so
        /// options being non-empty at return is a perfectly normal behavior.
        /// 
        /// @todo Let the user decide somehow what information is needed so that
        /// we do not waste time getting stuff the user does not need.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_find_stream_info")]
        public static extern int avformat_find_stream_info(libavformat.AVFormatContext* ic, libavutil.AVDictionary** options);

        /// <summary>
        /// Read packets of a media file to get stream information. This
        /// is useful for file formats with no headers such as MPEG. This
        /// function also computes the real framerate in case of MPEG-2 repeat
        /// frame mode.
        /// The logical file position is not changed by this function;
        /// examined packets may be buffered for later processing.
        /// </summary>
        /// <param name="ic">
        /// media file handle
        /// </param>
        /// <param name="options">
        /// If non-NULL, an ic.nb_streams long array of pointers to
        /// dictionaries, where i-th member contains options for
        /// codec corresponding to i-th stream.
        /// On return each dictionary will be filled with options that were not
        /// found.
        /// </param>
        /// <returns>
        /// >=0 if OK, AVERROR_xxx on error
        /// </returns>
        /// <remark>
        /// this function isn't guaranteed to open all the codecs, so
        /// options being non-empty at return is a perfectly normal behavior.
        /// 
        /// @todo Let the user decide somehow what information is needed so that
        /// we do not waste time getting stuff the user does not need.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_find_stream_info")]
        public static extern int avformat_find_stream_info(libavformat.AVFormatContext* ic, ref libavutil.AVDictionary* options);

        /// <summary>
        /// Find the programs which belong to a given stream.
        /// </summary>
        /// <param name="ic">
        /// media file handle
        /// </param>
        /// <param name="last">
        /// the last found program, the search will start after this
        /// program, or from the beginning if it is NULL
        /// </param>
        /// <param name="s">
        /// stream index
        /// </param>
        /// <returns>
        /// the next program which belongs to s, NULL if no program is found or
        /// the last program is not among the programs of ic.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_find_program_from_stream")]
        public static extern libavformat.AVProgram* av_find_program_from_stream(libavformat.AVFormatContext* ic, libavformat.AVProgram* last, int s);

        /// <summary>
        /// Find the "best" stream in the file.
        /// The best stream is determined according to various heuristics as the
        /// most
        /// likely to be what the user expects.
        /// If the decoder parameter is non-NULL, av_find_best_stream will find the
        /// default decoder for the stream's codec; streams for which no decoder
        /// can
        /// be found are ignored.
        /// </summary>
        /// <param name="ic">
        /// media file handle
        /// </param>
        /// <param name="type">
        /// stream type: video, audio, subtitles, etc.
        /// </param>
        /// <param name="wanted_stream_nb">
        /// user-requested stream number,
        /// or -1 for automatic selection
        /// </param>
        /// <param name="related_stream">
        /// try to find a stream related (eg. in the same
        /// program) to this one, or -1 if none
        /// </param>
        /// <param name="decoder_ret">
        /// if non-NULL, returns the decoder for the
        /// selected stream
        /// </param>
        /// <param name="flags">
        /// flags; none are currently defined
        /// </param>
        /// <returns>
        /// the non-negative stream number in case of success,
        /// AVERROR_STREAM_NOT_FOUND if no stream with the requested type
        /// could be found,
        /// AVERROR_DECODER_NOT_FOUND if streams were found but no decoder
        /// </returns>
        /// <remark>
        /// If av_find_best_stream returns successfully and decoder_ret is not
        /// NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_find_best_stream")]
        public static extern int av_find_best_stream(libavformat.AVFormatContext* ic, libavutil.AVMediaType type, int wanted_stream_nb, int related_stream, libavcodec.AVCodec** decoder_ret, int flags);

        /// <summary>
        /// Find the "best" stream in the file.
        /// The best stream is determined according to various heuristics as the
        /// most
        /// likely to be what the user expects.
        /// If the decoder parameter is non-NULL, av_find_best_stream will find the
        /// default decoder for the stream's codec; streams for which no decoder
        /// can
        /// be found are ignored.
        /// </summary>
        /// <param name="ic">
        /// media file handle
        /// </param>
        /// <param name="type">
        /// stream type: video, audio, subtitles, etc.
        /// </param>
        /// <param name="wanted_stream_nb">
        /// user-requested stream number,
        /// or -1 for automatic selection
        /// </param>
        /// <param name="related_stream">
        /// try to find a stream related (eg. in the same
        /// program) to this one, or -1 if none
        /// </param>
        /// <param name="decoder_ret">
        /// if non-NULL, returns the decoder for the
        /// selected stream
        /// </param>
        /// <param name="flags">
        /// flags; none are currently defined
        /// </param>
        /// <returns>
        /// the non-negative stream number in case of success,
        /// AVERROR_STREAM_NOT_FOUND if no stream with the requested type
        /// could be found,
        /// AVERROR_DECODER_NOT_FOUND if streams were found but no decoder
        /// </returns>
        /// <remark>
        /// If av_find_best_stream returns successfully and decoder_ret is not
        /// NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_find_best_stream")]
        public static extern int av_find_best_stream(libavformat.AVFormatContext* ic, libavutil.AVMediaType type, int wanted_stream_nb, int related_stream, ref libavcodec.AVCodec* decoder_ret, int flags);

        /// <summary>
        /// Return the next frame of a stream.
        /// This function returns what is stored in the file, and does not validate
        /// that what is there are valid frames for the decoder. It will split what
        /// is
        /// stored in the file into frames and return one for each call. It will
        /// not
        /// omit invalid data between valid frames so as to give the decoder the
        /// maximum
        /// information possible for decoding.
        /// 
        /// If pkt->buf is NULL, then the packet is valid until the next
        /// av_read_frame() or until avformat_close_input(). Otherwise the packet
        /// is valid indefinitely. In both cases the packet must be freed with
        /// av_free_packet when it is no longer needed. For video, the packet
        /// contains
        /// exactly one frame. For audio, it contains an integer number of frames
        /// if each
        /// frame has a known fixed size (e.g. PCM or ADPCM data). If the audio
        /// frames
        /// have a variable size (e.g. MPEG audio), then it contains one frame.
        /// 
        /// pkt->pts, pkt->dts and pkt->duration are always set to correct
        /// values in AVStream.time_base units (and guessed if the format cannot
        /// provide them). pkt->pts can be AV_NOPTS_VALUE if the video format
        /// has B-frames, so it is better to rely on pkt->dts if you do not
        /// decompress the payload.
        /// </summary>
        /// <returns>
        /// 0 if OK, < 0 on error or end of file
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_read_frame")]
        public static extern int av_read_frame(libavformat.AVFormatContext* s, libavcodec.AVPacket* pkt);

        /// <summary>
        /// Seek to the keyframe at timestamp.
        /// 'timestamp' in 'stream_index'.
        /// </summary>
        /// <param name="s">
        /// media file handle
        /// </param>
        /// <param name="stream_index">
        /// If stream_index is (-1), a default
        /// stream is selected, and timestamp is automatically converted
        /// from AV_TIME_BASE units to the stream specific time_base.
        /// </param>
        /// <param name="timestamp">
        /// Timestamp in AVStream.time_base units
        /// or, if no stream is specified, in AV_TIME_BASE units.
        /// </param>
        /// <param name="flags">
        /// flags which select direction and seeking mode
        /// </param>
        /// <returns>
        /// >= 0 on success
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_seek_frame")]
        public static extern int av_seek_frame(libavformat.AVFormatContext* s, int stream_index, long timestamp, int flags);

        /// <summary>
        /// Seek to timestamp ts.
        /// Seeking will be done so that the point from which all active streams
        /// can be presented successfully will be closest to ts and within
        /// min/max_ts.
        /// Active streams are all streams that have AVStream.discard <
        /// AVDISCARD_ALL.
        /// 
        /// If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and
        /// are the file position (this may not be supported by all demuxers).
        /// If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames
        /// in the stream with stream_index (this may not be supported by all
        /// demuxers).
        /// Otherwise all timestamps are in units of the stream selected by
        /// stream_index
        /// or if stream_index is -1, in AV_TIME_BASE units.
        /// If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as
        /// keyframes (this may not be supported by all demuxers).
        /// If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.
        /// </summary>
        /// <param name="s">
        /// media file handle
        /// </param>
        /// <param name="stream_index">
        /// index of the stream which is used as time base reference
        /// </param>
        /// <param name="min_ts">
        /// smallest acceptable timestamp
        /// </param>
        /// <param name="ts">
        /// target timestamp
        /// </param>
        /// <param name="max_ts">
        /// largest acceptable timestamp
        /// </param>
        /// <param name="flags">
        /// flags
        /// </param>
        /// <returns>
        /// >=0 on success, error code otherwise
        /// </returns>
        /// <remark>
        /// This is part of the new seek API which is still under construction.
        /// Thus do not use this yet. It may change at any time, do not expect
        /// ABI compatibility yet!
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_seek_file")]
        public static extern int avformat_seek_file(libavformat.AVFormatContext* s, int stream_index, long min_ts, long ts, long max_ts, int flags);

        /// <summary>
        /// Discard all internally buffered data. This can be useful when dealing
        /// with
        /// discontinuities in the byte stream. Generally works only with formats
        /// that
        /// can resync. This includes headerless formats like MPEG-TS/TS but should
        /// also
        /// work with NUT, Ogg and in a limited way AVI for example.
        /// 
        /// The set of streams, the detected duration, stream parameters and codecs
        /// do
        /// not change when calling this function. If you want a complete reset,
        /// it's
        /// better to open a new AVFormatContext.
        /// 
        /// This does not flush the AVIOContext (s->pb). If necessary, call
        /// avio_flush(s->pb) before calling this function.
        /// </summary>
        /// <param name="s">
        /// media file handle
        /// </param>
        /// <returns>
        /// >=0 on success, error code otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_flush")]
        public static extern int avformat_flush(libavformat.AVFormatContext* s);

        /// <summary>
        /// Start playing a network-based stream (e.g. RTSP stream) at the
        /// current position.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_read_play")]
        public static extern int av_read_play(libavformat.AVFormatContext* s);

        /// <summary>
        /// Pause a network-based stream (e.g. RTSP stream).
        /// 
        /// Use av_read_play() to resume it.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_read_pause")]
        public static extern int av_read_pause(libavformat.AVFormatContext* s);

        /// <summary>
        /// Close an opened input AVFormatContext. Free it and all its contents
        /// and set *s to NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_close_input")]
        public static extern void avformat_close_input(libavformat.AVFormatContext** s);

        /// <summary>
        /// Close an opened input AVFormatContext. Free it and all its contents
        /// and set *s to NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_close_input")]
        public static extern void avformat_close_input(ref libavformat.AVFormatContext* s);

        /// <summary>
        /// @addtogroup lavf_encoding
        /// @{
        /// 
        /// 
        /// Allocate the stream private data and write the stream header to
        /// an output media file.
        /// </summary>
        /// <param name="s">
        /// Media file handle, must be allocated with avformat_alloc_context().
        /// Its oformat field must be set to the desired output format;
        /// Its pb field must be set to an already opened AVIOContext.
        /// </param>
        /// <param name="options">
        /// An AVDictionary filled with AVFormatContext and muxer-private options.
        /// On return this parameter will be destroyed and replaced with a dict
        /// containing
        /// options that were not found. May be NULL.
        /// </param>
        /// <returns>
        /// 0 on success, negative AVERROR on failure.
        /// 
        /// @see av_opt_find, av_dict_set, avio_open, av_oformat_next.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_write_header")]
        public static extern int avformat_write_header(libavformat.AVFormatContext* s, libavutil.AVDictionary** options);

        /// <summary>
        /// @addtogroup lavf_encoding
        /// @{
        /// 
        /// 
        /// Allocate the stream private data and write the stream header to
        /// an output media file.
        /// </summary>
        /// <param name="s">
        /// Media file handle, must be allocated with avformat_alloc_context().
        /// Its oformat field must be set to the desired output format;
        /// Its pb field must be set to an already opened AVIOContext.
        /// </param>
        /// <param name="options">
        /// An AVDictionary filled with AVFormatContext and muxer-private options.
        /// On return this parameter will be destroyed and replaced with a dict
        /// containing
        /// options that were not found. May be NULL.
        /// </param>
        /// <returns>
        /// 0 on success, negative AVERROR on failure.
        /// 
        /// @see av_opt_find, av_dict_set, avio_open, av_oformat_next.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_write_header")]
        public static extern int avformat_write_header(libavformat.AVFormatContext* s, ref libavutil.AVDictionary* options);

        /// <summary>
        /// Write a packet to an output media file.
        /// 
        /// This function passes the packet directly to the muxer, without any
        /// buffering
        /// or reordering. The caller is responsible for correctly interleaving the
        /// packets if the format requires it. Callers that want libavformat to
        /// handle
        /// the interleaving should call av_interleaved_write_frame() instead of
        /// this
        /// function.
        /// </summary>
        /// <param name="s">
        /// media file handle
        /// </param>
        /// <param name="pkt">
        /// The packet containing the data to be written. Note that unlike
        /// av_interleaved_write_frame(), this function does not take
        /// ownership of the packet passed to it (though some muxers may make
        /// an internal reference to the input packet).
        /// br>
        /// This parameter can be NULL (at any time, not just at the end), in
        /// order to immediately flush data buffered within the muxer, for
        /// muxers that buffer up data internally before writing it to the
        /// output.
        /// br>
        /// Packet's @ref AVPacket.stream_index "stream_index" field must be
        /// set to the index of the corresponding stream in @ref
        /// AVFormatContext.streams "s->streams". It is very strongly
        /// recommended that timing information (@ref AVPacket.pts "pts", @ref
        /// AVPacket.dts "dts", @ref AVPacket.duration "duration") is set to
        /// correct values.
        /// </param>
        /// <returns>
        /// < 0 on error, = 0 if OK, 1 if flushed and there is no more data to
        /// flush
        /// 
        /// @see av_interleaved_write_frame()
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_write_frame")]
        public static extern int av_write_frame(libavformat.AVFormatContext* s, libavcodec.AVPacket* pkt);

        /// <summary>
        /// Write a packet to an output media file ensuring correct interleaving.
        /// 
        /// This function will buffer the packets internally as needed to make sure
        /// the
        /// packets in the output file are properly interleaved in the order of
        /// increasing dts. Callers doing their own interleaving should call
        /// av_write_frame() instead of this function.
        /// </summary>
        /// <param name="s">
        /// media file handle
        /// </param>
        /// <param name="pkt">
        /// The packet containing the data to be written.
        /// br>
        /// If the packet is reference-counted, this function will take
        /// ownership of this reference and unreference it later when it sees
        /// fit.
        /// The caller must not access the data through this reference after
        /// this function returns. If the packet is not reference-counted,
        /// libavformat will make a copy.
        /// br>
        /// This parameter can be NULL (at any time, not just at the end), to
        /// flush the interleaving queues.
        /// br>
        /// Packet's @ref AVPacket.stream_index "stream_index" field must be
        /// set to the index of the corresponding stream in @ref
        /// AVFormatContext.streams "s->streams". It is very strongly
        /// recommended that timing information (@ref AVPacket.pts "pts", @ref
        /// AVPacket.dts "dts", @ref AVPacket.duration "duration") is set to
        /// correct values.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on error. Libavformat will always
        /// take care of freeing the packet, even if this function fails.
        /// 
        /// @see av_write_frame(), AVFormatContext.max_interleave_delta
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_interleaved_write_frame")]
        public static extern int av_interleaved_write_frame(libavformat.AVFormatContext* s, libavcodec.AVPacket* pkt);

        /// <summary>
        /// Write a uncoded frame to an output media file.
        /// 
        /// The frame must be correctly interleaved according to the container
        /// specification; if not, then av_interleaved_write_frame() must be used.
        /// 
        /// See av_interleaved_write_frame() for details.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_write_uncoded_frame")]
        public static extern int av_write_uncoded_frame(libavformat.AVFormatContext* s, int stream_index, libavutil.AVFrame* frame);

        /// <summary>
        /// Write a uncoded frame to an output media file.
        /// 
        /// If the muxer supports it, this function allows to write an AVFrame
        /// structure directly, without encoding it into a packet.
        /// It is mostly useful for devices and similar special muxers that use raw
        /// video or PCM data and will not serialize it into a byte stream.
        /// 
        /// To test whether it is possible to use it with a given muxer and stream,
        /// use av_write_uncoded_frame_query().
        /// 
        /// The caller gives up ownership of the frame and must not access it
        /// afterwards.
        /// </summary>
        /// <returns>
        /// >=0 for success, a negative code on error
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_interleaved_write_uncoded_frame")]
        public static extern int av_interleaved_write_uncoded_frame(libavformat.AVFormatContext* s, int stream_index, libavutil.AVFrame* frame);

        /// <summary>
        /// Test whether a muxer supports uncoded frame.
        /// </summary>
        /// <returns>
        /// >=0 if an uncoded frame can be written to that muxer and stream,
        /// 0 if not
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_write_uncoded_frame_query")]
        public static extern int av_write_uncoded_frame_query(libavformat.AVFormatContext* s, int stream_index);

        /// <summary>
        /// Write the stream trailer to an output media file and free the
        /// file private data.
        /// 
        /// May only be called after a successful call to avformat_write_header.
        /// </summary>
        /// <param name="s">
        /// media file handle
        /// </param>
        /// <returns>
        /// 0 if OK, AVERROR_xxx on error
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_write_trailer")]
        public static extern int av_write_trailer(libavformat.AVFormatContext* s);

        /// <summary>
        /// Return the output format in the list of registered output formats
        /// which best matches the provided parameters, or return NULL if
        /// there is no match.
        /// </summary>
        /// <param name="short_name">
        /// if non-NULL checks if short_name matches with the
        /// names of the registered formats
        /// </param>
        /// <param name="filename">
        /// if non-NULL checks if filename terminates with the
        /// extensions of the registered formats
        /// </param>
        /// <param name="mime_type">
        /// if non-NULL checks if mime_type matches with the
        /// MIME type of the registered formats
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_guess_format")]
        public static extern libavformat.AVOutputFormat* av_guess_format(string short_name, string filename, string mime_type);

        /// <summary>
        /// Guess the codec ID based upon muxer and filename.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_guess_codec")]
        public static extern libavcodec.AVCodecID av_guess_codec(libavformat.AVOutputFormat* fmt, string short_name, string filename, string mime_type, libavutil.AVMediaType type);

        /// <summary>
        /// Get timing information for the data currently output.
        /// The exact meaning of "currently output" depends on the format.
        /// It is mostly relevant for devices that have an internal buffer and/or
        /// work in real time.
        /// </summary>
        /// <param name="s">
        /// media file handle
        /// </param>
        /// <param name="stream">
        /// stream in the media file
        /// </param>
        /// <param name="[out]">
        /// dts   DTS of the last packet output for the stream, in stream
        /// time_base units
        /// </param>
        /// <param name="[out]">
        /// wall  absolute time when that packet whas output,
        /// in microsecond
        /// </param>
        /// <returns>
        /// 0 if OK, AVERROR(ENOSYS) if the format does not support it
        /// Note: some formats or devices may not allow to measure dts and wall
        /// atomically.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_output_timestamp")]
        public static extern int av_get_output_timestamp(libavformat.AVFormatContext* s, int stream, long* dts, long* wall);

        /// <summary>
        /// Send a nice hexadecimal dump of a buffer to the log.
        /// </summary>
        /// <param name="avcl">
        /// A pointer to an arbitrary struct of which the first field is a
        /// pointer to an AVClass struct.
        /// </param>
        /// <param name="level">
        /// The importance level of the message, lower values signifying
        /// higher importance.
        /// </param>
        /// <param name="buf">
        /// buffer
        /// </param>
        /// <param name="size">
        /// buffer size
        /// 
        /// @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hex_dump_log")]
        public static extern void av_hex_dump_log(void* avcl, int level, byte* buf, int size);

        /// <summary>
        /// Send a nice dump of a packet to the log.
        /// </summary>
        /// <param name="avcl">
        /// A pointer to an arbitrary struct of which the first field is a
        /// pointer to an AVClass struct.
        /// </param>
        /// <param name="level">
        /// The importance level of the message, lower values signifying
        /// higher importance.
        /// </param>
        /// <param name="pkt">
        /// packet to dump
        /// </param>
        /// <param name="dump_payload">
        /// True if the payload must be displayed, too.
        /// </param>
        /// <param name="st">
        /// AVStream that the packet belongs to
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_pkt_dump_log2")]
        public static extern void av_pkt_dump_log2(void* avcl, int level, libavcodec.AVPacket* pkt, int dump_payload, libavformat.AVStream* st);

        /// <summary>
        /// Get the AVCodecID for the given codec tag tag.
        /// If no codec id is found returns AV_CODEC_ID_NONE.
        /// </summary>
        /// <param name="tags">
        /// list of supported codec_id-codec_tag pairs, as stored
        /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
        /// </param>
        /// <param name="tag">
        /// codec tag to match to a codec ID
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_id")]
        public static extern libavcodec.AVCodecID av_codec_get_id(libavformat.AVCodecTag** tags, uint tag);

        /// <summary>
        /// Get the AVCodecID for the given codec tag tag.
        /// If no codec id is found returns AV_CODEC_ID_NONE.
        /// </summary>
        /// <param name="tags">
        /// list of supported codec_id-codec_tag pairs, as stored
        /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
        /// </param>
        /// <param name="tag">
        /// codec tag to match to a codec ID
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_id")]
        public static extern libavcodec.AVCodecID av_codec_get_id(ref libavformat.AVCodecTag* tags, uint tag);

        /// <summary>
        /// Get the codec tag for the given codec id id.
        /// If no codec tag is found returns 0.
        /// </summary>
        /// <param name="tags">
        /// list of supported codec_id-codec_tag pairs, as stored
        /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
        /// </param>
        /// <param name="id">
        /// codec ID to match to a codec tag
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_tag")]
        public static extern uint av_codec_get_tag(libavformat.AVCodecTag** tags, libavcodec.AVCodecID id);

        /// <summary>
        /// Get the codec tag for the given codec id id.
        /// If no codec tag is found returns 0.
        /// </summary>
        /// <param name="tags">
        /// list of supported codec_id-codec_tag pairs, as stored
        /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
        /// </param>
        /// <param name="id">
        /// codec ID to match to a codec tag
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_tag")]
        public static extern uint av_codec_get_tag(ref libavformat.AVCodecTag* tags, libavcodec.AVCodecID id);

        /// <summary>
        /// Get the codec tag for the given codec id.
        /// </summary>
        /// <param name="tags">
        /// list of supported codec_id - codec_tag pairs, as stored
        /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
        /// </param>
        /// <param name="id">
        /// codec id that should be searched for in the list
        /// </param>
        /// <param name="tag">
        /// A pointer to the found tag
        /// </param>
        /// <returns>
        /// 0 if id was not found in tags, > 0 if it was found
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_tag2")]
        public static extern int av_codec_get_tag2(libavformat.AVCodecTag** tags, libavcodec.AVCodecID id, uint* tag);

        /// <summary>
        /// Get the codec tag for the given codec id.
        /// </summary>
        /// <param name="tags">
        /// list of supported codec_id - codec_tag pairs, as stored
        /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
        /// </param>
        /// <param name="id">
        /// codec id that should be searched for in the list
        /// </param>
        /// <param name="tag">
        /// A pointer to the found tag
        /// </param>
        /// <returns>
        /// 0 if id was not found in tags, > 0 if it was found
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_codec_get_tag2")]
        public static extern int av_codec_get_tag2(ref libavformat.AVCodecTag* tags, libavcodec.AVCodecID id, uint* tag);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_find_default_stream_index")]
        public static extern int av_find_default_stream_index(libavformat.AVFormatContext* s);

        /// <summary>
        /// Get the index for a specific timestamp.
        /// </summary>
        /// <param name="st">
        /// stream that the timestamp belongs to
        /// </param>
        /// <param name="timestamp">
        /// timestamp to retrieve the index for
        /// </param>
        /// <param name="flags">
        /// if AVSEEK_FLAG_BACKWARD then the returned index will correspond
        /// to the timestamp which is <= the requested one, if backward
        /// is 0, then it will be >=
        /// if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise
        /// </param>
        /// <returns>
        /// < 0 if no such timestamp could be found
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_index_search_timestamp")]
        public static extern int av_index_search_timestamp(libavformat.AVStream* st, long timestamp, int flags);

        /// <summary>
        /// Add an index entry into a sorted list. Update the entry if the list
        /// already contains it.
        /// </summary>
        /// <param name="timestamp">
        /// timestamp in the time base of the given stream
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_add_index_entry")]
        public static extern int av_add_index_entry(libavformat.AVStream* st, long pos, long timestamp, int size, int distance, int flags);

        /// <summary>
        /// Split a URL string into components.
        /// 
        /// The pointers to buffers for storing individual components may be null,
        /// in order to ignore that component. Buffers for components not found are
        /// set to empty strings. If the port is not found, it is set to a negative
        /// value.
        /// </summary>
        /// <param name="proto">
        /// the buffer for the protocol
        /// </param>
        /// <param name="proto_size">
        /// the size of the proto buffer
        /// </param>
        /// <param name="authorization">
        /// the buffer for the authorization
        /// </param>
        /// <param name="authorization_size">
        /// the size of the authorization buffer
        /// </param>
        /// <param name="hostname">
        /// the buffer for the host name
        /// </param>
        /// <param name="hostname_size">
        /// the size of the hostname buffer
        /// </param>
        /// <param name="port_ptr">
        /// a pointer to store the port number in
        /// </param>
        /// <param name="path">
        /// the buffer for the path
        /// </param>
        /// <param name="path_size">
        /// the size of the path buffer
        /// </param>
        /// <param name="url">
        /// the URL to split
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_url_split")]
        public static extern void av_url_split(System.Text.StringBuilder proto, int proto_size, System.Text.StringBuilder authorization, int authorization_size, System.Text.StringBuilder hostname, int hostname_size, int* port_ptr, System.Text.StringBuilder path, int path_size, string url);

        /// <summary>
        /// Print detailed information about the input or output format, such as
        /// duration, bitrate, streams, container, programs, metadata, side data,
        /// codec and time base.
        /// </summary>
        /// <param name="ic">
        /// the context to analyze
        /// </param>
        /// <param name="index">
        /// index of the stream to dump information about
        /// </param>
        /// <param name="url">
        /// the URL to print, such as source or destination file
        /// </param>
        /// <param name="is_output">
        /// Select whether the specified context is an input(0) or output(1)
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_dump_format")]
        public static extern void av_dump_format(libavformat.AVFormatContext* ic, int index, string url, int is_output);

        /// <summary>
        /// Return in 'buf' the path with '%d' replaced by a number.
        /// 
        /// Also handles the '%0nd' format where 'n' is the total number
        /// of digits and '%%'.
        /// </summary>
        /// <param name="buf">
        /// destination buffer
        /// </param>
        /// <param name="buf_size">
        /// destination buffer size
        /// </param>
        /// <param name="path">
        /// numbered sequence string
        /// </param>
        /// <param name="number">
        /// frame number
        /// </param>
        /// <returns>
        /// 0 if OK, -1 on format error
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_get_frame_filename")]
        public static extern int av_get_frame_filename(System.Text.StringBuilder buf, int buf_size, string path, int number);

        /// <summary>
        /// Check whether filename actually is a numbered sequence generator.
        /// </summary>
        /// <param name="filename">
        /// possible numbered sequence string
        /// </param>
        /// <returns>
        /// 1 if a valid numbered sequence string, 0 otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_filename_number_test")]
        public static extern int av_filename_number_test(string filename);

        /// <summary>
        /// Generate an SDP for an RTP session.
        /// 
        /// Note, this overwrites the id values of AVStreams in the muxer contexts
        /// for getting unique dynamic payload types.
        /// </summary>
        /// <param name="ac">
        /// array of AVFormatContexts describing the RTP streams. If the
        /// array is composed by only one context, such context can contain
        /// multiple AVStreams (one AVStream per RTP stream). Otherwise,
        /// all the contexts in the array (an AVCodecContext per RTP stream)
        /// must contain only one AVStream.
        /// </param>
        /// <param name="n_files">
        /// number of AVCodecContexts contained in ac
        /// </param>
        /// <param name="buf">
        /// buffer where the SDP will be stored (must be allocated by
        /// the caller)
        /// </param>
        /// <param name="size">
        /// the size of the buffer
        /// </param>
        /// <returns>
        /// 0 if OK, AVERROR_xxx on error
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_sdp_create")]
        public static extern int av_sdp_create(libavformat.AVFormatContext** ac, int n_files, System.Text.StringBuilder buf, int size);

        /// <summary>
        /// Return a positive value if the given filename has one of the given
        /// extensions, 0 otherwise.
        /// </summary>
        /// <param name="filename">
        /// file name to check against the given extensions
        /// </param>
        /// <param name="extensions">
        /// a comma-separated list of filename extensions
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_match_ext")]
        public static extern int av_match_ext(string filename, string extensions);

        /// <summary>
        /// Test if the given container can store a codec.
        /// </summary>
        /// <param name="ofmt">
        /// container to check for compatibility
        /// </param>
        /// <param name="codec_id">
        /// codec to potentially store in container
        /// </param>
        /// <param name="std_compliance">
        /// standards compliance level, one of FF_COMPLIANCE_
        /// </param>
        /// <returns>
        /// 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.
        /// A negative number if this information is not available.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_query_codec")]
        public static extern int avformat_query_codec(libavformat.AVOutputFormat* ofmt, libavcodec.AVCodecID codec_id, int std_compliance);

        /// <summary>
        /// @defgroup riff_fourcc RIFF FourCCs
        /// @{
        /// Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The
        /// tables are
        /// meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the
        /// following code:
        /// </summary>
        /// <code>
        /// uint32_t tag = MKTAG('H', '2', '6', '4');
        /// const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0
        /// };
        /// enum AVCodecID id = av_codec_get_id(table, tag);
        /// </code>
        /// <returns>
        /// the table mapping RIFF FourCCs for video to libavcodec AVCodecID.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_get_riff_video_tags")]
        public static extern libavformat.AVCodecTag* avformat_get_riff_video_tags();

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// the table mapping RIFF FourCCs for audio to AVCodecID.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_get_riff_audio_tags")]
        public static extern libavformat.AVCodecTag* avformat_get_riff_audio_tags();

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// the table mapping MOV FourCCs for video to libavcodec AVCodecID.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_get_mov_video_tags")]
        public static extern libavformat.AVCodecTag* avformat_get_mov_video_tags();

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// the table mapping MOV FourCCs for audio to AVCodecID.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_get_mov_audio_tags")]
        public static extern libavformat.AVCodecTag* avformat_get_mov_audio_tags();

        /// <summary>
        /// Guess the sample aspect ratio of a frame, based on both the stream and
        /// the
        /// frame aspect ratio.
        /// 
        /// Since the frame aspect ratio is set by the codec but the stream aspect
        /// ratio
        /// is set by the demuxer, these two may not be equal. This function tries
        /// to
        /// return the value that you should use if you would like to display the
        /// frame.
        /// 
        /// Basic logic is to use the stream aspect ratio if it is set to something
        /// sane
        /// otherwise use the frame aspect ratio. This way a container setting,
        /// which is
        /// usually easy to modify can override the coded value in the frames.
        /// </summary>
        /// <param name="format">
        /// the format context which the stream is part of
        /// </param>
        /// <param name="stream">
        /// the stream which the frame is part of
        /// </param>
        /// <param name="frame">
        /// the frame with the aspect ratio to be determined
        /// </param>
        /// <returns>
        /// the guessed (valid) sample_aspect_ratio, 0/1 if no idea
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_guess_sample_aspect_ratio")]
        public static extern libavutil.AVRational av_guess_sample_aspect_ratio(libavformat.AVFormatContext* format, libavformat.AVStream* stream, libavutil.AVFrame* frame);

        /// <summary>
        /// Guess the frame rate, based on both the container and codec
        /// information.
        /// </summary>
        /// <param name="ctx">
        /// the format context which the stream is part of
        /// </param>
        /// <param name="stream">
        /// the stream which the frame is part of
        /// </param>
        /// <param name="frame">
        /// the frame for which the frame rate should be determined, may be NULL
        /// </param>
        /// <returns>
        /// the guessed (valid) frame rate, 0/1 if no idea
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_guess_frame_rate")]
        public static extern libavutil.AVRational av_guess_frame_rate(libavformat.AVFormatContext* ctx, libavformat.AVStream* stream, libavutil.AVFrame* frame);

        /// <summary>
        /// Check if the stream st contained in s is matched by the stream
        /// specifier
        /// spec.
        /// 
        /// See the "stream specifiers" chapter in the documentation for the syntax
        /// of spec.
        /// </summary>
        /// <returns>
        /// >0 if st is matched by spec;
        /// 0  if st is not matched by spec;
        /// AVERROR code if spec is invalid
        /// </returns>
        /// <remark>
        /// A stream specifier can match several streams in the format.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_match_stream_specifier")]
        public static extern int avformat_match_stream_specifier(libavformat.AVFormatContext* s, libavformat.AVStream* st, string spec);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avformat_queue_attached_pictures")]
        public static extern int avformat_queue_attached_pictures(libavformat.AVFormatContext* s);
    }
}
