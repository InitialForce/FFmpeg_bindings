//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FFmpeg
{
    public unsafe static partial class libavutil
    {
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVAudioFifo
        {
        }

        /// <summary>
        /// Free an AVAudioFifo.
        /// </summary>
        /// <param name="af">
        /// AVAudioFifo to free
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_free")]
        public static extern void av_audio_fifo_free(libavutil.AVAudioFifo* af);

        /// <summary>
        /// Allocate an AVAudioFifo.
        /// </summary>
        /// <param name="sample_fmt">
        /// sample format
        /// </param>
        /// <param name="channels">
        /// number of channels
        /// </param>
        /// <param name="nb_samples">
        /// initial allocation size, in samples
        /// </param>
        /// <returns>
        /// newly allocated AVAudioFifo, or NULL on error
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_alloc")]
        public static extern libavutil.AVAudioFifo* av_audio_fifo_alloc(libavutil.AVSampleFormat sample_fmt, int channels, int nb_samples);

        /// <summary>
        /// Reallocate an AVAudioFifo.
        /// </summary>
        /// <param name="af">
        /// AVAudioFifo to reallocate
        /// </param>
        /// <param name="nb_samples">
        /// new allocation size, in samples
        /// </param>
        /// <returns>
        /// 0 if OK, or negative AVERROR code on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_realloc")]
        public static extern int av_audio_fifo_realloc(libavutil.AVAudioFifo* af, int nb_samples);

        /// <summary>
        /// Write data to an AVAudioFifo.
        /// 
        /// The AVAudioFifo will be reallocated automatically if the available
        /// space
        /// is less than nb_samples.
        /// 
        /// @see enum AVSampleFormat
        /// The documentation for AVSampleFormat describes the data layout.
        /// </summary>
        /// <param name="af">
        /// AVAudioFifo to write to
        /// </param>
        /// <param name="data">
        /// audio data plane pointers
        /// </param>
        /// <param name="nb_samples">
        /// number of samples to write
        /// </param>
        /// <returns>
        /// number of samples actually written, or negative AVERROR
        /// code on failure. If successful, the number of samples
        /// actually written will always be nb_samples.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_write")]
        public static extern int av_audio_fifo_write(libavutil.AVAudioFifo* af, void** data, int nb_samples);

        /// <summary>
        /// Write data to an AVAudioFifo.
        /// 
        /// The AVAudioFifo will be reallocated automatically if the available
        /// space
        /// is less than nb_samples.
        /// 
        /// @see enum AVSampleFormat
        /// The documentation for AVSampleFormat describes the data layout.
        /// </summary>
        /// <param name="af">
        /// AVAudioFifo to write to
        /// </param>
        /// <param name="data">
        /// audio data plane pointers
        /// </param>
        /// <param name="nb_samples">
        /// number of samples to write
        /// </param>
        /// <returns>
        /// number of samples actually written, or negative AVERROR
        /// code on failure. If successful, the number of samples
        /// actually written will always be nb_samples.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_write")]
        public static extern int av_audio_fifo_write(libavutil.AVAudioFifo* af, ref void* data, int nb_samples);

        /// <summary>
        /// Peek data from an AVAudioFifo.
        /// 
        /// @see enum AVSampleFormat
        /// The documentation for AVSampleFormat describes the data layout.
        /// </summary>
        /// <param name="af">
        /// AVAudioFifo to read from
        /// </param>
        /// <param name="data">
        /// audio data plane pointers
        /// </param>
        /// <param name="nb_samples">
        /// number of samples to peek
        /// </param>
        /// <returns>
        /// number of samples actually peek, or negative AVERROR code
        /// on failure. The number of samples actually peek will not
        /// be greater than nb_samples, and will only be less than
        /// nb_samples if av_audio_fifo_size is less than nb_samples.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_peek")]
        public static extern int av_audio_fifo_peek(libavutil.AVAudioFifo* af, void** data, int nb_samples);

        /// <summary>
        /// Peek data from an AVAudioFifo.
        /// 
        /// @see enum AVSampleFormat
        /// The documentation for AVSampleFormat describes the data layout.
        /// </summary>
        /// <param name="af">
        /// AVAudioFifo to read from
        /// </param>
        /// <param name="data">
        /// audio data plane pointers
        /// </param>
        /// <param name="nb_samples">
        /// number of samples to peek
        /// </param>
        /// <returns>
        /// number of samples actually peek, or negative AVERROR code
        /// on failure. The number of samples actually peek will not
        /// be greater than nb_samples, and will only be less than
        /// nb_samples if av_audio_fifo_size is less than nb_samples.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_peek")]
        public static extern int av_audio_fifo_peek(libavutil.AVAudioFifo* af, ref void* data, int nb_samples);

        /// <summary>
        /// Read data from an AVAudioFifo.
        /// 
        /// @see enum AVSampleFormat
        /// The documentation for AVSampleFormat describes the data layout.
        /// </summary>
        /// <param name="af">
        /// AVAudioFifo to read from
        /// </param>
        /// <param name="data">
        /// audio data plane pointers
        /// </param>
        /// <param name="nb_samples">
        /// number of samples to read
        /// </param>
        /// <returns>
        /// number of samples actually read, or negative AVERROR code
        /// on failure. The number of samples actually read will not
        /// be greater than nb_samples, and will only be less than
        /// nb_samples if av_audio_fifo_size is less than nb_samples.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_read")]
        public static extern int av_audio_fifo_read(libavutil.AVAudioFifo* af, void** data, int nb_samples);

        /// <summary>
        /// Read data from an AVAudioFifo.
        /// 
        /// @see enum AVSampleFormat
        /// The documentation for AVSampleFormat describes the data layout.
        /// </summary>
        /// <param name="af">
        /// AVAudioFifo to read from
        /// </param>
        /// <param name="data">
        /// audio data plane pointers
        /// </param>
        /// <param name="nb_samples">
        /// number of samples to read
        /// </param>
        /// <returns>
        /// number of samples actually read, or negative AVERROR code
        /// on failure. The number of samples actually read will not
        /// be greater than nb_samples, and will only be less than
        /// nb_samples if av_audio_fifo_size is less than nb_samples.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_read")]
        public static extern int av_audio_fifo_read(libavutil.AVAudioFifo* af, ref void* data, int nb_samples);

        /// <summary>
        /// Drain data from an AVAudioFifo.
        /// 
        /// Removes the data without reading it.
        /// </summary>
        /// <param name="af">
        /// AVAudioFifo to drain
        /// </param>
        /// <param name="nb_samples">
        /// number of samples to drain
        /// </param>
        /// <returns>
        /// 0 if OK, or negative AVERROR code on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_drain")]
        public static extern int av_audio_fifo_drain(libavutil.AVAudioFifo* af, int nb_samples);

        /// <summary>
        /// Reset the AVAudioFifo buffer.
        /// 
        /// This empties all data in the buffer.
        /// </summary>
        /// <param name="af">
        /// AVAudioFifo to reset
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_reset")]
        public static extern void av_audio_fifo_reset(libavutil.AVAudioFifo* af);

        /// <summary>
        /// Get the current number of samples in the AVAudioFifo available for
        /// reading.
        /// </summary>
        /// <param name="af">
        /// the AVAudioFifo to query
        /// </param>
        /// <returns>
        /// number of samples available for reading
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_size")]
        public static extern int av_audio_fifo_size(libavutil.AVAudioFifo* af);

        /// <summary>
        /// Get the current number of samples in the AVAudioFifo available for
        /// writing.
        /// </summary>
        /// <param name="af">
        /// the AVAudioFifo to query
        /// </param>
        /// <returns>
        /// number of samples available for writing
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_audio_fifo_space")]
        public static extern int av_audio_fifo_space(libavutil.AVAudioFifo* af);
    }
}
