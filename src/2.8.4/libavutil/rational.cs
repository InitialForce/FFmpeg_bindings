//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FFmpeg
{
    public unsafe static partial class libavutil
    {
        /// <summary>
        /// rational number numerator/denominator
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVRational
        {
            /// <summary>
            /// numerator
            /// </summary>
            public int num;

            /// <summary>
            /// denominator
            /// </summary>
            public int den;
        }

        /// <summary>
        /// Create a rational.
        /// Useful for compilers that do not support compound literals.
        /// </summary>
        /// <remark>
        /// The return value is not reduced.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_make_q")]
        public static extern libavutil.AVRational av_make_q(int num, int den);

        /// <summary>
        /// Compare two rationals.
        /// </summary>
        /// <param name="a">
        /// first rational
        /// </param>
        /// <param name="b">
        /// second rational
        /// </param>
        /// <returns>
        /// 0 if a==b, 1 if a>b, -1 if a<b, and INT_MIN if one of the
        /// values is of the form 0/0
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_cmp_q")]
        public static extern int av_cmp_q(libavutil.AVRational a, libavutil.AVRational b);

        /// <summary>
        /// Convert rational to double.
        /// </summary>
        /// <param name="a">
        /// rational to convert
        /// </param>
        /// <returns>
        /// (double) a
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_q2d")]
        public static extern double av_q2d(libavutil.AVRational a);

        /// <summary>
        /// Reduce a fraction.
        /// This is useful for framerate calculations.
        /// </summary>
        /// <param name="dst_num">
        /// destination numerator
        /// </param>
        /// <param name="dst_den">
        /// destination denominator
        /// </param>
        /// <param name="num">
        /// source numerator
        /// </param>
        /// <param name="den">
        /// source denominator
        /// </param>
        /// <param name="max">
        /// the maximum allowed for dst_num & dst_den
        /// </param>
        /// <returns>
        /// 1 if exact, 0 otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_reduce")]
        public static extern int av_reduce(int* dst_num, int* dst_den, long num, long den, long max);

        /// <summary>
        /// Multiply two rationals.
        /// </summary>
        /// <param name="b">
        /// first rational
        /// </param>
        /// <param name="c">
        /// second rational
        /// </param>
        /// <returns>
        /// b*c
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_mul_q")]
        public static extern libavutil.AVRational av_mul_q(libavutil.AVRational b, libavutil.AVRational c);

        /// <summary>
        /// Divide one rational by another.
        /// </summary>
        /// <param name="b">
        /// first rational
        /// </param>
        /// <param name="c">
        /// second rational
        /// </param>
        /// <returns>
        /// b/c
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_div_q")]
        public static extern libavutil.AVRational av_div_q(libavutil.AVRational b, libavutil.AVRational c);

        /// <summary>
        /// Add two rationals.
        /// </summary>
        /// <param name="b">
        /// first rational
        /// </param>
        /// <param name="c">
        /// second rational
        /// </param>
        /// <returns>
        /// b+c
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_add_q")]
        public static extern libavutil.AVRational av_add_q(libavutil.AVRational b, libavutil.AVRational c);

        /// <summary>
        /// Subtract one rational from another.
        /// </summary>
        /// <param name="b">
        /// first rational
        /// </param>
        /// <param name="c">
        /// second rational
        /// </param>
        /// <returns>
        /// b-c
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_sub_q")]
        public static extern libavutil.AVRational av_sub_q(libavutil.AVRational b, libavutil.AVRational c);

        /// <summary>
        /// Invert a rational.
        /// </summary>
        /// <param name="q">
        /// value
        /// </param>
        /// <returns>
        /// 1 / q
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_inv_q")]
        public static extern libavutil.AVRational av_inv_q(libavutil.AVRational q);

        /// <summary>
        /// Convert a double precision floating point number to a rational.
        /// inf is expressed as {1,0} or {-1,0} depending on the sign.
        /// </summary>
        /// <param name="d">
        /// double to convert
        /// </param>
        /// <param name="max">
        /// the maximum allowed numerator and denominator
        /// </param>
        /// <returns>
        /// (AVRational) d
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_d2q")]
        public static extern libavutil.AVRational av_d2q(double d, int max);

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// 1 if q1 is nearer to q than q2, -1 if q2 is nearer
        /// than q1, 0 if they have the same distance.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_nearer_q")]
        public static extern int av_nearer_q(libavutil.AVRational q, libavutil.AVRational q1, libavutil.AVRational q2);

        /// <summary>
        /// Find the nearest value in q_list to q.
        /// </summary>
        /// <param name="q_list">
        /// an array of rationals terminated by {0, 0}
        /// </param>
        /// <returns>
        /// the index of the nearest value found in the array
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_find_nearest_q_idx")]
        public static extern int av_find_nearest_q_idx(libavutil.AVRational q, libavutil.AVRational* q_list);

        /// <summary>
        /// Converts a AVRational to a IEEE 32bit float.
        /// 
        /// The float is returned in a uint32_t and its value is platform
        /// indepenant.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_q2intfloat")]
        public static extern uint av_q2intfloat(libavutil.AVRational q);
    }
}
