//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
// ReSharper disable RedundantUsingDirective
// ReSharper disable CheckNamespace
#pragma warning disable 1584,1711,1572,1581,1580,1573
using System;
using System.Runtime.InteropServices;
using System.Security;
using FFmpeg;

namespace FFmpeg
{
    /// <summary>
    /// A function executing multiple jobs, possibly in parallel.
    /// </summary>
    /// <param name="ctx">
    /// the filter context to which the jobs belong
    /// </param>
    /// <param name="func">
    /// the function to be called multiple times
    /// </param>
    /// <param name="arg">
    /// the argument to be passed to func
    /// </param>
    /// <param name="ret">
    /// a nb_jobs-sized array to be filled with return values from each
    /// invocation of func
    /// </param>
    /// <param name="nb_jobs">
    /// the number of jobs to execute
    /// </param>
    /// <returns>
    /// 0 on success, a negative AVERROR on error
    /// </returns>
    /// <summary>
    /// A function pointer passed to the @ref AVFilterGraph.execute
    /// callback to be
    /// executed multiple times, possibly in parallel.
    /// </summary>
    /// <param name="ctx">
    /// the filter context the job belongs to
    /// </param>
    /// <param name="arg">
    /// an opaque parameter passed through from @ref
    /// AVFilterGraph.execute
    /// </param>
    /// <param name="jobnr">
    /// the index of the job being executed
    /// </param>
    /// <param name="nb_jobs">
    /// the total number of jobs
    /// </param>
    /// <returns>
    /// 0 on success, a negative AVERROR on error
    /// </returns>
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "UnusedMember.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "InconsistentNaming")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantUnsafeContext")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "FieldCanBeMadeReadOnly.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "PartialTypeWithSinglePart")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantNameQualifier")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "ArrangeModifiersOrder")]
    public unsafe static partial class libavfilter
    {
        public const ulong AVFILTER_FLAG_DYNAMIC_INPUTS = (1 << 0);

        public const ulong AVFILTER_FLAG_DYNAMIC_OUTPUTS = (1 << 1);

        public const ulong AVFILTER_FLAG_SLICE_THREADS = (1 << 2);

        public const ulong AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC = (1 << 16);

        public const ulong AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL = (1 << 17);

        public const ulong AVFILTER_THREAD_SLICE = (1 << 0);

        public const sbyte AVFILTER_CMD_FLAG_ONE = 1;

        public const sbyte AVFILTER_CMD_FLAG_FAST = 2;

        public enum AVFILTER_AUTO_CONVERT
        {
            /// <summary>all automatic conversions enabled</summary>
            AVFILTER_AUTO_CONVERT_ALL = 0,
            /// <summary>all automatic conversions disabled</summary>
            AVFILTER_AUTO_CONVERT_NONE = -1
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterChannelLayouts
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterCommand
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterPad
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterFormats
        {
        }

        /// <summary>
        /// Filter definition. This defines the pads a filter contains, and all the
        /// callback functions used to interact with the filter.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilter
        {
            /// <summary>
            /// Filter name. Must be non-NULL and unique among filters.
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// A description of the filter. May be NULL.
            /// 
            /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
            /// </summary>
            public sbyte* description;

            /// <summary>
            /// List of inputs, terminated by a zeroed element.
            /// 
            /// NULL if there are no (static) inputs. Instances of filters with
            /// AVFILTER_FLAG_DYNAMIC_INPUTS set may have more inputs than present in
            /// this list.
            /// </summary>
            public libavfilter.AVFilterPad* inputs;

            /// <summary>
            /// List of outputs, terminated by a zeroed element.
            /// 
            /// NULL if there are no (static) outputs. Instances of filters with
            /// AVFILTER_FLAG_DYNAMIC_OUTPUTS set may have more outputs than present in
            /// this list.
            /// </summary>
            public libavfilter.AVFilterPad* outputs;

            /// <summary>
            /// A class for the private data, used to declare filter private AVOptions.
            /// This field is NULL for filters that do not declare any options.
            /// 
            /// If this field is non-NULL, the first member of the filter private data
            /// must be a pointer to AVClass, which will be set by libavfilter generic
            /// code to this class.
            /// </summary>
            public libavutil.AVClass* priv_class;

            /// <summary>
            /// A combination of AVFILTER_FLAG_
            /// </summary>
            public int flags;

            /// <summary>
            /// Filter initialization function.
            /// 
            /// This callback will be called only once during the filter lifetime,
            /// after
            /// all the options have been set, but before links between filters are
            /// established and format negotiation is done.
            /// 
            /// Basic filter initialization should be done here. Filters with dynamic
            /// inputs and/or outputs should create those inputs/outputs here based on
            /// provided options. No more changes to this filter's inputs/outputs can
            /// be
            /// done after this callback.
            /// 
            /// This callback must not assume that the filter links exist or frame
            /// parameters are known.
            /// 
            /// @ref AVFilter.uninit "uninit" is guaranteed to be called even if
            /// initialization fails, so this callback does not have to clean up on
            /// failure.
            /// </summary>
            /// <returns>
            /// 0 on success, a negative AVERROR on failure
            /// </returns>
            public global::System.IntPtr init;

            /// <summary>
            /// Should be set instead of @ref AVFilter.init "init" by the filters that
            /// want to pass a dictionary of AVOptions to nested contexts that are
            /// allocated during init.
            /// 
            /// On return, the options dict should be freed and replaced with one that
            /// contains all the options which could not be processed by this filter
            /// (or
            /// with NULL if all the options were processed).
            /// 
            /// Otherwise the semantics is the same as for @ref AVFilter.init "init".
            /// </summary>
            public global::System.IntPtr init_dict;

            /// <summary>
            /// Filter uninitialization function.
            /// 
            /// Called only once right before the filter is freed. Should deallocate
            /// any
            /// memory held by the filter, release any buffer references, etc. It does
            /// not need to deallocate the AVFilterContext.priv memory itself.
            /// 
            /// This callback may be called even if @ref AVFilter.init "init" was not
            /// called or failed, so it must be prepared to handle such a situation.
            /// </summary>
            public global::System.IntPtr uninit;

            /// <summary>
            /// Query formats supported by the filter on its inputs and outputs.
            /// 
            /// This callback is called after the filter is initialized (so the inputs
            /// and outputs are fixed), shortly before the format negotiation. This
            /// callback may be called more than once.
            /// 
            /// This callback must set AVFilterLink.out_formats on every input link and
            /// AVFilterLink.in_formats on every output link to a list of pixel/sample
            /// formats that the filter supports on that link. For audio links, this
            /// filter must also set @ref AVFilterLink.in_samplerates "in_samplerates"
            /// @ref AVFilterLink.out_samplerates "out_samplerates" and
            /// @ref AVFilterLink.in_channel_layouts "in_channel_layouts"
            /// @ref AVFilterLink.out_channel_layouts "out_channel_layouts"
            /// analogously.
            /// 
            /// This callback may be NULL for filters with one input, in which case
            /// libavfilter assumes that it supports all input formats and preserves
            /// them on output.
            /// </summary>
            /// <returns>
            /// zero on success, a negative value corresponding to an
            /// AVERROR code otherwise
            /// </returns>
            public global::System.IntPtr query_formats;

            /// <summary>
            /// &lt; size of private data to allocate for the filter
            /// </summary>
            public int priv_size;

            /// <summary>
            /// Used by the filter registration system. Must not be touched by any
            /// other
            /// code.
            /// </summary>
            public libavfilter.AVFilter* next;

            /// <summary>
            /// Make the filter instance process a command.
            /// </summary>
            /// <param name="cmd">
            /// the command to process, for handling simplicity all commands must be
            /// alphanumeric only
            /// </param>
            /// <param name="arg">
            /// the argument for the command
            /// </param>
            /// <param name="res">
            /// a buffer with size res_size where the filter(s) can return a response.
            /// This must not change when the command is not supported.
            /// </param>
            /// <param name="flags">
            /// if AVFILTER_CMD_FLAG_FAST is set and the command would be
            /// time consuming then a filter should treat it like an unsupported
            /// command
            /// </param>
            /// <returns>
            /// s &gt;=0 on success otherwise an error code.
            /// AVERROR(ENOSYS) on unsupported commands
            /// </returns>
            public global::System.IntPtr process_command;

            /// <summary>
            /// Filter initialization function, alternative to the init()
            /// callback. Args contains the user-supplied parameters, opaque is
            /// used for providing binary data.
            /// </summary>
            public global::System.IntPtr init_opaque;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterInternal
        {
        }

        /// <summary>
        /// An instance of a filter
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterContext
        {
            /// <summary>
            /// &lt; needed for av_log() and filters common options
            /// </summary>
            public libavutil.AVClass* av_class;

            /// <summary>
            /// &lt; the AVFilter of which this is an instance
            /// </summary>
            public libavfilter.AVFilter* filter;

            /// <summary>
            /// &lt; name of this filter instance
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// &lt; array of input pads
            /// </summary>
            public libavfilter.AVFilterPad* input_pads;

            /// <summary>
            /// &lt; array of pointers to input links
            /// </summary>
            public libavfilter.AVFilterLink** inputs;

            /// <summary>
            /// &lt; number of input pads
            /// </summary>
            public uint nb_inputs;

            /// <summary>
            /// &lt; array of output pads
            /// </summary>
            public libavfilter.AVFilterPad* output_pads;

            /// <summary>
            /// &lt; array of pointers to output links
            /// </summary>
            public libavfilter.AVFilterLink** outputs;

            /// <summary>
            /// &lt; number of output pads
            /// </summary>
            public uint nb_outputs;

            /// <summary>
            /// &lt; private data for use by the filter
            /// </summary>
            public void* priv;

            /// <summary>
            /// &lt; filtergraph this filter belongs to
            /// </summary>
            public libavfilter.AVFilterGraph* graph;

            /// <summary>
            /// Type of multithreading being allowed/used. A combination of
            /// AVFILTER_THREAD_* flags.
            /// 
            /// May be set by the caller before initializing the filter to forbid some
            /// or all kinds of multithreading for this filter. The default is allowing
            /// everything.
            /// 
            /// When the filter is initialized, this field is combined using bit AND
            /// with
            /// AVFilterGraph.thread_type to get the final mask used for determining
            /// allowed threading types. I.e. a threading type needs to be set in both
            /// to be allowed.
            /// 
            /// After the filter is initialized, libavfilter sets this field to the
            /// threading type that is actually used (0 for no multithreading).
            /// </summary>
            public int thread_type;

            /// <summary>
            /// An opaque struct for libavfilter internal use.
            /// </summary>
            public libavfilter.AVFilterInternal* @internal;

            public libavfilter.AVFilterCommand* command_queue;

            /// <summary>
            /// &lt; enable expression string
            /// </summary>
            public sbyte* enable_str;

            /// <summary>
            /// &lt; parsed expression (AVExpr*)
            /// </summary>
            public void* enable;

            /// <summary>
            /// &lt; variable values for the enable expression
            /// </summary>
            public double* var_values;

            /// <summary>
            /// &lt; the enabled state from the last expression evaluation
            /// </summary>
            public int is_disabled;

            /// <summary>
            /// For filters which will create hardware frames, sets the device the
            /// filter should create them in.  All other filters will ignore this
            /// field:
            /// in particular, a filter which consumes or processes hardware frames
            /// will
            /// instead use the hw_frames_ctx field in AVFilterLink to carry the
            /// hardware context information.
            /// </summary>
            public libavutil.AVBufferRef* hw_device_ctx;
        }

        /// <summary>
        /// A link between two filters. This contains pointers to the source and
        /// destination filters between which this link exists, and the indexes of
        /// the pads involved. In addition, this link also contains the parameters
        /// which have been negotiated and agreed upon between the filter, such as
        /// image dimensions, format, etc.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterLink
        {
            /// <summary>
            /// &lt; source filter
            /// </summary>
            public libavfilter.AVFilterContext* src;

            /// <summary>
            /// &lt; output pad on the source filter
            /// </summary>
            public libavfilter.AVFilterPad* srcpad;

            /// <summary>
            /// &lt; dest filter
            /// </summary>
            public libavfilter.AVFilterContext* dst;

            /// <summary>
            /// &lt; input pad on the dest filter
            /// </summary>
            public libavfilter.AVFilterPad* dstpad;

            /// <summary>
            /// &lt; filter media type
            /// </summary>
            public libavutil.AVMediaType type;

            /// <summary>
            /// &lt; agreed upon image width
            /// </summary>
            public int w;

            /// <summary>
            /// &lt; agreed upon image height
            /// </summary>
            public int h;

            /// <summary>
            /// &lt; agreed upon sample aspect ratio
            /// </summary>
            public libavutil.AVRational sample_aspect_ratio;

            /// <summary>
            /// &lt; channel layout of current buffer (see libavutil/channel_layout.h)
            /// </summary>
            public ulong channel_layout;

            /// <summary>
            /// &lt; samples per second
            /// </summary>
            public int sample_rate;

            /// <summary>
            /// &lt; agreed upon media format
            /// </summary>
            public int format;

            /// <summary>
            /// Define the time base used by the PTS of the frames/samples
            /// which will pass through this link.
            /// During the configuration stage, each filter is supposed to
            /// change only the output timebase, while the timebase of the
            /// input link is assumed to be an unchangeable property.
            /// </summary>
            public libavutil.AVRational time_base;

            /// <summary>
            /// 
            /// All fields below this line are not part of the public API. They
            /// may not be used outside of libavfilter and can be changed and
            /// removed at will.
            /// New public fields should be added right above.
            /// 
            /// 
            /// 
            /// Lists of formats and channel layouts supported by the input and output
            /// filters respectively. These lists are used for negotiating the format
            /// to actually be used, which will be loaded into the format and
            /// channel_layout members, above, when chosen.
            /// </summary>
            public libavfilter.AVFilterFormats* in_formats;

            public libavfilter.AVFilterFormats* out_formats;

            /// <summary>
            /// Lists of channel layouts and sample rates used for automatic
            /// negotiation.
            /// </summary>
            public libavfilter.AVFilterFormats* in_samplerates;

            public libavfilter.AVFilterFormats* out_samplerates;

            public libavfilter.AVFilterChannelLayouts* in_channel_layouts;

            public libavfilter.AVFilterChannelLayouts* out_channel_layouts;

            /// <summary>
            /// Audio only, the destination filter sets this to a non-zero value to
            /// request that buffers with the given number of samples should be sent to
            /// it. AVFilterPad.needs_fifo must also be set on the corresponding input
            /// pad.
            /// Last buffer before EOF will be padded with silence.
            /// </summary>
            public int request_samples;

            public libavfilter.AVFilterLink.AVLINK init_state;

            /// <summary>
            /// Graph the filter belongs to.
            /// </summary>
            public libavfilter.AVFilterGraph* graph;

            /// <summary>
            /// Current timestamp of the link, as defined by the most recent
            /// frame(s), in link time_base units.
            /// </summary>
            public long current_pts;

            /// <summary>
            /// Current timestamp of the link, as defined by the most recent
            /// frame(s), in AV_TIME_BASE units.
            /// </summary>
            public long current_pts_us;

            /// <summary>
            /// Index in the age array.
            /// </summary>
            public int age_index;

            /// <summary>
            /// Frame rate of the stream on the link, or 1/0 if unknown or variable;
            /// if left to 0/0, will be automatically copied from the first input
            /// of the source filter if it exists.
            /// 
            /// Sources should set it to the best estimation of the real frame rate.
            /// If the source frame rate is unknown or variable, set this to 1/0.
            /// Filters should update it if necessary depending on their function.
            /// Sinks can use it to set a default output frame rate.
            /// It is similar to the r_frame_rate field in AVStream.
            /// </summary>
            public libavutil.AVRational frame_rate;

            /// <summary>
            /// Buffer partially filled with samples to achieve a fixed/minimum size.
            /// </summary>
            public libavutil.AVFrame* partial_buf;

            /// <summary>
            /// Size of the partial buffer to allocate.
            /// Must be between min_samples and max_samples.
            /// </summary>
            public int partial_buf_size;

            /// <summary>
            /// Minimum number of samples to filter at once. If filter_frame() is
            /// called with fewer samples, it will accumulate them in partial_buf.
            /// This field and the related ones must not be changed after filtering
            /// has started.
            /// If 0, all related fields are ignored.
            /// </summary>
            public int min_samples;

            /// <summary>
            /// Maximum number of samples to filter at once. If filter_frame() is
            /// called with more samples, it will split them.
            /// </summary>
            public int max_samples;

            /// <summary>
            /// Link status.
            /// If not zero, all attempts of filter_frame or request_frame
            /// will fail with the corresponding code, and if necessary the reference
            /// will be destroyed.
            /// If request_frame returns an error, the status is set on the
            /// corresponding link.
            /// It can be set also be set by either the source or the destination
            /// filter.
            /// </summary>
            public int status;

            /// <summary>
            /// Number of channels.
            /// </summary>
            public int channels;

            /// <summary>
            /// Link processing flags.
            /// </summary>
            public uint flags;

            /// <summary>
            /// Number of past frames sent through the link.
            /// </summary>
            public long frame_count;

            /// <summary>
            /// A pointer to a FFVideoFramePool struct.
            /// </summary>
            public void* video_frame_pool;

            /// <summary>
            /// True if a frame is currently wanted on the input of this filter.
            /// Set when ff_request_frame() is called by the output,
            /// cleared when the request is handled or forwarded.
            /// </summary>
            public int frame_wanted_in;

            /// <summary>
            /// True if a frame is currently wanted on the output of this filter.
            /// Set when ff_request_frame() is called by the output,
            /// cleared when a frame is filtered.
            /// </summary>
            public int frame_wanted_out;

            /// <summary>
            /// For hwaccel pixel formats, this should be a reference to the
            /// AVHWFramesContext describing the frames.
            /// </summary>
            public libavutil.AVBufferRef* hw_frames_ctx;

            /// <summary>
            /// stage of the initialization of the link properties (dimensions, etc)
            /// </summary>
            public enum AVLINK
            {
                /// <summary>not started</summary>
                AVLINK_UNINIT = 0,
                /// <summary>started, but incomplete</summary>
                AVLINK_STARTINIT = 1,
                /// <summary>complete</summary>
                AVLINK_INIT = 2
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterGraphInternal
        {
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterGraph
        {
            public libavutil.AVClass* av_class;

            public libavfilter.AVFilterContext** filters;

            public uint nb_filters;

            /// <summary>
            /// &lt; sws options to use for the auto-inserted scale filters
            /// </summary>
            public sbyte* scale_sws_opts;

            /// <summary>
            /// &lt; libavresample options to use for the auto-inserted resample
            /// filters
            /// </summary>
            public sbyte* resample_lavr_opts;

            /// <summary>
            /// Type of multithreading allowed for filters in this graph. A combination
            /// of AVFILTER_THREAD_* flags.
            /// 
            /// May be set by the caller at any point, the setting will apply to all
            /// filters initialized after that. The default is allowing everything.
            /// 
            /// When a filter in this graph is initialized, this field is combined
            /// using
            /// bit AND with AVFilterContext.thread_type to get the final mask used for
            /// determining allowed threading types. I.e. a threading type needs to be
            /// set in both to be allowed.
            /// </summary>
            public int thread_type;

            /// <summary>
            /// Maximum number of threads used by filters in this graph. May be set by
            /// the caller before adding any filters to the filtergraph. Zero (the
            /// default) means that the number of threads is determined automatically.
            /// </summary>
            public int nb_threads;

            /// <summary>
            /// Opaque object for libavfilter internal use.
            /// </summary>
            public libavfilter.AVFilterGraphInternal* @internal;

            /// <summary>
            /// Opaque user data. May be set by the caller to an arbitrary value, e.g.
            /// to
            /// be used from callbacks like @ref AVFilterGraph.execute.
            /// Libavfilter will not touch this field in any way.
            /// </summary>
            public void* opaque;

            /// <summary>
            /// This callback may be set by the caller immediately after allocating the
            /// graph and before adding any filters to it, to provide a custom
            /// multithreading implementation.
            /// 
            /// If set, filters with slice threading capability will call this callback
            /// to execute multiple jobs in parallel.
            /// 
            /// If this field is left unset, libavfilter will use its internal
            /// implementation, which may or may not be multithreaded depending on the
            /// platform and build options.
            /// </summary>
            public global::System.IntPtr execute;

            /// <summary>
            /// &lt; swr options to use for the auto-inserted aresample filters, Access
            /// ONLY through AVOptions
            /// </summary>
            public sbyte* aresample_swr_opts;

            /// <summary>
            /// Private fields
            /// 
            /// The following fields are for internal use only.
            /// Their type, offset, number and semantic can change without notice.
            /// </summary>
            public libavfilter.AVFilterLink** sink_links;

            public int sink_links_count;

            public uint disable_auto_convert;
        }

        /// <summary>
        /// A linked-list of the inputs/outputs of the filter chain.
        /// 
        /// This is mainly useful for avfilter_graph_parse() /
        /// avfilter_graph_parse2(),
        /// where it is used to communicate open (unlinked) inputs and outputs from
        /// and
        /// to the caller.
        /// This struct specifies, per each not connected pad contained in the
        /// graph, the
        /// filter context and the pad index required for establishing a link.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVFilterInOut
        {
            /// <summary>
            /// unique name for this input/output in the list
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// filter context associated to this input/output
            /// </summary>
            public libavfilter.AVFilterContext* filter_ctx;

            /// <summary>
            /// index of the filt_ctx pad to use for linking
            /// </summary>
            public int pad_idx;

            /// <summary>
            /// next input/input in the list, NULL if this is the last
            /// </summary>
            public libavfilter.AVFilterInOut* next;
        }

        /// <summary>
        /// Return the LIBAVFILTER_VERSION_INT constant.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_version")]
        public static extern uint avfilter_version();

        /// <summary>
        /// Return the libavfilter build-time configuration.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_configuration")]
        public static extern sbyte* avfilter_configuration();

        /// <summary>
        /// Return the libavfilter license.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_license")]
        public static extern sbyte* avfilter_license();

        /// <summary>
        /// Get the number of elements in a NULL-terminated array of AVFilterPads
        /// (e.g.
        /// AVFilter.inputs/outputs).
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_pad_count")]
        public static extern int avfilter_pad_count(libavfilter.AVFilterPad* pads);

        /// <summary>
        /// Get the name of an AVFilterPad.
        /// </summary>
        /// <param name="pads">
        /// an array of AVFilterPads
        /// </param>
        /// <param name="pad_idx">
        /// index of the pad in the array it; is the caller's
        /// responsibility to ensure the index is valid
        /// </param>
        /// <returns>
        /// name of the pad_idx'th pad in pads
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_pad_get_name")]
        public static extern sbyte* avfilter_pad_get_name(libavfilter.AVFilterPad* pads, int pad_idx);

        /// <summary>
        /// Get the type of an AVFilterPad.
        /// </summary>
        /// <param name="pads">
        /// an array of AVFilterPads
        /// </param>
        /// <param name="pad_idx">
        /// index of the pad in the array; it is the caller's
        /// responsibility to ensure the index is valid
        /// </param>
        /// <returns>
        /// type of the pad_idx'th pad in pads
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_pad_get_type")]
        public static extern libavutil.AVMediaType avfilter_pad_get_type(libavfilter.AVFilterPad* pads, int pad_idx);

        /// <summary>
        /// Link two filters together.
        /// </summary>
        /// <param name="src">
        /// the source filter
        /// </param>
        /// <param name="srcpad">
        /// index of the output pad on the source filter
        /// </param>
        /// <param name="dst">
        /// the destination filter
        /// </param>
        /// <param name="dstpad">
        /// index of the input pad on the destination filter
        /// </param>
        /// <returns>
        /// zero on success
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_link")]
        public static extern int avfilter_link(libavfilter.AVFilterContext* src, uint srcpad, libavfilter.AVFilterContext* dst, uint dstpad);

        /// <summary>
        /// Free the link in *link, and set its pointer to NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_link_free")]
        public static extern void avfilter_link_free(libavfilter.AVFilterLink** link);

        /// <summary>
        /// Free the link in *link, and set its pointer to NULL.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_link_free")]
        public static extern void avfilter_link_free(ref libavfilter.AVFilterLink* link);

        /// <summary>
        /// Get the number of channels of a link.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_link_get_channels")]
        public static extern int avfilter_link_get_channels(libavfilter.AVFilterLink* link);

        /// <summary>
        /// Set the closed field of a link.
        /// @deprecated applications are not supposed to mess with links, they
        /// should
        /// close the sinks.
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_link_set_closed")]
        public static extern void avfilter_link_set_closed(libavfilter.AVFilterLink* link, int closed);

        /// <summary>
        /// Negotiate the media format, dimensions, etc of all inputs to a filter.
        /// </summary>
        /// <param name="filter">
        /// the filter to negotiate the properties for its inputs
        /// </param>
        /// <returns>
        /// zero on successful negotiation
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_config_links")]
        public static extern int avfilter_config_links(libavfilter.AVFilterContext* filter);

        /// <summary>
        /// Make the filter instance process a command.
        /// It is recommended to use avfilter_graph_send_command().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_process_command")]
        public static extern int avfilter_process_command(libavfilter.AVFilterContext* filter, string cmd, string arg, System.Text.StringBuilder res, int res_len, int flags);

        /// <summary>
        /// Initialize the filter system. Register all builtin filters.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_register_all")]
        public static extern void avfilter_register_all();

        /// <summary>
        /// Uninitialize the filter system. Unregister all filters.
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_uninit")]
        public static extern void avfilter_uninit();

        /// <summary>
        /// Register a filter. This is only needed if you plan to use
        /// avfilter_get_by_name later to lookup the AVFilter structure by name. A
        /// filter can still by instantiated with avfilter_graph_alloc_filter even
        /// if it
        /// is not registered.
        /// </summary>
        /// <param name="filter">
        /// the filter to register
        /// </param>
        /// <returns>
        /// 0 if the registration was successful, a negative value
        /// otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_register")]
        public static extern int avfilter_register(libavfilter.AVFilter* filter);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_get_by_name")]
        public static extern libavfilter.AVFilter* avfilter_get_by_name(string name);

        /// <summary>
        /// Iterate over all registered filters.
        /// </summary>
        /// <returns>
        /// If prev is non-NULL, next registered filter after prev or NULL if
        /// prev is the last filter. If prev is NULL, return the first registered
        /// filter.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_next")]
        public static extern libavfilter.AVFilter* avfilter_next(libavfilter.AVFilter* prev);

        /// <summary>
        /// If filter is NULL, returns a pointer to the first registered filter
        /// pointer,
        /// if filter is non-NULL, returns the next pointer after filter.
        /// If the returned pointer points to NULL, the last registered filter
        /// was already reached.
        /// @deprecated use avfilter_next()
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_filter_next")]
        public static extern libavfilter.AVFilter** av_filter_next(libavfilter.AVFilter** filter);

        /// <summary>
        /// If filter is NULL, returns a pointer to the first registered filter
        /// pointer,
        /// if filter is non-NULL, returns the next pointer after filter.
        /// If the returned pointer points to NULL, the last registered filter
        /// was already reached.
        /// @deprecated use avfilter_next()
        /// </summary>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_filter_next")]
        public static extern libavfilter.AVFilter** av_filter_next(ref libavfilter.AVFilter* filter);

        /// <summary>
        /// Create a filter instance.
        /// </summary>
        /// <param name="filter_ctx">
        /// put here a pointer to the created filter context
        /// on success, NULL on failure
        /// </param>
        /// <param name="filter">
        /// the filter to create an instance of
        /// </param>
        /// <param name="inst_name">
        /// Name to give to the new instance. Can be NULL for none.
        /// </param>
        /// <returns>
        /// &gt;= 0 in case of success, a negative error code otherwise
        /// @deprecated use avfilter_graph_alloc_filter() instead
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_open")]
        public static extern int avfilter_open(libavfilter.AVFilterContext** filter_ctx, libavfilter.AVFilter* filter, string inst_name);

        /// <summary>
        /// Create a filter instance.
        /// </summary>
        /// <param name="filter_ctx">
        /// put here a pointer to the created filter context
        /// on success, NULL on failure
        /// </param>
        /// <param name="filter">
        /// the filter to create an instance of
        /// </param>
        /// <param name="inst_name">
        /// Name to give to the new instance. Can be NULL for none.
        /// </param>
        /// <returns>
        /// &gt;= 0 in case of success, a negative error code otherwise
        /// @deprecated use avfilter_graph_alloc_filter() instead
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_open")]
        public static extern int avfilter_open(ref libavfilter.AVFilterContext* filter_ctx, libavfilter.AVFilter* filter, string inst_name);

        /// <summary>
        /// Initialize a filter.
        /// </summary>
        /// <param name="filter">
        /// the filter to initialize
        /// </param>
        /// <param name="args">
        /// A string of parameters to use when initializing the filter.
        /// The format and meaning of this string varies by filter.
        /// </param>
        /// <param name="opaque">
        /// Any extra non-string data needed by the filter. The meaning
        /// of this parameter varies by filter.
        /// </param>
        /// <returns>
        /// zero on success
        /// </returns>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_init_filter")]
        public static extern int avfilter_init_filter(libavfilter.AVFilterContext* filter, string args, void* opaque);

        /// <summary>
        /// Initialize a filter with the supplied parameters.
        /// </summary>
        /// <param name="ctx">
        /// uninitialized filter context to initialize
        /// </param>
        /// <param name="args">
        /// Options to initialize the filter with. This must be a
        /// ':'-separated list of options in the 'key=value' form.
        /// May be NULL if the options have been set directly using the
        /// AVOptions API or there are no options that need to be set.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_init_str")]
        public static extern int avfilter_init_str(libavfilter.AVFilterContext* ctx, string args);

        /// <summary>
        /// Initialize a filter with the supplied dictionary of options.
        /// </summary>
        /// <param name="ctx">
        /// uninitialized filter context to initialize
        /// </param>
        /// <param name="options">
        /// An AVDictionary filled with options for this filter. On
        /// return this parameter will be destroyed and replaced with
        /// a dict containing options that were not found. This dictionary
        /// must be freed by the caller.
        /// May be NULL, then this function is equivalent to
        /// avfilter_init_str() with the second parameter set to NULL.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on failure
        /// </returns>
        /// <remark>
        /// This function and avfilter_init_str() do essentially the same thing,
        /// the difference is in manner in which the options are passed. It is up
        /// to the
        /// calling code to choose whichever is more preferable. The two functions
        /// also
        /// behave differently when some of the provided options are not declared
        /// as
        /// supported by the filter. In such a case, avfilter_init_str() will fail,
        /// but
        /// this function will leave those extra options in the options
        /// AVDictionary and
        /// continue as usual.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_init_dict")]
        public static extern int avfilter_init_dict(libavfilter.AVFilterContext* ctx, libavutil.AVDictionary** options);

        /// <summary>
        /// Initialize a filter with the supplied dictionary of options.
        /// </summary>
        /// <param name="ctx">
        /// uninitialized filter context to initialize
        /// </param>
        /// <param name="options">
        /// An AVDictionary filled with options for this filter. On
        /// return this parameter will be destroyed and replaced with
        /// a dict containing options that were not found. This dictionary
        /// must be freed by the caller.
        /// May be NULL, then this function is equivalent to
        /// avfilter_init_str() with the second parameter set to NULL.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on failure
        /// </returns>
        /// <remark>
        /// This function and avfilter_init_str() do essentially the same thing,
        /// the difference is in manner in which the options are passed. It is up
        /// to the
        /// calling code to choose whichever is more preferable. The two functions
        /// also
        /// behave differently when some of the provided options are not declared
        /// as
        /// supported by the filter. In such a case, avfilter_init_str() will fail,
        /// but
        /// this function will leave those extra options in the options
        /// AVDictionary and
        /// continue as usual.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_init_dict")]
        public static extern int avfilter_init_dict(libavfilter.AVFilterContext* ctx, ref libavutil.AVDictionary* options);

        /// <summary>
        /// Free a filter context. This will also remove the filter from its
        /// filtergraph's list of filters.
        /// </summary>
        /// <param name="filter">
        /// the filter to free
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_free")]
        public static extern void avfilter_free(libavfilter.AVFilterContext* filter);

        /// <summary>
        /// Insert a filter in the middle of an existing link.
        /// </summary>
        /// <param name="link">
        /// the link into which the filter should be inserted
        /// </param>
        /// <param name="filt">
        /// the filter to be inserted
        /// </param>
        /// <param name="filt_srcpad_idx">
        /// the input pad on the filter to connect
        /// </param>
        /// <param name="filt_dstpad_idx">
        /// the output pad on the filter to connect
        /// </param>
        /// <returns>
        /// zero on success
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_insert_filter")]
        public static extern int avfilter_insert_filter(libavfilter.AVFilterLink* link, libavfilter.AVFilterContext* filt, uint filt_srcpad_idx, uint filt_dstpad_idx);

        /// <summary>
        /// 
        /// </summary>
        /// <returns>
        /// AVClass for AVFilterContext.
        /// 
        /// @see av_opt_find().
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_get_class")]
        public static extern libavutil.AVClass* avfilter_get_class();

        /// <summary>
        /// Allocate a filter graph.
        /// </summary>
        /// <returns>
        /// the allocated filter graph on success or NULL.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_alloc")]
        public static extern libavfilter.AVFilterGraph* avfilter_graph_alloc();

        /// <summary>
        /// Create a new filter instance in a filter graph.
        /// </summary>
        /// <param name="graph">
        /// graph in which the new filter will be used
        /// </param>
        /// <param name="filter">
        /// the filter to create an instance of
        /// </param>
        /// <param name="name">
        /// Name to give to the new instance (will be copied to
        /// AVFilterContext.name). This may be used by the caller to identify
        /// different filters, libavfilter itself assigns no semantics to
        /// this parameter. May be NULL.
        /// </param>
        /// <returns>
        /// the context of the newly created filter instance (note that it is
        /// also retrievable directly through AVFilterGraph.filters or with
        /// avfilter_graph_get_filter()) on success or NULL on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_alloc_filter")]
        public static extern libavfilter.AVFilterContext* avfilter_graph_alloc_filter(libavfilter.AVFilterGraph* graph, libavfilter.AVFilter* filter, string name);

        /// <summary>
        /// Get a filter instance identified by instance name from graph.
        /// </summary>
        /// <param name="graph">
        /// filter graph to search through.
        /// </param>
        /// <param name="name">
        /// filter instance name (should be unique in the graph).
        /// </param>
        /// <returns>
        /// the pointer to the found filter instance or NULL if it
        /// cannot be found.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_get_filter")]
        public static extern libavfilter.AVFilterContext* avfilter_graph_get_filter(libavfilter.AVFilterGraph* graph, string name);

        /// <summary>
        /// Add an existing filter instance to a filter graph.
        /// </summary>
        /// <param name="graphctx">
        /// the filter graph
        /// </param>
        /// <param name="filter">
        /// the filter to be added
        /// 
        /// @deprecated use avfilter_graph_alloc_filter() to allocate a filter in a
        /// filter graph
        /// </param>
        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_add_filter")]
        public static extern int avfilter_graph_add_filter(libavfilter.AVFilterGraph* graphctx, libavfilter.AVFilterContext* filter);

        /// <summary>
        /// Create and add a filter instance into an existing graph.
        /// The filter instance is created from the filter filt and inited
        /// with the parameters args and opaque.
        /// 
        /// In case of success put in *filt_ctx the pointer to the created
        /// filter instance, otherwise set *filt_ctx to NULL.
        /// </summary>
        /// <param name="name">
        /// the instance name to give to the created filter instance
        /// </param>
        /// <param name="graph_ctx">
        /// the filter graph
        /// </param>
        /// <returns>
        /// a negative AVERROR error code in case of failure, a non
        /// negative value otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_create_filter")]
        public static extern int avfilter_graph_create_filter(libavfilter.AVFilterContext** filt_ctx, libavfilter.AVFilter* filt, string name, string args, void* opaque, libavfilter.AVFilterGraph* graph_ctx);

        /// <summary>
        /// Create and add a filter instance into an existing graph.
        /// The filter instance is created from the filter filt and inited
        /// with the parameters args and opaque.
        /// 
        /// In case of success put in *filt_ctx the pointer to the created
        /// filter instance, otherwise set *filt_ctx to NULL.
        /// </summary>
        /// <param name="name">
        /// the instance name to give to the created filter instance
        /// </param>
        /// <param name="graph_ctx">
        /// the filter graph
        /// </param>
        /// <returns>
        /// a negative AVERROR error code in case of failure, a non
        /// negative value otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_create_filter")]
        public static extern int avfilter_graph_create_filter(ref libavfilter.AVFilterContext* filt_ctx, libavfilter.AVFilter* filt, string name, string args, void* opaque, libavfilter.AVFilterGraph* graph_ctx);

        /// <summary>
        /// Enable or disable automatic format conversion inside the graph.
        /// 
        /// Note that format conversion can still happen inside explicitly inserted
        /// scale and aresample filters.
        /// </summary>
        /// <param name="flags">
        /// any of the AVFILTER_AUTO_CONVERT_* constants
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_set_auto_convert")]
        public static extern void avfilter_graph_set_auto_convert(libavfilter.AVFilterGraph* graph, uint flags);

        /// <summary>
        /// Check validity and configure all the links and formats in the graph.
        /// </summary>
        /// <param name="graphctx">
        /// the filter graph
        /// </param>
        /// <param name="log_ctx">
        /// context used for logging
        /// </param>
        /// <returns>
        /// &gt;= 0 in case of success, a negative AVERROR code otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_config")]
        public static extern int avfilter_graph_config(libavfilter.AVFilterGraph* graphctx, void* log_ctx);

        /// <summary>
        /// Free a graph, destroy its links, and set *graph to NULL.
        /// If *graph is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_free")]
        public static extern void avfilter_graph_free(libavfilter.AVFilterGraph** graph);

        /// <summary>
        /// Free a graph, destroy its links, and set *graph to NULL.
        /// If *graph is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_free")]
        public static extern void avfilter_graph_free(ref libavfilter.AVFilterGraph* graph);

        /// <summary>
        /// Allocate a single AVFilterInOut entry.
        /// Must be freed with avfilter_inout_free().
        /// </summary>
        /// <returns>
        /// allocated AVFilterInOut on success, NULL on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_inout_alloc")]
        public static extern libavfilter.AVFilterInOut* avfilter_inout_alloc();

        /// <summary>
        /// Free the supplied list of AVFilterInOut and set *inout to NULL.
        /// If *inout is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_inout_free")]
        public static extern void avfilter_inout_free(libavfilter.AVFilterInOut** inout);

        /// <summary>
        /// Free the supplied list of AVFilterInOut and set *inout to NULL.
        /// If *inout is NULL, do nothing.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_inout_free")]
        public static extern void avfilter_inout_free(ref libavfilter.AVFilterInOut* inout);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// </summary>
        /// <remark>
        /// The caller must provide the lists of inputs and outputs,
        /// which therefore must be known before calling the function.
        /// </remark>
        /// <remark>
        /// The inputs parameter describes inputs of the already existing
        /// part of the graph; i.e. from the point of view of the newly created
        /// part, they are outputs. Similarly the outputs parameter describes
        /// outputs of the already existing filters, which are provided as
        /// inputs to the parsed filters.
        /// </remark>
        /// <param name="graph">
        /// the filter graph where to link the parsed graph context
        /// </param>
        /// <param name="filters">
        /// string to be parsed
        /// </param>
        /// <param name="inputs">
        /// linked list to the inputs of the graph
        /// </param>
        /// <param name="outputs">
        /// linked list to the outputs of the graph
        /// </param>
        /// <returns>
        /// zero on success, a negative AVERROR code on error
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse")]
        public static extern int avfilter_graph_parse(libavfilter.AVFilterGraph* graph, string filters, libavfilter.AVFilterInOut* inputs, libavfilter.AVFilterInOut* outputs, void* log_ctx);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// 
        /// In the graph filters description, if the input label of the first
        /// filter is not specified, "in" is assumed; if the output label of
        /// the last filter is not specified, "out" is assumed.
        /// </summary>
        /// <param name="graph">
        /// the filter graph where to link the parsed graph context
        /// </param>
        /// <param name="filters">
        /// string to be parsed
        /// </param>
        /// <param name="inputs">
        /// pointer to a linked list to the inputs of the graph, may be NULL.
        /// If non-NULL, *inputs is updated to contain the list of open inputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <param name="outputs">
        /// pointer to a linked list to the outputs of the graph, may be NULL.
        /// If non-NULL, *outputs is updated to contain the list of open outputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <returns>
        /// non negative on success, a negative AVERROR code on error
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse_ptr")]
        public static extern int avfilter_graph_parse_ptr(libavfilter.AVFilterGraph* graph, string filters, libavfilter.AVFilterInOut** inputs, libavfilter.AVFilterInOut** outputs, void* log_ctx);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// 
        /// In the graph filters description, if the input label of the first
        /// filter is not specified, "in" is assumed; if the output label of
        /// the last filter is not specified, "out" is assumed.
        /// </summary>
        /// <param name="graph">
        /// the filter graph where to link the parsed graph context
        /// </param>
        /// <param name="filters">
        /// string to be parsed
        /// </param>
        /// <param name="inputs">
        /// pointer to a linked list to the inputs of the graph, may be NULL.
        /// If non-NULL, *inputs is updated to contain the list of open inputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <param name="outputs">
        /// pointer to a linked list to the outputs of the graph, may be NULL.
        /// If non-NULL, *outputs is updated to contain the list of open outputs
        /// after the parsing, should be freed with avfilter_inout_free().
        /// </param>
        /// <returns>
        /// non negative on success, a negative AVERROR code on error
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse_ptr")]
        public static extern int avfilter_graph_parse_ptr(libavfilter.AVFilterGraph* graph, string filters, ref libavfilter.AVFilterInOut* inputs, ref libavfilter.AVFilterInOut* outputs, void* log_ctx);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// </summary>
        /// <param name="[in]">
        /// graph   the filter graph where to link the parsed graph context
        /// </param>
        /// <param name="[in]">
        /// filters string to be parsed
        /// </param>
        /// <param name="[out]">
        /// inputs  a linked list of all free (unlinked) inputs of the
        /// parsed graph will be returned here. It is to be freed
        /// by the caller using avfilter_inout_free().
        /// </param>
        /// <param name="[out]">
        /// outputs a linked list of all free (unlinked) outputs of the
        /// parsed graph will be returned here. It is to be freed by the
        /// caller using avfilter_inout_free().
        /// </param>
        /// <returns>
        /// zero on success, a negative AVERROR code on error
        /// </returns>
        /// <remark>
        /// This function returns the inputs and outputs that are left
        /// unlinked after parsing the graph and the caller then deals with
        /// them.
        /// </remark>
        /// <remark>
        /// This function makes no reference whatsoever to already
        /// existing parts of the graph and the inputs parameter will on return
        /// contain inputs of the newly parsed part of the graph.  Analogously
        /// the outputs parameter will contain outputs of the newly created
        /// filters.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse2")]
        public static extern int avfilter_graph_parse2(libavfilter.AVFilterGraph* graph, string filters, libavfilter.AVFilterInOut** inputs, libavfilter.AVFilterInOut** outputs);

        /// <summary>
        /// Add a graph described by a string to a graph.
        /// </summary>
        /// <param name="[in]">
        /// graph   the filter graph where to link the parsed graph context
        /// </param>
        /// <param name="[in]">
        /// filters string to be parsed
        /// </param>
        /// <param name="[out]">
        /// inputs  a linked list of all free (unlinked) inputs of the
        /// parsed graph will be returned here. It is to be freed
        /// by the caller using avfilter_inout_free().
        /// </param>
        /// <param name="[out]">
        /// outputs a linked list of all free (unlinked) outputs of the
        /// parsed graph will be returned here. It is to be freed by the
        /// caller using avfilter_inout_free().
        /// </param>
        /// <returns>
        /// zero on success, a negative AVERROR code on error
        /// </returns>
        /// <remark>
        /// This function returns the inputs and outputs that are left
        /// unlinked after parsing the graph and the caller then deals with
        /// them.
        /// </remark>
        /// <remark>
        /// This function makes no reference whatsoever to already
        /// existing parts of the graph and the inputs parameter will on return
        /// contain inputs of the newly parsed part of the graph.  Analogously
        /// the outputs parameter will contain outputs of the newly created
        /// filters.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_parse2")]
        public static extern int avfilter_graph_parse2(libavfilter.AVFilterGraph* graph, string filters, ref libavfilter.AVFilterInOut* inputs, ref libavfilter.AVFilterInOut* outputs);

        /// <summary>
        /// Send a command to one or more filter instances.
        /// </summary>
        /// <param name="graph">
        /// the filter graph
        /// </param>
        /// <param name="target">
        /// the filter(s) to which the command should be sent
        /// "all" sends to all filters
        /// otherwise it can be a filter or filter instance name
        /// which will send the command to all matching filters.
        /// </param>
        /// <param name="cmd">
        /// the command to send, for handling simplicity all commands must be
        /// alphanumeric only
        /// </param>
        /// <param name="arg">
        /// the argument for the command
        /// </param>
        /// <param name="res">
        /// a buffer with size res_size where the filter(s) can return a response.
        /// </param>
        /// <returns>
        /// s &gt;=0 on success otherwise an error code.
        /// AVERROR(ENOSYS) on unsupported commands
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_send_command")]
        public static extern int avfilter_graph_send_command(libavfilter.AVFilterGraph* graph, string target, string cmd, string arg, System.Text.StringBuilder res, int res_len, int flags);

        /// <summary>
        /// Queue a command for one or more filter instances.
        /// </summary>
        /// <param name="graph">
        /// the filter graph
        /// </param>
        /// <param name="target">
        /// the filter(s) to which the command should be sent
        /// "all" sends to all filters
        /// otherwise it can be a filter or filter instance name
        /// which will send the command to all matching filters.
        /// </param>
        /// <param name="cmd">
        /// the command to sent, for handling simplicity all commands must be
        /// alphanumeric only
        /// </param>
        /// <param name="arg">
        /// the argument for the command
        /// </param>
        /// <param name="ts">
        /// time at which the command should be sent to the filter
        /// </param>
        /// <remark>
        /// As this executes commands after this function returns, no return code
        /// from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not
        /// supported.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_queue_command")]
        public static extern int avfilter_graph_queue_command(libavfilter.AVFilterGraph* graph, string target, string cmd, string arg, int flags, double ts);

        /// <summary>
        /// Dump a graph into a human-readable string representation.
        /// </summary>
        /// <param name="graph">
        /// the graph to dump
        /// </param>
        /// <param name="options">
        /// formatting options; currently ignored
        /// </param>
        /// <returns>
        /// a string, or NULL in case of memory allocation failure;
        /// the string must be freed using av_free
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_dump")]
        public static extern sbyte* avfilter_graph_dump(libavfilter.AVFilterGraph* graph, string options);

        /// <summary>
        /// Request a frame on the oldest sink link.
        /// 
        /// If the request returns AVERROR_EOF, try the next.
        /// 
        /// Note that this function is not meant to be the sole scheduling
        /// mechanism
        /// of a filtergraph, only a convenience function to help drain a
        /// filtergraph
        /// in a balanced way under normal circumstances.
        /// 
        /// Also note that AVERROR_EOF does not mean that frames did not arrive on
        /// some of the sinks during the process.
        /// When there are multiple sink links, in case the requested link
        /// returns an EOF, this may cause a filter to flush pending frames
        /// which are sent to another sink link, although unrequested.
        /// </summary>
        /// <returns>
        /// the return value of ff_request_frame(),
        /// or AVERROR_EOF if all links returned AVERROR_EOF
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avfilter_graph_request_oldest")]
        public static extern int avfilter_graph_request_oldest(libavfilter.AVFilterGraph* graph);
    }
}
