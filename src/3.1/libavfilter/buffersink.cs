//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
// ReSharper disable RedundantUsingDirective
// ReSharper disable CheckNamespace
#pragma warning disable 1584,1711,1572,1581,1580,1573
using System;
using System.Runtime.InteropServices;
using System.Security;
using FFmpeg;

namespace FFmpeg
{
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "UnusedMember.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "InconsistentNaming")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantUnsafeContext")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "FieldCanBeMadeReadOnly.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "PartialTypeWithSinglePart")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantNameQualifier")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "ArrangeModifiersOrder")]
    public unsafe static partial class libavfilter
    {
        public const sbyte AV_BUFFERSINK_FLAG_PEEK = 1;

        public const sbyte AV_BUFFERSINK_FLAG_NO_REQUEST = 2;

        /// <summary>
        /// Struct to use for initializing a buffersink context.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVBufferSinkParams
        {
            /// <summary>
            /// &lt; list of allowed pixel formats, terminated by AV_PIX_FMT_NONE
            /// </summary>
            public libavutil.AVPixelFormat* pixel_fmts;
        }

        /// <summary>
        /// Struct to use for initializing an abuffersink context.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVABufferSinkParams
        {
            /// <summary>
            /// &lt; list of allowed sample formats, terminated by AV_SAMPLE_FMT_NONE
            /// </summary>
            public libavutil.AVSampleFormat* sample_fmts;

            /// <summary>
            /// &lt; list of allowed channel layouts, terminated by -1
            /// </summary>
            public long* channel_layouts;

            /// <summary>
            /// &lt; list of allowed channel counts, terminated by -1
            /// </summary>
            public int* channel_counts;

            /// <summary>
            /// &lt; if not 0, accept any channel count or layout
            /// </summary>
            public int all_channel_counts;

            /// <summary>
            /// &lt; list of allowed sample rates, terminated by -1
            /// </summary>
            public int* sample_rates;
        }

        /// <summary>
        /// Get a frame with filtered data from sink and put it in frame.
        /// </summary>
        /// <param name="ctx">
        /// pointer to a buffersink or abuffersink filter context.
        /// </param>
        /// <param name="frame">
        /// pointer to an allocated frame that will be filled with data.
        /// The data must be freed using av_frame_unref() / av_frame_free()
        /// </param>
        /// <param name="flags">
        /// a combination of AV_BUFFERSINK_FLAG_* flags
        /// </param>
        /// <returns>
        /// &gt;= 0 in for success, a negative AVERROR code for failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersink_get_frame_flags")]
        public static extern int av_buffersink_get_frame_flags(libavfilter.AVFilterContext* ctx, libavutil.AVFrame* frame, int flags);

        /// <summary>
        /// Create an AVBufferSinkParams structure.
        /// 
        /// Must be freed with av_free().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersink_params_alloc")]
        public static extern libavfilter.AVBufferSinkParams* av_buffersink_params_alloc();

        /// <summary>
        /// Create an AVABufferSinkParams structure.
        /// 
        /// Must be freed with av_free().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_abuffersink_params_alloc")]
        public static extern libavfilter.AVABufferSinkParams* av_abuffersink_params_alloc();

        /// <summary>
        /// Set the frame size for an audio buffer sink.
        /// 
        /// All calls to av_buffersink_get_buffer_ref will return a buffer with
        /// exactly the specified number of samples, or AVERROR(EAGAIN) if there is
        /// not enough. The last buffer at EOF will be padded with 0.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersink_set_frame_size")]
        public static extern void av_buffersink_set_frame_size(libavfilter.AVFilterContext* ctx, uint frame_size);

        /// <summary>
        /// Get the frame rate of the input.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersink_get_frame_rate")]
        public static extern libavutil.AVRational av_buffersink_get_frame_rate(libavfilter.AVFilterContext* ctx);

        /// <summary>
        /// Get a frame with filtered data from sink and put it in frame.
        /// </summary>
        /// <param name="ctx">
        /// pointer to a context of a buffersink or abuffersink AVFilter.
        /// </param>
        /// <param name="frame">
        /// pointer to an allocated frame that will be filled with data.
        /// The data must be freed using av_frame_unref() / av_frame_free()
        /// </param>
        /// <returns>
        /// - &gt;= 0 if a frame was successfully returned.
        /// - AVERROR(EAGAIN) if no frames are available at this point; more
        /// input frames must be added to the filtergraph to get more output.
        /// - AVERROR_EOF if there will be no more output frames on this sink.
        /// - A different negative AVERROR code in other failure cases.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersink_get_frame")]
        public static extern int av_buffersink_get_frame(libavfilter.AVFilterContext* ctx, libavutil.AVFrame* frame);

        /// <summary>
        /// Same as av_buffersink_get_frame(), but with the ability to specify the
        /// number
        /// of samples read. This function is less efficient than
        /// av_buffersink_get_frame(), because it copies the data around.
        /// </summary>
        /// <param name="ctx">
        /// pointer to a context of the abuffersink AVFilter.
        /// </param>
        /// <param name="frame">
        /// pointer to an allocated frame that will be filled with data.
        /// The data must be freed using av_frame_unref() / av_frame_free()
        /// frame will contain exactly nb_samples audio samples, except at
        /// the end of stream, when it can contain less than nb_samples.
        /// </param>
        /// <returns>
        /// The return codes have the same meaning as for
        /// av_buffersink_get_samples().
        /// 
        /// @warning do not mix this function with av_buffersink_get_frame(). Use
        /// only one or
        /// the other with a single sink, not both.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersink_get_samples")]
        public static extern int av_buffersink_get_samples(libavfilter.AVFilterContext* ctx, libavutil.AVFrame* frame, int nb_samples);
    }
}
