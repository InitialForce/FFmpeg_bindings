//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
// ReSharper disable RedundantUsingDirective
// ReSharper disable CheckNamespace
#pragma warning disable 1584,1711,1572,1581,1580,1573
using System;
using System.Runtime.InteropServices;
using System.Security;
using FFmpeg;

namespace FFmpeg
{
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "UnusedMember.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "InconsistentNaming")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantUnsafeContext")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "FieldCanBeMadeReadOnly.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "PartialTypeWithSinglePart")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantNameQualifier")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "ArrangeModifiersOrder")]
    public unsafe static partial class libavfilter
    {
        /// <summary>
        /// @defgroup lavfi_buffersrc Buffer source API
        /// @ingroup lavfi
        /// @{
        /// </summary>
        [Flags]
        public enum AV_BUFFERSRC_FLAG
        {
            /// <summary>Do not check for format changes.</summary>
            AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1,
            /// <summary>Immediately push the frame to the output.</summary>
            AV_BUFFERSRC_FLAG_PUSH = 4,
            /// <summary>Keep a reference to the frame. If the frame if reference-counted, create a new reference; otherwise copy the frame data.</summary>
            AV_BUFFERSRC_FLAG_KEEP_REF = 8
        }

        /// <summary>
        /// This structure contains the parameters describing the frames that will
        /// be
        /// passed to this filter.
        /// 
        /// It should be allocated with av_buffersrc_parameters_alloc() and freed
        /// with
        /// av_free(). All the allocated fields in it remain owned by the caller.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVBufferSrcParameters
        {
            /// <summary>
            /// video: the pixel format, value corresponds to enum AVPixelFormat
            /// audio: the sample format, value corresponds to enum AVSampleFormat
            /// </summary>
            public int format;

            /// <summary>
            /// The timebase to be used for the timestamps on the input frames.
            /// </summary>
            public libavutil.AVRational time_base;

            /// <summary>
            /// Video only, the display dimensions of the input frames.
            /// </summary>
            public int width;

            /// <summary>
            /// Video only, the display dimensions of the input frames.
            /// </summary>
            public int height;

            /// <summary>
            /// Video only, the sample (pixel) aspect ratio.
            /// </summary>
            public libavutil.AVRational sample_aspect_ratio;

            /// <summary>
            /// Video only, the frame rate of the input video. This field must only be
            /// set to a non-zero value if input stream has a known constant framerate
            /// and should be left at its initial value if the framerate is variable or
            /// unknown.
            /// </summary>
            public libavutil.AVRational frame_rate;

            /// <summary>
            /// Video with a hwaccel pixel format only. This should be a reference to
            /// an
            /// AVHWFramesContext instance describing the input frames.
            /// </summary>
            public libavutil.AVBufferRef* hw_frames_ctx;

            /// <summary>
            /// Audio only, the audio sampling rate in samples per secon.
            /// </summary>
            public int sample_rate;

            /// <summary>
            /// Audio only, the audio channel layout
            /// </summary>
            public ulong channel_layout;
        }

        /// <summary>
        /// Get the number of failed requests.
        /// 
        /// A failed request is when the request_frame method is called while no
        /// frame is present in the buffer.
        /// The number is reset when a frame is added.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersrc_get_nb_failed_requests")]
        public static extern uint av_buffersrc_get_nb_failed_requests(libavfilter.AVFilterContext* buffer_src);

        /// <summary>
        /// Allocate a new AVBufferSrcParameters instance. It should be freed by
        /// the
        /// caller with av_free().
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersrc_parameters_alloc")]
        public static extern libavfilter.AVBufferSrcParameters* av_buffersrc_parameters_alloc();

        /// <summary>
        /// Initialize the buffersrc or abuffersrc filter with the provided
        /// parameters.
        /// This function may be called multiple times, the later calls override
        /// the
        /// previous ones. Some of the parameters may also be set through
        /// AVOptions, then
        /// whatever method is used last takes precedence.
        /// </summary>
        /// <param name="ctx">
        /// an instance of the buffersrc or abuffersrc filter
        /// </param>
        /// <param name="param">
        /// the stream parameters. The frames later passed to this filter
        /// must conform to those parameters. All the allocated fields in
        /// param remain owned by the caller, libavfilter will make internal
        /// copies or references when necessary.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR code on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersrc_parameters_set")]
        public static extern int av_buffersrc_parameters_set(libavfilter.AVFilterContext* ctx, libavfilter.AVBufferSrcParameters* param);

        /// <summary>
        /// Add a frame to the buffer source.
        /// </summary>
        /// <param name="ctx">
        /// an instance of the buffersrc filter
        /// </param>
        /// <param name="frame">
        /// frame to be added. If the frame is reference counted, this
        /// function will make a new reference to it. Otherwise the frame data will
        /// be
        /// copied.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on error
        /// 
        /// This function is equivalent to av_buffersrc_add_frame_flags() with the
        /// AV_BUFFERSRC_FLAG_KEEP_REF flag.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersrc_write_frame")]
        public static extern int av_buffersrc_write_frame(libavfilter.AVFilterContext* ctx, libavutil.AVFrame* frame);

        /// <summary>
        /// Add a frame to the buffer source.
        /// </summary>
        /// <param name="ctx">
        /// an instance of the buffersrc filter
        /// </param>
        /// <param name="frame">
        /// frame to be added. If the frame is reference counted, this
        /// function will take ownership of the reference(s) and reset the frame.
        /// Otherwise the frame data will be copied. If this function returns an
        /// error,
        /// the input frame is not touched.
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR on error.
        /// </returns>
        /// <remark>
        /// the difference between this function and av_buffersrc_write_frame() is
        /// that av_buffersrc_write_frame() creates a new reference to the input
        /// frame,
        /// while this function takes ownership of the reference passed to it.
        /// 
        /// This function is equivalent to av_buffersrc_add_frame_flags() without
        /// the
        /// AV_BUFFERSRC_FLAG_KEEP_REF flag.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersrc_add_frame")]
        public static extern int av_buffersrc_add_frame(libavfilter.AVFilterContext* ctx, libavutil.AVFrame* frame);

        /// <summary>
        /// Add a frame to the buffer source.
        /// 
        /// By default, if the frame is reference-counted, this function will take
        /// ownership of the reference(s) and reset the frame. This can be
        /// controlled
        /// using the flags.
        /// 
        /// If this function returns an error, the input frame is not touched.
        /// </summary>
        /// <param name="buffer_src">
        /// pointer to a buffer source context
        /// </param>
        /// <param name="frame">
        /// a frame, or NULL to mark EOF
        /// </param>
        /// <param name="flags">
        /// a combination of AV_BUFFERSRC_FLAG_
        /// </param>
        /// <returns>
        /// &gt;= 0 in case of success, a negative AVERROR code
        /// in case of failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFILTER_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_buffersrc_add_frame_flags")]
        public static extern int av_buffersrc_add_frame_flags(libavfilter.AVFilterContext* buffer_src, libavutil.AVFrame* frame, int flags);
    }
}
