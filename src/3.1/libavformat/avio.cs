//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
// ReSharper disable RedundantUsingDirective
// ReSharper disable CheckNamespace
#pragma warning disable 1584,1711,1572,1581,1580,1573
using System;
using System.Runtime.InteropServices;
using System.Security;
using FFmpeg;

namespace FFmpeg
{
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "UnusedMember.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "InconsistentNaming")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantUnsafeContext")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "FieldCanBeMadeReadOnly.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "PartialTypeWithSinglePart")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantNameQualifier")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "ArrangeModifiersOrder")]
    public unsafe static partial class libavformat
    {
        public const sbyte AVIO_SEEKABLE_NORMAL = 0x1;

        public const int AVSEEK_SIZE = 0x10000;

        public const int AVSEEK_FORCE = 0x20000;

        public const sbyte AVIO_FLAG_READ = 1;

        public const sbyte AVIO_FLAG_WRITE = 2;

        public const sbyte AVIO_FLAG_NONBLOCK = 8;

        public const ushort AVIO_FLAG_DIRECT = 0x8000;

        /// <summary>
        /// Directory entry types.
        /// </summary>
        public enum AVIODirEntryType
        {
            AVIO_ENTRY_UNKNOWN = 0,
            AVIO_ENTRY_BLOCK_DEVICE = 1,
            AVIO_ENTRY_CHARACTER_DEVICE = 2,
            AVIO_ENTRY_DIRECTORY = 3,
            AVIO_ENTRY_NAMED_PIPE = 4,
            AVIO_ENTRY_SYMBOLIC_LINK = 5,
            AVIO_ENTRY_SOCKET = 6,
            AVIO_ENTRY_FILE = 7,
            AVIO_ENTRY_SERVER = 8,
            AVIO_ENTRY_SHARE = 9,
            AVIO_ENTRY_WORKGROUP = 10
        }

        /// <summary>
        /// Different data types that can be returned via the AVIO
        /// write_data_type callback.
        /// </summary>
        public enum AVIODataMarkerType
        {
            /// <summary>Header data; this needs to be present for the stream to be decodeable.</summary>
            AVIO_DATA_MARKER_HEADER = 0,
            /// <summary>A point in the output bytestream where a decoder can start decoding (i.e. a keyframe). A demuxer/decoder given the data flagged with AVIO_DATA_MARKER_HEADER, followed by any AVIO_DATA_MARKER_SYNC_POINT, should give decodeable results.</summary>
            AVIO_DATA_MARKER_SYNC_POINT = 1,
            /// <summary>A point in the output bytestream where a demuxer can start parsing (for non self synchronizing bytestream formats). That is, any non-keyframe packet start point.</summary>
            AVIO_DATA_MARKER_BOUNDARY_POINT = 2,
            /// <summary>This is any, unlabelled data. It can either be a muxer not marking any positions at all, it can be an actual boundary/sync point that the muxer chooses not to mark, or a later part of a packet/fragment that is cut into multiple write callbacks due to limited IO buffer size.</summary>
            AVIO_DATA_MARKER_UNKNOWN = 3,
            /// <summary>Trailer data, which doesn't contain actual content, but only for finalizing the output file.</summary>
            AVIO_DATA_MARKER_TRAILER = 4
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct URLContext
        {
        }

        /// <summary>
        /// Callback for checking whether to abort blocking functions.
        /// AVERROR_EXIT is returned in this case by the interrupted
        /// function. During blocking operations, callback is called with
        /// opaque as parameter. If the callback returns 1, the
        /// blocking operation will be aborted.
        /// 
        /// No members can be added to this struct without a major bump, if
        /// new elements have been added after this struct in AVFormatContext
        /// or AVIOContext.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVIOInterruptCB
        {
            public global::System.IntPtr callback;

            public void* opaque;
        }

        /// <summary>
        /// Describes single entry of the directory.
        /// 
        /// Only name and type fields are guaranteed be set.
        /// Rest of fields are protocol or/and platform dependent and might be
        /// unknown.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVIODirEntry
        {
            /// <summary>
            /// &lt; Filename
            /// </summary>
            public sbyte* name;

            /// <summary>
            /// &lt; Type of the entry
            /// </summary>
            public int type;

            /// <summary>
            /// &lt; Set to 1 when name is encoded with UTF-8, 0 otherwise.
            /// Name can be encoded with UTF-8 even though 0 is set.
            /// </summary>
            public int utf8;

            /// <summary>
            /// &lt; File size in bytes, -1 if unknown.
            /// </summary>
            public long size;

            /// <summary>
            /// &lt; Time of last modification in microseconds since unix
            /// epoch, -1 if unknown.
            /// </summary>
            public long modification_timestamp;

            /// <summary>
            /// &lt; Time of last access in microseconds since unix epoch,
            /// -1 if unknown.
            /// </summary>
            public long access_timestamp;

            /// <summary>
            /// &lt; Time of last status change in microseconds since unix
            /// epoch, -1 if unknown.
            /// </summary>
            public long status_change_timestamp;

            /// <summary>
            /// &lt; User ID of owner, -1 if unknown.
            /// </summary>
            public long user_id;

            /// <summary>
            /// &lt; Group ID of owner, -1 if unknown.
            /// </summary>
            public long group_id;

            /// <summary>
            /// &lt; Unix file mode, -1 if unknown.
            /// </summary>
            public long filemode;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVIODirContext
        {
            public libavformat.URLContext* url_context;
        }

        /// <summary>
        /// Bytestream IO Context.
        /// New fields can be added to the end with minor version bumps.
        /// Removal, reordering and changes to existing fields require a major
        /// version bump.
        /// sizeof(AVIOContext) must not be used outside libav*.
        /// </summary>
        /// <remark>
        /// None of the function pointers in AVIOContext should be called
        /// directly, they should only be set by the client application
        /// when implementing custom I/O. Normally these are set to the
        /// function pointers specified in avio_alloc_context()
        /// </remark>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVIOContext
        {
            /// <summary>
            /// A class for private options.
            /// 
            /// If this AVIOContext is created by avio_open2(), av_class is set and
            /// passes the options down to protocols.
            /// 
            /// If this AVIOContext is manually allocated, then av_class may be set by
            /// the caller.
            /// 
            /// warning -- this field can be NULL, be sure to not pass this AVIOContext
            /// to any av_opt_* functions in that case.
            /// </summary>
            public libavutil.AVClass* av_class;

            /// <summary>
            /// &lt; Start of the buffer.
            /// </summary>
            public byte* buffer;

            /// <summary>
            /// &lt; Maximum buffer size
            /// </summary>
            public int buffer_size;

            /// <summary>
            /// &lt; Current position in the buffer
            /// </summary>
            public byte* buf_ptr;

            /// <summary>
            /// &lt; End of the data, may be less than
            /// buffer+buffer_size if the read function returned
            /// less data than requested, e.g. for streams where
            /// no more data has been received yet.
            /// </summary>
            public byte* buf_end;

            /// <summary>
            /// &lt; A private pointer, passed to the read/write/seek/...
            /// functions.
            /// </summary>
            public void* opaque;

            public global::System.IntPtr read_packet;

            public global::System.IntPtr write_packet;

            public global::System.IntPtr seek;

            /// <summary>
            /// &lt; position in the file of the current buffer
            /// </summary>
            public long pos;

            /// <summary>
            /// &lt; true if the next seek should flush
            /// </summary>
            public int must_flush;

            /// <summary>
            /// &lt; true if eof reached
            /// </summary>
            public int eof_reached;

            /// <summary>
            /// &lt; true if open for writing
            /// </summary>
            public int write_flag;

            public int max_packet_size;

            public uint checksum;

            public byte* checksum_ptr;

            public global::System.IntPtr update_checksum;

            /// <summary>
            /// &lt; contains the error code or 0 if no error happened
            /// </summary>
            public int error;

            /// <summary>
            /// Pause or resume playback for network streaming protocols - e.g. MMS.
            /// </summary>
            public global::System.IntPtr read_pause;

            /// <summary>
            /// Seek to a given timestamp in stream with the specified stream_index.
            /// Needed for some network streaming protocols which don't support seeking
            /// to byte position.
            /// </summary>
            public global::System.IntPtr read_seek;

            /// <summary>
            /// A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not
            /// seekable.
            /// </summary>
            public int seekable;

            /// <summary>
            /// max filesize, used to limit allocations
            /// This field is internal to libavformat and access from outside is not
            /// allowed.
            /// </summary>
            public long maxsize;

            /// <summary>
            /// avio_read and avio_write should if possible be satisfied directly
            /// instead of going through a buffer, and avio_seek will always
            /// call the underlying seek function directly.
            /// </summary>
            public int direct;

            /// <summary>
            /// Bytes read statistic
            /// This field is internal to libavformat and access from outside is not
            /// allowed.
            /// </summary>
            public long bytes_read;

            /// <summary>
            /// seek statistic
            /// This field is internal to libavformat and access from outside is not
            /// allowed.
            /// </summary>
            public int seek_count;

            /// <summary>
            /// writeout statistic
            /// This field is internal to libavformat and access from outside is not
            /// allowed.
            /// </summary>
            public int writeout_count;

            /// <summary>
            /// Original buffer size
            /// used internally after probing and ensure seekback to reset the buffer
            /// size
            /// This field is internal to libavformat and access from outside is not
            /// allowed.
            /// </summary>
            public int orig_buffer_size;

            /// <summary>
            /// Threshold to favor readahead over seek.
            /// This is current internal only, do not use from outside.
            /// </summary>
            public int short_seek_threshold;

            /// <summary>
            /// ',' separated list of allowed protocols.
            /// </summary>
            public sbyte* protocol_whitelist;

            /// <summary>
            /// ',' separated list of disallowed protocols.
            /// </summary>
            public sbyte* protocol_blacklist;

            /// <summary>
            /// A callback that is used instead of write_packet.
            /// </summary>
            public global::System.IntPtr write_data_type;

            /// <summary>
            /// If set, don't call write_data_type separately for
            /// AVIO_DATA_MARKER_BOUNDARY_POINT,
            /// but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid
            /// needlessly
            /// small chunks of data returned from the callback).
            /// </summary>
            public int ignore_boundary_point;

            /// <summary>
            /// Internal, not meant to be used from outside of AVIOContext.
            /// </summary>
            public libavformat.AVIODataMarkerType current_type;

            public long last_time;
        }

        /// <summary>
        /// Return the name of the protocol that will handle the passed URL.
        /// 
        /// NULL is returned if no protocol could be found for the given URL.
        /// </summary>
        /// <returns>
        /// Name of the protocol or NULL.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_find_protocol_name")]
        public static extern sbyte* avio_find_protocol_name(string url);

        /// <summary>
        /// Return AVIO_FLAG_* access flags corresponding to the access permissions
        /// of the resource in url, or a negative value corresponding to an
        /// AVERROR code in case of failure. The returned access flags are
        /// masked by the value in flags.
        /// </summary>
        /// <remark>
        /// This function is intrinsically unsafe, in the sense that the
        /// checked resource may change its existence or permission status from
        /// one call to another. Thus you should not trust the returned value,
        /// unless you are sure that no other processes are accessing the
        /// checked resource.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_check")]
        public static extern int avio_check(string url, int flags);

        /// <summary>
        /// Move or rename a resource.
        /// </summary>
        /// <remark>
        /// url_src and url_dst should share the same protocol and authority.
        /// </remark>
        /// <param name="url_src">
        /// url to resource to be moved
        /// </param>
        /// <param name="url_dst">
        /// new url to resource if the operation succeeded
        /// </param>
        /// <returns>
        /// &gt;=0 on success or negative on error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avpriv_io_move")]
        public static extern int avpriv_io_move(string url_src, string url_dst);

        /// <summary>
        /// Delete a resource.
        /// </summary>
        /// <param name="url">
        /// resource to be deleted.
        /// </param>
        /// <returns>
        /// &gt;=0 on success or negative on error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avpriv_io_delete")]
        public static extern int avpriv_io_delete(string url);

        /// <summary>
        /// Open directory for reading.
        /// </summary>
        /// <param name="s">
        /// directory read context. Pointer to a NULL pointer must be passed.
        /// </param>
        /// <param name="url">
        /// directory to be listed.
        /// </param>
        /// <param name="options">
        /// A dictionary filled with protocol-private options. On return
        /// this parameter will be destroyed and replaced with a dictionary
        /// containing options that were not found. May be NULL.
        /// </param>
        /// <returns>
        /// &gt;=0 on success or negative on error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_open_dir")]
        public static extern int avio_open_dir(libavformat.AVIODirContext** s, string url, libavutil.AVDictionary** options);

        /// <summary>
        /// Open directory for reading.
        /// </summary>
        /// <param name="s">
        /// directory read context. Pointer to a NULL pointer must be passed.
        /// </param>
        /// <param name="url">
        /// directory to be listed.
        /// </param>
        /// <param name="options">
        /// A dictionary filled with protocol-private options. On return
        /// this parameter will be destroyed and replaced with a dictionary
        /// containing options that were not found. May be NULL.
        /// </param>
        /// <returns>
        /// &gt;=0 on success or negative on error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_open_dir")]
        public static extern int avio_open_dir(ref libavformat.AVIODirContext* s, string url, ref libavutil.AVDictionary* options);

        /// <summary>
        /// Get next directory entry.
        /// 
        /// Returned entry must be freed with avio_free_directory_entry(). In
        /// particular
        /// it may outlive AVIODirContext.
        /// </summary>
        /// <param name="s">
        /// directory read context.
        /// </param>
        /// <param name="[out]">
        /// next next entry or NULL when no more entries.
        /// </param>
        /// <returns>
        /// &gt;=0 on success or negative on error. End of list is not considered
        /// an
        /// error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_read_dir")]
        public static extern int avio_read_dir(libavformat.AVIODirContext* s, libavformat.AVIODirEntry** next);

        /// <summary>
        /// Get next directory entry.
        /// 
        /// Returned entry must be freed with avio_free_directory_entry(). In
        /// particular
        /// it may outlive AVIODirContext.
        /// </summary>
        /// <param name="s">
        /// directory read context.
        /// </param>
        /// <param name="[out]">
        /// next next entry or NULL when no more entries.
        /// </param>
        /// <returns>
        /// &gt;=0 on success or negative on error. End of list is not considered
        /// an
        /// error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_read_dir")]
        public static extern int avio_read_dir(libavformat.AVIODirContext* s, ref libavformat.AVIODirEntry* next);

        /// <summary>
        /// Close directory.
        /// </summary>
        /// <remark>
        /// Entries created using avio_read_dir() are not deleted and must be
        /// freeded with avio_free_directory_entry().
        /// </remark>
        /// <param name="s">
        /// directory read context.
        /// </param>
        /// <returns>
        /// &gt;=0 on success or negative on error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_close_dir")]
        public static extern int avio_close_dir(libavformat.AVIODirContext** s);

        /// <summary>
        /// Close directory.
        /// </summary>
        /// <remark>
        /// Entries created using avio_read_dir() are not deleted and must be
        /// freeded with avio_free_directory_entry().
        /// </remark>
        /// <param name="s">
        /// directory read context.
        /// </param>
        /// <returns>
        /// &gt;=0 on success or negative on error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_close_dir")]
        public static extern int avio_close_dir(ref libavformat.AVIODirContext* s);

        /// <summary>
        /// Free entry allocated by avio_read_dir().
        /// </summary>
        /// <param name="entry">
        /// entry to be freed.
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_free_directory_entry")]
        public static extern void avio_free_directory_entry(libavformat.AVIODirEntry** entry);

        /// <summary>
        /// Free entry allocated by avio_read_dir().
        /// </summary>
        /// <param name="entry">
        /// entry to be freed.
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_free_directory_entry")]
        public static extern void avio_free_directory_entry(ref libavformat.AVIODirEntry* entry);

        /// <summary>
        /// Allocate and initialize an AVIOContext for buffered I/O. It must be
        /// later
        /// freed with av_free().
        /// </summary>
        /// <param name="buffer">
        /// Memory block for input/output operations via AVIOContext.
        /// The buffer must be allocated with av_malloc() and friends.
        /// It may be freed and replaced with a new buffer by libavformat.
        /// AVIOContext.buffer holds the buffer currently in use,
        /// which must be later freed with av_free().
        /// </param>
        /// <param name="buffer_size">
        /// The buffer size is very important for performance.
        /// For protocols with fixed blocksize it should be set to this blocksize.
        /// For others a typical size is a cache page, e.g. 4kb.
        /// </param>
        /// <param name="write_flag">
        /// Set to 1 if the buffer should be writable, 0 otherwise.
        /// </param>
        /// <param name="opaque">
        /// An opaque pointer to user-specific data.
        /// </param>
        /// <param name="read_packet">
        /// A function for refilling the buffer, may be NULL.
        /// </param>
        /// <param name="write_packet">
        /// A function for writing the buffer contents, may be NULL.
        /// The function may not change the input buffers content.
        /// </param>
        /// <param name="seek">
        /// A function for seeking to specified byte position, may be NULL.
        /// </param>
        /// <returns>
        /// Allocated AVIOContext or NULL on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_alloc_context")]
        public static extern libavformat.AVIOContext* avio_alloc_context(byte* buffer, int buffer_size, int write_flag, void* opaque, global::System.IntPtr read_packet, global::System.IntPtr write_packet, global::System.IntPtr seek);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_w8")]
        public static extern void avio_w8(libavformat.AVIOContext* s, int b);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_write")]
        public static extern void avio_write(libavformat.AVIOContext* s, byte* buf, int size);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_wl64")]
        public static extern void avio_wl64(libavformat.AVIOContext* s, ulong val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_wb64")]
        public static extern void avio_wb64(libavformat.AVIOContext* s, ulong val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_wl32")]
        public static extern void avio_wl32(libavformat.AVIOContext* s, uint val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_wb32")]
        public static extern void avio_wb32(libavformat.AVIOContext* s, uint val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_wl24")]
        public static extern void avio_wl24(libavformat.AVIOContext* s, uint val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_wb24")]
        public static extern void avio_wb24(libavformat.AVIOContext* s, uint val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_wl16")]
        public static extern void avio_wl16(libavformat.AVIOContext* s, uint val);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_wb16")]
        public static extern void avio_wb16(libavformat.AVIOContext* s, uint val);

        /// <summary>
        /// Write a NULL-terminated string.
        /// </summary>
        /// <returns>
        /// number of bytes written.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_put_str")]
        public static extern int avio_put_str(libavformat.AVIOContext* s, string str);

        /// <summary>
        /// Convert an UTF-8 string to UTF-16LE and write it.
        /// </summary>
        /// <param name="s">
        /// the AVIOContext
        /// </param>
        /// <param name="str">
        /// NULL-terminated UTF-8 string
        /// </param>
        /// <returns>
        /// number of bytes written.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_put_str16le")]
        public static extern int avio_put_str16le(libavformat.AVIOContext* s, string str);

        /// <summary>
        /// Convert an UTF-8 string to UTF-16BE and write it.
        /// </summary>
        /// <param name="s">
        /// the AVIOContext
        /// </param>
        /// <param name="str">
        /// NULL-terminated UTF-8 string
        /// </param>
        /// <returns>
        /// number of bytes written.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_put_str16be")]
        public static extern int avio_put_str16be(libavformat.AVIOContext* s, string str);

        /// <summary>
        /// Mark the written bytestream as a specific type.
        /// 
        /// Zero-length ranges are omitted from the output.
        /// </summary>
        /// <param name="time">
        /// the stream time the current bytestream pos corresponds to
        /// (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not
        /// applicable
        /// </param>
        /// <param name="type">
        /// the kind of data written starting at the current pos
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_write_marker")]
        public static extern void avio_write_marker(libavformat.AVIOContext* s, long time, libavformat.AVIODataMarkerType type);

        /// <summary>
        /// fseek() equivalent for AVIOContext.
        /// </summary>
        /// <returns>
        /// new position or AVERROR.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_seek")]
        public static extern long avio_seek(libavformat.AVIOContext* s, long offset, int whence);

        /// <summary>
        /// Skip given number of bytes forward
        /// </summary>
        /// <returns>
        /// new position or AVERROR.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_skip")]
        public static extern long avio_skip(libavformat.AVIOContext* s, long offset);

        /// <summary>
        /// ftell() equivalent for AVIOContext.
        /// </summary>
        /// <returns>
        /// position or AVERROR.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_tell")]
        public static extern long avio_tell(libavformat.AVIOContext* s);

        /// <summary>
        /// Get the filesize.
        /// </summary>
        /// <returns>
        /// filesize or AVERROR
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_size")]
        public static extern long avio_size(libavformat.AVIOContext* s);

        /// <summary>
        /// feof() equivalent for AVIOContext.
        /// </summary>
        /// <returns>
        /// non zero if and only if end of file
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_feof")]
        public static extern int avio_feof(libavformat.AVIOContext* s);

        [System.ObsoleteAttribute()]
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="url_feof")]
        public static extern int url_feof(libavformat.AVIOContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_printf")]
        public static extern int avio_printf(libavformat.AVIOContext* s, string fmt);

        /// <summary>
        /// Force flushing of buffered data.
        /// 
        /// For write streams, force the buffered data to be immediately written to
        /// the output,
        /// without to wait to fill the internal buffer.
        /// 
        /// For read streams, discard all currently buffered data, and advance the
        /// reported file position to that of the underlying stream. This does not
        /// read new data, and does not perform any seeks.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_flush")]
        public static extern void avio_flush(libavformat.AVIOContext* s);

        /// <summary>
        /// Read size bytes from AVIOContext into buf.
        /// </summary>
        /// <returns>
        /// number of bytes read or AVERROR
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_read")]
        public static extern int avio_read(libavformat.AVIOContext* s, byte* buf, int size);

        /// <summary>
        /// @name Functions for reading from AVIOContext
        /// @{
        /// </summary>
        /// <remark>
        /// return 0 if EOF, so you cannot use it if EOF handling is
        /// necessary
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_r8")]
        public static extern int avio_r8(libavformat.AVIOContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_rl16")]
        public static extern uint avio_rl16(libavformat.AVIOContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_rl24")]
        public static extern uint avio_rl24(libavformat.AVIOContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_rl32")]
        public static extern uint avio_rl32(libavformat.AVIOContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_rl64")]
        public static extern ulong avio_rl64(libavformat.AVIOContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_rb16")]
        public static extern uint avio_rb16(libavformat.AVIOContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_rb24")]
        public static extern uint avio_rb24(libavformat.AVIOContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_rb32")]
        public static extern uint avio_rb32(libavformat.AVIOContext* s);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_rb64")]
        public static extern ulong avio_rb64(libavformat.AVIOContext* s);

        /// <summary>
        /// Read a string from pb into buf. The reading will terminate when either
        /// a NULL character was encountered, maxlen bytes have been read, or
        /// nothing
        /// more can be read from pb. The result is guaranteed to be
        /// NULL-terminated, it
        /// will be truncated if buf is too small.
        /// Note that the string is not interpreted or validated in any way, it
        /// might get truncated in the middle of a sequence for multi-byte
        /// encodings.
        /// </summary>
        /// <returns>
        /// number of bytes read (is always &lt;= maxlen).
        /// If reading ends on EOF or error, the return value will be one more than
        /// bytes actually read.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_get_str")]
        public static extern int avio_get_str(libavformat.AVIOContext* pb, int maxlen, System.Text.StringBuilder buf, int buflen);

        /// <summary>
        /// Read a UTF-16 string from pb and convert it to UTF-8.
        /// The reading will terminate when either a null or invalid character was
        /// encountered or maxlen bytes have been read.
        /// </summary>
        /// <returns>
        /// number of bytes read (is always &lt;= maxlen)
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_get_str16le")]
        public static extern int avio_get_str16le(libavformat.AVIOContext* pb, int maxlen, System.Text.StringBuilder buf, int buflen);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_get_str16be")]
        public static extern int avio_get_str16be(libavformat.AVIOContext* pb, int maxlen, System.Text.StringBuilder buf, int buflen);

        /// <summary>
        /// Create and initialize a AVIOContext for accessing the
        /// resource indicated by url.
        /// </summary>
        /// <remark>
        /// When the resource indicated by url has been opened in
        /// read+write mode, the AVIOContext can be used only for writing.
        /// </remark>
        /// <param name="s">
        /// Used to return the pointer to the created AVIOContext.
        /// In case of failure the pointed to value is set to NULL.
        /// </param>
        /// <param name="url">
        /// resource to access
        /// </param>
        /// <param name="flags">
        /// flags which control how the resource indicated by url
        /// is to be opened
        /// </param>
        /// <returns>
        /// &gt;= 0 in case of success, a negative value corresponding to an
        /// AVERROR code in case of failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_open")]
        public static extern int avio_open(libavformat.AVIOContext** s, string url, int flags);

        /// <summary>
        /// Create and initialize a AVIOContext for accessing the
        /// resource indicated by url.
        /// </summary>
        /// <remark>
        /// When the resource indicated by url has been opened in
        /// read+write mode, the AVIOContext can be used only for writing.
        /// </remark>
        /// <param name="s">
        /// Used to return the pointer to the created AVIOContext.
        /// In case of failure the pointed to value is set to NULL.
        /// </param>
        /// <param name="url">
        /// resource to access
        /// </param>
        /// <param name="flags">
        /// flags which control how the resource indicated by url
        /// is to be opened
        /// </param>
        /// <returns>
        /// &gt;= 0 in case of success, a negative value corresponding to an
        /// AVERROR code in case of failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_open")]
        public static extern int avio_open(ref libavformat.AVIOContext* s, string url, int flags);

        /// <summary>
        /// Create and initialize a AVIOContext for accessing the
        /// resource indicated by url.
        /// </summary>
        /// <remark>
        /// When the resource indicated by url has been opened in
        /// read+write mode, the AVIOContext can be used only for writing.
        /// </remark>
        /// <param name="s">
        /// Used to return the pointer to the created AVIOContext.
        /// In case of failure the pointed to value is set to NULL.
        /// </param>
        /// <param name="url">
        /// resource to access
        /// </param>
        /// <param name="flags">
        /// flags which control how the resource indicated by url
        /// is to be opened
        /// </param>
        /// <param name="int_cb">
        /// an interrupt callback to be used at the protocols level
        /// </param>
        /// <param name="options">
        /// A dictionary filled with protocol-private options. On return
        /// this parameter will be destroyed and replaced with a dict containing
        /// options
        /// that were not found. May be NULL.
        /// </param>
        /// <returns>
        /// &gt;= 0 in case of success, a negative value corresponding to an
        /// AVERROR code in case of failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_open2")]
        public static extern int avio_open2(libavformat.AVIOContext** s, string url, int flags, libavformat.AVIOInterruptCB* int_cb, libavutil.AVDictionary** options);

        /// <summary>
        /// Create and initialize a AVIOContext for accessing the
        /// resource indicated by url.
        /// </summary>
        /// <remark>
        /// When the resource indicated by url has been opened in
        /// read+write mode, the AVIOContext can be used only for writing.
        /// </remark>
        /// <param name="s">
        /// Used to return the pointer to the created AVIOContext.
        /// In case of failure the pointed to value is set to NULL.
        /// </param>
        /// <param name="url">
        /// resource to access
        /// </param>
        /// <param name="flags">
        /// flags which control how the resource indicated by url
        /// is to be opened
        /// </param>
        /// <param name="int_cb">
        /// an interrupt callback to be used at the protocols level
        /// </param>
        /// <param name="options">
        /// A dictionary filled with protocol-private options. On return
        /// this parameter will be destroyed and replaced with a dict containing
        /// options
        /// that were not found. May be NULL.
        /// </param>
        /// <returns>
        /// &gt;= 0 in case of success, a negative value corresponding to an
        /// AVERROR code in case of failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_open2")]
        public static extern int avio_open2(ref libavformat.AVIOContext* s, string url, int flags, libavformat.AVIOInterruptCB* int_cb, ref libavutil.AVDictionary* options);

        /// <summary>
        /// Close the resource accessed by the AVIOContext s and free it.
        /// This function can only be used if s was opened by avio_open().
        /// 
        /// The internal buffer is automatically flushed before closing the
        /// resource.
        /// </summary>
        /// <returns>
        /// 0 on success, an AVERROR &lt; 0 on error.
        /// @see avio_closep
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_close")]
        public static extern int avio_close(libavformat.AVIOContext* s);

        /// <summary>
        /// Close the resource accessed by the AVIOContext *s, free it
        /// and set the pointer pointing to it to NULL.
        /// This function can only be used if s was opened by avio_open().
        /// 
        /// The internal buffer is automatically flushed before closing the
        /// resource.
        /// </summary>
        /// <returns>
        /// 0 on success, an AVERROR &lt; 0 on error.
        /// @see avio_close
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_closep")]
        public static extern int avio_closep(libavformat.AVIOContext** s);

        /// <summary>
        /// Close the resource accessed by the AVIOContext *s, free it
        /// and set the pointer pointing to it to NULL.
        /// This function can only be used if s was opened by avio_open().
        /// 
        /// The internal buffer is automatically flushed before closing the
        /// resource.
        /// </summary>
        /// <returns>
        /// 0 on success, an AVERROR &lt; 0 on error.
        /// @see avio_close
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_closep")]
        public static extern int avio_closep(ref libavformat.AVIOContext* s);

        /// <summary>
        /// Open a write only memory stream.
        /// </summary>
        /// <param name="s">
        /// new IO context
        /// </param>
        /// <returns>
        /// zero if no error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_open_dyn_buf")]
        public static extern int avio_open_dyn_buf(libavformat.AVIOContext** s);

        /// <summary>
        /// Open a write only memory stream.
        /// </summary>
        /// <param name="s">
        /// new IO context
        /// </param>
        /// <returns>
        /// zero if no error.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_open_dyn_buf")]
        public static extern int avio_open_dyn_buf(ref libavformat.AVIOContext* s);

        /// <summary>
        /// Return the written size and a pointer to the buffer. The buffer
        /// must be freed with av_free().
        /// Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.
        /// </summary>
        /// <param name="s">
        /// IO context
        /// </param>
        /// <param name="pbuffer">
        /// pointer to a byte buffer
        /// </param>
        /// <returns>
        /// the length of the byte buffer
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_close_dyn_buf")]
        public static extern int avio_close_dyn_buf(libavformat.AVIOContext* s, byte** pbuffer);

        /// <summary>
        /// Return the written size and a pointer to the buffer. The buffer
        /// must be freed with av_free().
        /// Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.
        /// </summary>
        /// <param name="s">
        /// IO context
        /// </param>
        /// <param name="pbuffer">
        /// pointer to a byte buffer
        /// </param>
        /// <returns>
        /// the length of the byte buffer
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_close_dyn_buf")]
        public static extern int avio_close_dyn_buf(libavformat.AVIOContext* s, ref byte* pbuffer);

        /// <summary>
        /// Iterate through names of available protocols.
        /// </summary>
        /// <param name="opaque">
        /// A private pointer representing current protocol.
        /// It must be a pointer to NULL on first iteration and will
        /// be updated by successive calls to avio_enum_protocols.
        /// </param>
        /// <param name="output">
        /// If set to 1, iterate over output protocols,
        /// otherwise over input protocols.
        /// </param>
        /// <returns>
        /// A static string containing the name of current protocol or NULL
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_enum_protocols")]
        public static extern sbyte* avio_enum_protocols(void** opaque, int output);

        /// <summary>
        /// Iterate through names of available protocols.
        /// </summary>
        /// <param name="opaque">
        /// A private pointer representing current protocol.
        /// It must be a pointer to NULL on first iteration and will
        /// be updated by successive calls to avio_enum_protocols.
        /// </param>
        /// <param name="output">
        /// If set to 1, iterate over output protocols,
        /// otherwise over input protocols.
        /// </param>
        /// <returns>
        /// A static string containing the name of current protocol or NULL
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_enum_protocols")]
        public static extern sbyte* avio_enum_protocols(ref void* opaque, int output);

        /// <summary>
        /// Pause and resume playing - only meaningful if using a network streaming
        /// protocol (e.g. MMS).
        /// </summary>
        /// <param name="h">
        /// IO context from which to call the read_pause function pointer
        /// </param>
        /// <param name="pause">
        /// 1 for pause, 0 for resume
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_pause")]
        public static extern int avio_pause(libavformat.AVIOContext* h, int pause);

        /// <summary>
        /// Seek to a given timestamp relative to some component stream.
        /// Only meaningful if using a network streaming protocol (e.g. MMS.).
        /// </summary>
        /// <param name="h">
        /// IO context from which to call the seek function pointers
        /// </param>
        /// <param name="stream_index">
        /// The stream index that the timestamp is relative to.
        /// If stream_index is (-1) the timestamp should be in AV_TIME_BASE
        /// units from the beginning of the presentation.
        /// If a stream_index &gt;= 0 is used and the protocol does not support
        /// seeking based on component streams, the call will fail.
        /// </param>
        /// <param name="timestamp">
        /// timestamp in AVStream.time_base units
        /// or if there is no stream specified then in AV_TIME_BASE units.
        /// </param>
        /// <param name="flags">
        /// Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE
        /// and AVSEEK_FLAG_ANY. The protocol may silently ignore
        /// AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will
        /// fail if used and not supported.
        /// </param>
        /// <returns>
        /// &gt;= 0 on success
        /// @see AVInputFormat::read_seek
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_seek_time")]
        public static extern long avio_seek_time(libavformat.AVIOContext* h, int stream_index, long timestamp, int flags);

        /// <summary>
        /// Read contents of h into print buffer, up to max_size bytes, or up to
        /// EOF.
        /// </summary>
        /// <returns>
        /// 0 for success (max_size bytes read or EOF reached), negative error
        /// code otherwise
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_read_to_bprint")]
        public static extern int avio_read_to_bprint(libavformat.AVIOContext* h, AVBPrint* pb, global::System.UIntPtr max_size);

        /// <summary>
        /// Accept and allocate a client context on a server context.
        /// </summary>
        /// <param name="s">
        /// the server context
        /// </param>
        /// <param name="c">
        /// the client context, must be unallocated
        /// </param>
        /// <returns>
        /// &gt;= 0 on success or a negative value corresponding
        /// to an AVERROR on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_accept")]
        public static extern int avio_accept(libavformat.AVIOContext* s, libavformat.AVIOContext** c);

        /// <summary>
        /// Accept and allocate a client context on a server context.
        /// </summary>
        /// <param name="s">
        /// the server context
        /// </param>
        /// <param name="c">
        /// the client context, must be unallocated
        /// </param>
        /// <returns>
        /// &gt;= 0 on success or a negative value corresponding
        /// to an AVERROR on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_accept")]
        public static extern int avio_accept(libavformat.AVIOContext* s, ref libavformat.AVIOContext* c);

        /// <summary>
        /// Perform one step of the protocol handshake to accept a new client.
        /// This function must be called on a client returned by avio_accept()
        /// before
        /// using it as a read/write context.
        /// It is separate from avio_accept() because it may block.
        /// A step of the handshake is defined by places where the application may
        /// decide to change the proceedings.
        /// For example, on a protocol with a request header and a reply header,
        /// each
        /// one can constitute a step because the application may use the
        /// parameters
        /// from the request to change parameters in the reply; or each individual
        /// chunk of the request can constitute a step.
        /// If the handshake is already finished, avio_handshake() does nothing and
        /// returns 0 immediately.
        /// </summary>
        /// <param name="c">
        /// the client context to perform the handshake on
        /// </param>
        /// <returns>
        /// 0   on a complete and successful handshake
        /// &gt; 0 if the handshake progressed, but is not complete
        /// &lt; 0 for an AVERROR code
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVFORMAT_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="avio_handshake")]
        public static extern int avio_handshake(libavformat.AVIOContext* c);
    }
}
