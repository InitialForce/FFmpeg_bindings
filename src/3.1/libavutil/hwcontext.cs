//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
// ReSharper disable RedundantUsingDirective
// ReSharper disable CheckNamespace
#pragma warning disable 1584,1711,1572,1581,1580,1573
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FFmpeg
{
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "UnusedMember.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "InconsistentNaming")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantUnsafeContext")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "FieldCanBeMadeReadOnly.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "PartialTypeWithSinglePart")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantNameQualifier")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "ArrangeModifiersOrder")]
    public unsafe static partial class libavutil
    {
        public enum AVHWDeviceType
        {
            AV_HWDEVICE_TYPE_VDPAU = 0,
            AV_HWDEVICE_TYPE_CUDA = 1,
            AV_HWDEVICE_TYPE_VAAPI = 2,
            AV_HWDEVICE_TYPE_DXVA2 = 3
        }

        public enum AVHWFrameTransferDirection
        {
            /// <summary>Transfer the data from the queried hw frame.</summary>
            AV_HWFRAME_TRANSFER_DIRECTION_FROM = 0,
            /// <summary>Transfer the data to the queried hw frame.</summary>
            AV_HWFRAME_TRANSFER_DIRECTION_TO = 1
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVHWDeviceInternal
        {
        }

        /// <summary>
        /// This struct aggregates all the (hardware/vendor-specific) "high-level"
        /// state,
        /// i.e. state that is not tied to a concrete processing configuration.
        /// E.g., in an API that supports hardware-accelerated encoding and
        /// decoding,
        /// this struct will (if possible) wrap the state that is common to both
        /// encoding
        /// and decoding and from which specific instances of encoders or decoders
        /// can be
        /// derived.
        /// 
        /// This struct is reference-counted with the AVBuffer mechanism. The
        /// av_hwdevice_ctx_alloc() constructor yields a reference, whose data
        /// field
        /// points to the actual AVHWDeviceContext. Further objects derived from
        /// AVHWDeviceContext (such as AVHWFramesContext, describing a frame pool
        /// with
        /// specific properties) will hold an internal reference to it. After all
        /// the
        /// references are released, the AVHWDeviceContext itself will be freed,
        /// optionally invoking a user-specified callback for uninitializing the
        /// hardware
        /// state.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVHWDeviceContext
        {
            /// <summary>
            /// A class for logging. Set by av_hwdevice_ctx_alloc().
            /// </summary>
            public libavutil.AVClass* av_class;

            /// <summary>
            /// Private data used internally by libavutil. Must not be accessed in any
            /// way by the caller.
            /// </summary>
            public libavutil.AVHWDeviceInternal* @internal;

            /// <summary>
            /// This field identifies the underlying API used for hardware access.
            /// 
            /// This field is set when this struct is allocated and never changed
            /// afterwards.
            /// </summary>
            public libavutil.AVHWDeviceType type;

            /// <summary>
            /// The format-specific data, allocated and freed by libavutil along with
            /// this context.
            /// 
            /// Should be cast by the user to the format-specific context defined in
            /// the
            /// corresponding header (hwcontext_*.h) and filled as described in the
            /// documentation before calling av_hwdevice_ctx_init().
            /// 
            /// After calling av_hwdevice_ctx_init() this struct should not be modified
            /// by the caller.
            /// </summary>
            public void* hwctx;

            /// <summary>
            /// This field may be set by the caller before calling
            /// av_hwdevice_ctx_init().
            /// 
            /// If non-NULL, this callback will be called when the last reference to
            /// this context is unreferenced, immediately before it is freed.
            /// </summary>
            /// <remark>
            /// when other objects (e.g an AVHWFramesContext) are derived from this
            /// struct, this callback will be invoked after all such child objects
            /// are fully uninitialized and their respective destructors invoked.
            /// </remark>
            public global::System.IntPtr free;

            /// <summary>
            /// Arbitrary user data, to be used e.g. by the free() callback.
            /// </summary>
            public void* user_opaque;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVHWFramesInternal
        {
        }

        /// <summary>
        /// This struct describes a set or pool of "hardware" frames (i.e. those
        /// with
        /// data not located in normal system memory). All the frames in the pool
        /// are
        /// assumed to be allocated in the same way and interchangeable.
        /// 
        /// This struct is reference-counted with the AVBuffer mechanism and tied
        /// to a
        /// given AVHWDeviceContext instance. The av_hwframe_ctx_alloc()
        /// constructor
        /// yields a reference, whose data field points to the actual
        /// AVHWFramesContext
        /// struct.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVHWFramesContext
        {
            /// <summary>
            /// A class for logging.
            /// </summary>
            public libavutil.AVClass* av_class;

            /// <summary>
            /// Private data used internally by libavutil. Must not be accessed in any
            /// way by the caller.
            /// </summary>
            public libavutil.AVHWFramesInternal* @internal;

            /// <summary>
            /// A reference to the parent AVHWDeviceContext. This reference is owned
            /// and
            /// managed by the enclosing AVHWFramesContext, but the caller may derive
            /// additional references from it.
            /// </summary>
            public libavutil.AVBufferRef* device_ref;

            /// <summary>
            /// The parent AVHWDeviceContext. This is simply a pointer to
            /// device_ref-&gt;data provided for convenience.
            /// 
            /// Set by libavutil in av_hwframe_ctx_init().
            /// </summary>
            public libavutil.AVHWDeviceContext* device_ctx;

            /// <summary>
            /// The format-specific data, allocated and freed automatically along with
            /// this context.
            /// 
            /// Should be cast by the user to the format-specific context defined in
            /// the
            /// corresponding header (hwframe_*.h) and filled as described in the
            /// documentation before calling av_hwframe_ctx_init().
            /// 
            /// After any frames using this context are created, the contents of this
            /// struct should not be modified by the caller.
            /// </summary>
            public void* hwctx;

            /// <summary>
            /// This field may be set by the caller before calling
            /// av_hwframe_ctx_init().
            /// 
            /// If non-NULL, this callback will be called when the last reference to
            /// this context is unreferenced, immediately before it is freed.
            /// </summary>
            public global::System.IntPtr free;

            /// <summary>
            /// Arbitrary user data, to be used e.g. by the free() callback.
            /// </summary>
            public void* user_opaque;

            /// <summary>
            /// A pool from which the frames are allocated by av_hwframe_get_buffer().
            /// This field may be set by the caller before calling
            /// av_hwframe_ctx_init().
            /// The buffers returned by calling av_buffer_pool_get() on this pool must
            /// have the properties described in the documentation in the corresponding
            /// hw
            /// type's header (hwcontext_*.h). The pool will be freed strictly before
            /// this struct's free() callback is invoked.
            /// 
            /// This field may be NULL, then libavutil will attempt to allocate a pool
            /// internally. Note that certain device types enforce pools allocated at
            /// fixed size (frame count), which cannot be extended dynamically. In such
            /// a
            /// case, initial_pool_size must be set appropriately.
            /// </summary>
            public libavutil.AVBufferPool* pool;

            /// <summary>
            /// Initial size of the frame pool. If a device type does not support
            /// dynamically resizing the pool, then this is also the maximum pool size.
            /// 
            /// May be set by the caller before calling av_hwframe_ctx_init(). Must be
            /// set if pool is NULL and the device type does not support dynamic pools.
            /// </summary>
            public int initial_pool_size;

            /// <summary>
            /// The pixel format identifying the underlying HW surface type.
            /// 
            /// Must be a hwaccel format, i.e. the corresponding descriptor must have
            /// the
            /// AV_PIX_FMT_FLAG_HWACCEL flag set.
            /// 
            /// Must be set by the user before calling av_hwframe_ctx_init().
            /// </summary>
            public libavutil.AVPixelFormat format;

            /// <summary>
            /// The pixel format identifying the actual data layout of the hardware
            /// frames.
            /// 
            /// Must be set by the caller before calling av_hwframe_ctx_init().
            /// </summary>
            /// <remark>
            /// when the underlying API does not provide the exact data layout, but
            /// only the colorspace/bit depth, this field should be set to the fully
            /// planar version of that format (e.g. for 8-bit 420 YUV it should be
            /// AV_PIX_FMT_YUV420P, not AV_PIX_FMT_NV12 or anything else).
            /// </remark>
            public libavutil.AVPixelFormat sw_format;

            /// <summary>
            /// The allocated dimensions of the frames in this pool.
            /// 
            /// Must be set by the user before calling av_hwframe_ctx_init().
            /// </summary>
            public int width;

            /// <summary>
            /// The allocated dimensions of the frames in this pool.
            /// 
            /// Must be set by the user before calling av_hwframe_ctx_init().
            /// </summary>
            public int height;
        }

        /// <summary>
        /// This struct describes the constraints on hardware frames attached to
        /// a given device with a hardware-specific configuration.  This is
        /// returned
        /// by av_hwdevice_get_hwframe_constraints() and must be freed by
        /// av_hwframe_constraints_free() after use.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVHWFramesConstraints
        {
            /// <summary>
            /// A list of possible values for format in the hw_frames_ctx,
            /// terminated by AV_PIX_FMT_NONE.  This member will always be filled.
            /// </summary>
            public libavutil.AVPixelFormat* valid_hw_formats;

            /// <summary>
            /// A list of possible values for sw_format in the hw_frames_ctx,
            /// terminated by AV_PIX_FMT_NONE.  Can be NULL if this information is
            /// not known.
            /// </summary>
            public libavutil.AVPixelFormat* valid_sw_formats;

            /// <summary>
            /// The minimum size of frames in this hw_frames_ctx.
            /// (Zero if not known.)
            /// </summary>
            public int min_width;

            public int min_height;

            /// <summary>
            /// The maximum size of frames in this hw_frames_ctx.
            /// (INT_MAX if not known / no limit.)
            /// </summary>
            public int max_width;

            public int max_height;
        }

        /// <summary>
        /// Allocate an AVHWDeviceContext for a given pixel format.
        /// </summary>
        /// <param name="format">
        /// a hwaccel pixel format (AV_PIX_FMT_FLAG_HWACCEL must be set
        /// on the corresponding format descriptor)
        /// </param>
        /// <returns>
        /// a reference to the newly created AVHWDeviceContext on success or NULL
        /// on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwdevice_ctx_alloc")]
        public static extern libavutil.AVBufferRef* av_hwdevice_ctx_alloc(libavutil.AVHWDeviceType type);

        /// <summary>
        /// Finalize the device context before use. This function must be called
        /// after
        /// the context is filled with all the required information and before it
        /// is
        /// used in any way.
        /// </summary>
        /// <param name="ref">
        /// a reference to the AVHWDeviceContext
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR code on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwdevice_ctx_init")]
        public static extern int av_hwdevice_ctx_init(libavutil.AVBufferRef* _ref);

        /// <summary>
        /// Open a device of the specified type and create an AVHWDeviceContext for
        /// it.
        /// 
        /// This is a convenience function intended to cover the simple cases.
        /// Callers
        /// who need to fine-tune device creation/management should open the device
        /// manually and then wrap it in an AVHWDeviceContext using
        /// av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init().
        /// 
        /// The returned context is already initialized and ready for use, the
        /// caller
        /// should not call av_hwdevice_ctx_init() on it. The user_opaque/free
        /// fields of
        /// the created AVHWDeviceContext are set by this function and should not
        /// be
        /// touched by the caller.
        /// </summary>
        /// <param name="device_ctx">
        /// On success, a reference to the newly-created device context
        /// will be written here. The reference is owned by the caller
        /// and must be released with av_buffer_unref() when no longer
        /// needed. On failure, NULL will be written to this pointer.
        /// </param>
        /// <param name="type">
        /// The type of the device to create.
        /// </param>
        /// <param name="device">
        /// A type-specific string identifying the device to open.
        /// </param>
        /// <param name="opts">
        /// A dictionary of additional (type-specific) options to use in
        /// opening the device. The dictionary remains owned by the caller.
        /// </param>
        /// <param name="flags">
        /// currently unused
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR code on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwdevice_ctx_create")]
        public static extern int av_hwdevice_ctx_create(libavutil.AVBufferRef** device_ctx, libavutil.AVHWDeviceType type, string device, libavutil.AVDictionary* opts, int flags);

        /// <summary>
        /// Open a device of the specified type and create an AVHWDeviceContext for
        /// it.
        /// 
        /// This is a convenience function intended to cover the simple cases.
        /// Callers
        /// who need to fine-tune device creation/management should open the device
        /// manually and then wrap it in an AVHWDeviceContext using
        /// av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init().
        /// 
        /// The returned context is already initialized and ready for use, the
        /// caller
        /// should not call av_hwdevice_ctx_init() on it. The user_opaque/free
        /// fields of
        /// the created AVHWDeviceContext are set by this function and should not
        /// be
        /// touched by the caller.
        /// </summary>
        /// <param name="device_ctx">
        /// On success, a reference to the newly-created device context
        /// will be written here. The reference is owned by the caller
        /// and must be released with av_buffer_unref() when no longer
        /// needed. On failure, NULL will be written to this pointer.
        /// </param>
        /// <param name="type">
        /// The type of the device to create.
        /// </param>
        /// <param name="device">
        /// A type-specific string identifying the device to open.
        /// </param>
        /// <param name="opts">
        /// A dictionary of additional (type-specific) options to use in
        /// opening the device. The dictionary remains owned by the caller.
        /// </param>
        /// <param name="flags">
        /// currently unused
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR code on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwdevice_ctx_create")]
        public static extern int av_hwdevice_ctx_create(ref libavutil.AVBufferRef* device_ctx, libavutil.AVHWDeviceType type, string device, libavutil.AVDictionary* opts, int flags);

        /// <summary>
        /// Allocate an AVHWFramesContext tied to a given device context.
        /// </summary>
        /// <param name="device_ctx">
        /// a reference to a AVHWDeviceContext. This function will make
        /// a new reference for internal use, the one passed to the
        /// function remains owned by the caller.
        /// </param>
        /// <returns>
        /// a reference to the newly created AVHWFramesContext on success or NULL
        /// on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwframe_ctx_alloc")]
        public static extern libavutil.AVBufferRef* av_hwframe_ctx_alloc(libavutil.AVBufferRef* device_ctx);

        /// <summary>
        /// Finalize the context before use. This function must be called after the
        /// context is filled with all the required information and before it is
        /// attached
        /// to any frames.
        /// </summary>
        /// <param name="ref">
        /// a reference to the AVHWFramesContext
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR code on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwframe_ctx_init")]
        public static extern int av_hwframe_ctx_init(libavutil.AVBufferRef* _ref);

        /// <summary>
        /// Allocate a new frame attached to the given AVHWFramesContext.
        /// </summary>
        /// <param name="hwframe_ctx">
        /// a reference to an AVHWFramesContext
        /// </param>
        /// <param name="frame">
        /// an empty (freshly allocated or unreffed) frame to be filled with
        /// newly allocated buffers.
        /// </param>
        /// <param name="flags">
        /// currently unused, should be set to zero
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR code on failure
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwframe_get_buffer")]
        public static extern int av_hwframe_get_buffer(libavutil.AVBufferRef* hwframe_ctx, libavutil.AVFrame* frame, int flags);

        /// <summary>
        /// Copy data to or from a hw surface. At least one of dst/src must have an
        /// AVHWFramesContext attached.
        /// 
        /// If src has an AVHWFramesContext attached, then the format of dst (if
        /// set)
        /// must use one of the formats returned by
        /// av_hwframe_transfer_get_formats(src,
        /// AV_HWFRAME_TRANSFER_DIRECTION_FROM).
        /// If dst has an AVHWFramesContext attached, then the format of src must
        /// use one
        /// of the formats returned by av_hwframe_transfer_get_formats(dst,
        /// AV_HWFRAME_TRANSFER_DIRECTION_TO)
        /// 
        /// dst may be "clean" (i.e. with data/buf pointers unset), in which case
        /// the
        /// data buffers will be allocated by this function using
        /// av_frame_get_buffer().
        /// If dst-&gt;format is set, then this format will be used, otherwise
        /// (when
        /// dst-&gt;format is AV_PIX_FMT_NONE) the first acceptable format will be
        /// chosen.
        /// </summary>
        /// <param name="dst">
        /// the destination frame. dst is not touched on failure.
        /// </param>
        /// <param name="src">
        /// the source frame.
        /// </param>
        /// <param name="flags">
        /// currently unused, should be set to zero
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR error code on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwframe_transfer_data")]
        public static extern int av_hwframe_transfer_data(libavutil.AVFrame* dst, libavutil.AVFrame* src, int flags);

        /// <summary>
        /// Get a list of possible source or target formats usable in
        /// av_hwframe_transfer_data().
        /// </summary>
        /// <param name="hwframe_ctx">
        /// the frame context to obtain the information for
        /// </param>
        /// <param name="dir">
        /// the direction of the transfer
        /// </param>
        /// <param name="formats">
        /// the pointer to the output format list will be written here.
        /// The list is terminated with AV_PIX_FMT_NONE and must be freed
        /// by the caller when no longer needed using av_free().
        /// If this function returns successfully, the format list will
        /// have at least one item (not counting the terminator).
        /// On failure, the contents of this pointer are unspecified.
        /// </param>
        /// <param name="flags">
        /// currently unused, should be set to zero
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR code on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwframe_transfer_get_formats")]
        public static extern int av_hwframe_transfer_get_formats(libavutil.AVBufferRef* hwframe_ctx, libavutil.AVHWFrameTransferDirection dir, libavutil.AVPixelFormat** formats, int flags);

        /// <summary>
        /// Get a list of possible source or target formats usable in
        /// av_hwframe_transfer_data().
        /// </summary>
        /// <param name="hwframe_ctx">
        /// the frame context to obtain the information for
        /// </param>
        /// <param name="dir">
        /// the direction of the transfer
        /// </param>
        /// <param name="formats">
        /// the pointer to the output format list will be written here.
        /// The list is terminated with AV_PIX_FMT_NONE and must be freed
        /// by the caller when no longer needed using av_free().
        /// If this function returns successfully, the format list will
        /// have at least one item (not counting the terminator).
        /// On failure, the contents of this pointer are unspecified.
        /// </param>
        /// <param name="flags">
        /// currently unused, should be set to zero
        /// </param>
        /// <returns>
        /// 0 on success, a negative AVERROR code on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwframe_transfer_get_formats")]
        public static extern int av_hwframe_transfer_get_formats(libavutil.AVBufferRef* hwframe_ctx, libavutil.AVHWFrameTransferDirection dir, ref libavutil.AVPixelFormat* formats, int flags);

        /// <summary>
        /// Allocate a HW-specific configuration structure for a given HW device.
        /// After use, the user must free all members as required by the specific
        /// hardware structure being used, then free the structure itself with
        /// av_free().
        /// </summary>
        /// <param name="device_ctx">
        /// a reference to the associated AVHWDeviceContext.
        /// </param>
        /// <returns>
        /// The newly created HW-specific configuration structure on
        /// success or NULL on failure.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwdevice_hwconfig_alloc")]
        public static extern void* av_hwdevice_hwconfig_alloc(libavutil.AVBufferRef* device_ctx);

        /// <summary>
        /// Get the constraints on HW frames given a device and the HW-specific
        /// configuration to be used with that device.  If no HW-specific
        /// configuration is provided, returns the maximum possible capabilities
        /// of the device.
        /// </summary>
        /// <param name="device_ctx">
        /// a reference to the associated AVHWDeviceContext.
        /// </param>
        /// <param name="hwconfig">
        /// a filled HW-specific configuration structure, or NULL
        /// to return the maximum possible capabilities of the device.
        /// </param>
        /// <returns>
        /// AVHWFramesConstraints structure describing the constraints
        /// on the device, or NULL if not available.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwdevice_get_hwframe_constraints")]
        public static extern libavutil.AVHWFramesConstraints* av_hwdevice_get_hwframe_constraints(libavutil.AVBufferRef* _ref, void* hwconfig);

        /// <summary>
        /// Free an AVHWFrameConstraints structure.
        /// </summary>
        /// <param name="constraints">
        /// The (filled or unfilled) AVHWFrameConstraints structure.
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwframe_constraints_free")]
        public static extern void av_hwframe_constraints_free(libavutil.AVHWFramesConstraints** constraints);

        /// <summary>
        /// Free an AVHWFrameConstraints structure.
        /// </summary>
        /// <param name="constraints">
        /// The (filled or unfilled) AVHWFrameConstraints structure.
        /// </param>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_hwframe_constraints_free")]
        public static extern void av_hwframe_constraints_free(ref libavutil.AVHWFramesConstraints* constraints);
    }
}
