//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
// ReSharper disable RedundantUsingDirective
// ReSharper disable CheckNamespace
#pragma warning disable 1584,1711,1572,1581,1580,1573
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace FFmpeg
{
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "UnusedMember.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "InconsistentNaming")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantUnsafeContext")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "MemberCanBePrivate.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "FieldCanBeMadeReadOnly.Global")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "PartialTypeWithSinglePart")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "RedundantNameQualifier")]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("ReSharper", "ArrangeModifiersOrder")]
    public unsafe static partial class libavutil
    {
        /// <summary>
        /// @addtogroup lavu_tree AVTree
        /// @ingroup lavu_data
        /// 
        /// Low-complexity tree container
        /// 
        /// Insertion, removal, finding equal, largest which is smaller than and
        /// smallest which is larger than, all have O(log n) worst-case complexity.
        /// @{
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe partial struct AVTreeNode
        {
        }

        /// <summary>
        /// Allocate an AVTreeNode.
        /// </summary>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_tree_node_alloc")]
        public static extern libavutil.AVTreeNode* av_tree_node_alloc();

        /// <summary>
        /// Find an element.
        /// </summary>
        /// <param name="root">
        /// a pointer to the root node of the tree
        /// </param>
        /// <param name="next">
        /// If next is not NULL, then next[0] will contain the previous
        /// element and next[1] the next element. If either does not exist,
        /// then the corresponding entry in next is unchanged.
        /// </param>
        /// <param name="cmp">
        /// compare function used to compare elements in the tree,
        /// API identical to that of Standard C's qsort
        /// It is guranteed that the first and only the first argument to cmp()
        /// will be the key parameter to av_tree_find(), thus it could if the
        /// user wants, be a different type (like an opaque context).
        /// </param>
        /// <returns>
        /// An element with cmp(key, elem) == 0 or NULL if no such element
        /// exists in the tree.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_tree_find")]
        public static extern void* av_tree_find(libavutil.AVTreeNode* root, void* key, global::System.IntPtr cmp, void** next);

        /// <summary>
        /// Insert or remove an element.
        /// 
        /// If *next is NULL, then the supplied element will be removed if it
        /// exists.
        /// If *next is non-NULL, then the supplied element will be inserted,
        /// unless
        /// it already exists in the tree.
        /// </summary>
        /// <param name="rootp">
        /// A pointer to a pointer to the root node of the tree; note that
        /// the root node can change during insertions, this is required
        /// to keep the tree balanced.
        /// </param>
        /// <param name="key">
        /// pointer to the element key to insert in the tree
        /// </param>
        /// <param name="next">
        /// Used to allocate and free AVTreeNodes. For insertion the user
        /// must set it to an allocated and zeroed object of at least
        /// av_tree_node_size bytes size. av_tree_insert() will set it to
        /// NULL if it has been consumed.
        /// For deleting elements *next is set to NULL by the user and
        /// av_tree_insert() will set it to the AVTreeNode which was
        /// used for the removed element.
        /// This allows the use of flat arrays, which have
        /// lower overhead compared to many malloced elements.
        /// You might want to define a function like:
        /// </param>
        /// <code>
        /// void *tree_insert(struct AVTreeNode **rootp, void *key,
        /// int (*cmp)(void *key, const void *b),
        /// AVTreeNode **next)
        /// {
        /// if (!*next)
        /// next = av_mallocz(av_tree_node_size);
        /// return av_tree_insert(rootp, key, cmp, next);
        /// }
        /// void *tree_remove(struct AVTreeNode **rootp, void *key,
        /// int (*cmp)(void *key, const void *b, AVTreeNode **next))
        /// {
        /// av_freep(next);
        /// return av_tree_insert(rootp, key, cmp, next);
        /// }
        /// </code>
        /// <param name="cmp">
        /// compare function used to compare elements in the tree, API identical
        /// to that of Standard C's qsort
        /// </param>
        /// <returns>
        /// If no insertion happened, the found element; if an insertion or
        /// removal happened, then either key or NULL will be returned.
        /// Which one it is depends on the tree state and the implementation. You
        /// should make no assumptions that it's one or the other in the code.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_tree_insert")]
        public static extern void* av_tree_insert(libavutil.AVTreeNode** rootp, void* key, global::System.IntPtr cmp, libavutil.AVTreeNode** next);

        /// <summary>
        /// Insert or remove an element.
        /// 
        /// If *next is NULL, then the supplied element will be removed if it
        /// exists.
        /// If *next is non-NULL, then the supplied element will be inserted,
        /// unless
        /// it already exists in the tree.
        /// </summary>
        /// <param name="rootp">
        /// A pointer to a pointer to the root node of the tree; note that
        /// the root node can change during insertions, this is required
        /// to keep the tree balanced.
        /// </param>
        /// <param name="key">
        /// pointer to the element key to insert in the tree
        /// </param>
        /// <param name="next">
        /// Used to allocate and free AVTreeNodes. For insertion the user
        /// must set it to an allocated and zeroed object of at least
        /// av_tree_node_size bytes size. av_tree_insert() will set it to
        /// NULL if it has been consumed.
        /// For deleting elements *next is set to NULL by the user and
        /// av_tree_insert() will set it to the AVTreeNode which was
        /// used for the removed element.
        /// This allows the use of flat arrays, which have
        /// lower overhead compared to many malloced elements.
        /// You might want to define a function like:
        /// </param>
        /// <code>
        /// void *tree_insert(struct AVTreeNode **rootp, void *key,
        /// int (*cmp)(void *key, const void *b),
        /// AVTreeNode **next)
        /// {
        /// if (!*next)
        /// next = av_mallocz(av_tree_node_size);
        /// return av_tree_insert(rootp, key, cmp, next);
        /// }
        /// void *tree_remove(struct AVTreeNode **rootp, void *key,
        /// int (*cmp)(void *key, const void *b, AVTreeNode **next))
        /// {
        /// av_freep(next);
        /// return av_tree_insert(rootp, key, cmp, next);
        /// }
        /// </code>
        /// <param name="cmp">
        /// compare function used to compare elements in the tree, API identical
        /// to that of Standard C's qsort
        /// </param>
        /// <returns>
        /// If no insertion happened, the found element; if an insertion or
        /// removal happened, then either key or NULL will be returned.
        /// Which one it is depends on the tree state and the implementation. You
        /// should make no assumptions that it's one or the other in the code.
        /// </returns>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_tree_insert")]
        public static extern void* av_tree_insert(ref libavutil.AVTreeNode* rootp, void* key, global::System.IntPtr cmp, ref libavutil.AVTreeNode* next);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_tree_destroy")]
        public static extern void av_tree_destroy(libavutil.AVTreeNode* t);

        /// <summary>
        /// Apply enu(opaque, &elem) to all the elements in the tree in a given
        /// range.
        /// </summary>
        /// <param name="cmp">
        /// a comparison function that returns &lt; 0 for an element below the
        /// range, &gt; 0 for an element above the range and == 0 for an
        /// element inside the range
        /// </param>
        /// <remark>
        /// The cmp function should use the same ordering used to construct the
        /// tree.
        /// </remark>
        [SuppressUnmanagedCodeSecurity]
        [DllImport(AVUTIL_DLL_NAME, CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
            CharSet = CharSet.Ansi, ExactSpelling = true,
            EntryPoint="av_tree_enumerate")]
        public static extern void av_tree_enumerate(libavutil.AVTreeNode* t, void* opaque, global::System.IntPtr cmp, global::System.IntPtr enu);
    }
}
